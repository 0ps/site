/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 13);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

eval("/**\n * vue-router v2.0.0-rc.3\n * (c) 2016 Evan You\n * @license MIT\n */\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.VueRouter = factory());\n}(this, function () { 'use strict';\n\n\tvar View = {\n\t  name: 'router-view',\n\t  functional: true,\n\t  props: {\n\t    name: {\n\t      type: String,\n\t      default: 'default'\n\t    }\n\t  },\n\t  render: function render (h, ref) {\n\t    var props = ref.props;\n\t    var children = ref.children;\n\t    var parent = ref.parent;\n\t    var data = ref.data;\n\n\t    data.routerView = true\n\n\t    var route = parent.$route\n\t    var cache = parent._routerViewCache || (parent._routerViewCache = {})\n\t    var depth = 0\n\t    var inactive = false\n\n\t    while (parent) {\n\t      if (parent.$vnode && parent.$vnode.data.routerView) {\n\t        depth++\n\t      }\n\t      if (parent._inactive) {\n\t        inactive = true\n\t      }\n\t      parent = parent.$parent\n\t    }\n\n\t    data.routerViewDepth = depth\n\t    var matched = route.matched[depth]\n\t    if (!matched) {\n\t      return h()\n\t    }\n\n\t    var component = inactive\n\t      ? cache[props.name]\n\t      : (cache[props.name] = matched.components[props.name])\n\n\t    var vnode = h(component, data, children)\n\t    if (!inactive) {\n\t      matched.instances[props.name] = vnode\n\t    }\n\n\t    return vnode\n\t  }\n\t}\n\n\t/*       */\n\n\tfunction resolvePath (\n\t  relative        ,\n\t  base        ,\n\t  append          \n\t)         {\n\t  if (relative.charAt(0) === '/') {\n\t    return relative\n\t  }\n\n\t  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {\n\t    return base + relative\n\t  }\n\n\t  var stack = base.split('/')\n\n\t  // remove trailing segment if:\n\t  // - not appending\n\t  // - appending to trailing slash (last segment is empty)\n\t  if (!append || !stack[stack.length - 1]) {\n\t    stack.pop()\n\t  }\n\n\t  // resolve relative path\n\t  var segments = relative.replace(/^\\//, '').split('/')\n\t  for (var i = 0; i < segments.length; i++) {\n\t    var segment = segments[i]\n\t    if (segment === '.') {\n\t      continue\n\t    } else if (segment === '..') {\n\t      stack.pop()\n\t    } else {\n\t      stack.push(segment)\n\t    }\n\t  }\n\n\t  // ensure leading slash\n\t  if (stack[0] !== '') {\n\t    stack.unshift('')\n\t  }\n\n\t  return stack.join('/')\n\t}\n\n\tfunction parsePath (path        )   \n\t               \n\t                \n\t               \n\t  {\n\t  var hash = ''\n\t  var query = ''\n\n\t  var hashIndex = path.indexOf('#')\n\t  if (hashIndex >= 0) {\n\t    hash = path.slice(hashIndex)\n\t    path = path.slice(0, hashIndex)\n\t  }\n\n\t  var queryIndex = path.indexOf('?')\n\t  if (queryIndex >= 0) {\n\t    query = path.slice(queryIndex + 1)\n\t    path = path.slice(0, queryIndex)\n\t  }\n\n\t  return {\n\t    path: path,\n\t    query: query,\n\t    hash: hash\n\t  }\n\t}\n\n\tfunction cleanPath (path        )         {\n\t  return path.replace(/\\/\\//g, '/')\n\t}\n\n\t/*       */\n\n\tfunction isSameRoute (a       , b        )          {\n\t  if (!b) {\n\t    return false\n\t  } else if (a.path && b.path) {\n\t    return (\n\t      a.path === b.path &&\n\t      a.hash === b.hash &&\n\t      isObjectEqual(a.query, b.query)\n\t    )\n\t  } else if (a.name && b.name) {\n\t    return (\n\t      a.name === b.name &&\n\t      a.hash === b.hash &&\n\t      isObjectEqual(a.query, b.query) &&\n\t      isObjectEqual(a.params, b.params)\n\t    )\n\t  } else {\n\t    return false\n\t  }\n\t}\n\n\tfunction isObjectEqual (a, b)          {\n\t  if ( a === void 0 ) a = {};\n\t  if ( b === void 0 ) b = {};\n\n\t  var aKeys = Object.keys(a)\n\t  var bKeys = Object.keys(b)\n\t  if (aKeys.length !== bKeys.length) {\n\t    return false\n\t  }\n\t  return aKeys.every(function (key) { return String(a[key]) === String(b[key]); })\n\t}\n\n\tfunction isIncludedRoute (current       , target       )          {\n\t  return (\n\t    current.path.indexOf(target.path) === 0 &&\n\t    (!target.hash || current.hash === target.hash) &&\n\t    queryIncludes(current.query, target.query)\n\t  )\n\t}\n\n\tfunction queryIncludes (current            , target            )          {\n\t  for (var key in target) {\n\t    if (!(key in current)) {\n\t      return false\n\t    }\n\t  }\n\t  return true\n\t}\n\n\t/*       */\n\n\tfunction assert (condition     , message        ) {\n\t  if (!condition) {\n\t    throw new Error((\"[vue-router] \" + message))\n\t  }\n\t}\n\n\tfunction warn (condition     , message        ) {\n\t  if (!condition) {\n\t    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message))\n\t  }\n\t}\n\n\tvar encode = encodeURIComponent\n\tvar decode = decodeURIComponent\n\n\tfunction resolveQuery (\n\t  query         ,\n\t  extraQuery\n\t)             {\n\t  if ( extraQuery === void 0 ) extraQuery             = {};\n\n\t  if (query) {\n\t    var parsedQuery\n\t    try {\n\t      parsedQuery = parseQuery(query)\n\t    } catch (e) {\n\t      warn(false, e.message)\n\t      parsedQuery = {}\n\t    }\n\t    for (var key in extraQuery) {\n\t      parsedQuery[key] = extraQuery[key]\n\t    }\n\t    return parsedQuery\n\t  } else {\n\t    return extraQuery\n\t  }\n\t}\n\n\tfunction parseQuery (query        )             {\n\t  var res = Object.create(null)\n\n\t  query = query.trim().replace(/^(\\?|#|&)/, '')\n\n\t  if (!query) {\n\t    return res\n\t  }\n\n\t  query.split('&').forEach(function (param) {\n\t    var parts = param.replace(/\\+/g, ' ').split('=')\n\t    var key = decode(parts.shift())\n\t    var val = parts.length > 0\n\t      ? decode(parts.join('='))\n\t      : null\n\n\t    if (res[key] === undefined) {\n\t      res[key] = val\n\t    } else if (Array.isArray(res[key])) {\n\t      res[key].push(val)\n\t    } else {\n\t      res[key] = [res[key], val]\n\t    }\n\t  })\n\n\t  return res\n\t}\n\n\tfunction stringifyQuery (obj            )         {\n\t  var res = obj ? Object.keys(obj).sort().map(function (key) {\n\t    var val = obj[key]\n\n\t    if (val === undefined) {\n\t      return ''\n\t    }\n\n\t    if (val === null) {\n\t      return encode(key)\n\t    }\n\n\t    if (Array.isArray(val)) {\n\t      var result = []\n\t      val.slice().forEach(function (val2) {\n\t        if (val2 === undefined) {\n\t          return\n\t        }\n\t        if (val2 === null) {\n\t          result.push(encode(key))\n\t        } else {\n\t          result.push(encode(key) + '=' + encode(val2))\n\t        }\n\t      })\n\t      return result.join('&')\n\t    }\n\n\t    return encode(key) + '=' + encode(val)\n\t  }).filter(function (x) { return x.length > 0; }).join('&') : null\n\t  return res ? (\"?\" + res) : ''\n\t}\n\n\tfunction normalizeLocation (\n\t  raw             ,\n\t  current        ,\n\t  append          \n\t)           {\n\t  var next           = typeof raw === 'string' ? { path: raw } : raw\n\t  if (next.name || next._normalized) {\n\t    return next\n\t  }\n\n\t  var parsedPath = parsePath(next.path || '')\n\t  var basePath = (current && current.path) || '/'\n\t  var path = parsedPath.path\n\t    ? resolvePath(parsedPath.path, basePath, append)\n\t    : (current && current.path) || '/'\n\t  var query = resolveQuery(parsedPath.query, next.query)\n\t  var hash = next.hash || parsedPath.hash\n\t  if (hash && hash.charAt(0) !== '#') {\n\t    hash = \"#\" + hash\n\t  }\n\n\t  return {\n\t    _normalized: true,\n\t    path: path,\n\t    query: query,\n\t    hash: hash\n\t  }\n\t}\n\n\tvar Link = {\n\t  name: 'router-link',\n\t  props: {\n\t    to: {\n\t      type: [String, Object],\n\t      required: true\n\t    },\n\t    tag: {\n\t      type: String,\n\t      default: 'a'\n\t    },\n\t    exact: Boolean,\n\t    append: Boolean,\n\t    replace: Boolean,\n\t    activeClass: String\n\t  },\n\t  render: function render (h) {\n\t    var this$1 = this;\n\n\t    var router = this.$router\n\t    var current = this.$route\n\t    var to = normalizeLocation(this.to, current, this.append)\n\t    var resolved = router.match(to)\n\t    var fullPath = resolved.redirectedFrom || resolved.fullPath\n\t    var base = router.history.base\n\t    var href = base ? cleanPath(base + fullPath) : fullPath\n\t    var classes = {}\n\t    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active'\n\t    classes[activeClass] = this.exact\n\t      ? isSameRoute(current, to)\n\t      : isIncludedRoute(current, to)\n\n\t    var data = {\n\t      class: classes,\n\t      on: {\n\t        click: function (e) {\n\t          e.preventDefault()\n\t          if (this$1.replace) {\n\t            router.replace(to)\n\t          } else {\n\t            router.push(to)\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    if (this.tag === 'a') {\n\t      data.attrs = { href: href }\n\t    } else {\n\t      // find the first <a> child and apply href\n\t      var a = findAnchor(this.$slots.default)\n\t      if (a) {\n\t        var aData = a.data || (a.data = {})\n\t        var aAttrs = aData.attrs || (aData.attrs = {})\n\t        aAttrs.href = href\n\t      }\n\t    }\n\n\t    return h(this.tag, data, this.$slots.default)\n\t  }\n\t}\n\n\tfunction findAnchor (children) {\n\t  if (children) {\n\t    var child\n\t    for (var i = 0; i < children.length; i++) {\n\t      child = children[i]\n\t      if (child.tag === 'a') {\n\t        return child\n\t      }\n\t      if (child.children && (child = findAnchor(child.children))) {\n\t        return child\n\t      }\n\t    }\n\t  }\n\t}\n\n\tfunction install (Vue) {\n\t  if (install.installed) return\n\t  install.installed = true\n\n\t  Object.defineProperty(Vue.prototype, '$router', {\n\t    get: function get () { return this.$root._router }\n\t  })\n\n\t  Object.defineProperty(Vue.prototype, '$route', {\n\t    get: function get$1 () { return this.$root._route }\n\t  })\n\n\t  Vue.mixin({\n\t    beforeCreate: function beforeCreate () {\n\t      if (this.$options.router) {\n\t        this._router = this.$options.router\n\t        this._router.init(this)\n\t        Vue.util.defineReactive(this, '_route', this._router.history.current)\n\t      }\n\t    }\n\t  })\n\n\t  Vue.component('router-view', View)\n\t  Vue.component('router-link', Link)\n\t}\n\n\tfunction interopDefault(ex) {\n\t\treturn ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n\t}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar index$1 = createCommonjsModule(function (module) {\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return Object.prototype.toString.call(arr) == '[object Array]';\n\t};\n\t});\n\n\tvar index$2 = interopDefault(index$1);\n\n\n\tvar require$$0 = Object.freeze({\n\t  default: index$2\n\t});\n\n\tvar index = createCommonjsModule(function (module) {\n\tvar isarray = interopDefault(require$$0)\n\n\t/**\n\t * Expose `pathToRegexp`.\n\t */\n\tmodule.exports = pathToRegexp\n\tmodule.exports.parse = parse\n\tmodule.exports.compile = compile\n\tmodule.exports.tokensToFunction = tokensToFunction\n\tmodule.exports.tokensToRegExp = tokensToRegExp\n\n\t/**\n\t * The main path matching regexp utility.\n\t *\n\t * @type {RegExp}\n\t */\n\tvar PATH_REGEXP = new RegExp([\n\t  // Match escaped characters that would otherwise appear in future matches.\n\t  // This allows the user to escape special characters that won't transform.\n\t  '(\\\\\\\\.)',\n\t  // Match Express-style parameters and un-named parameters with a prefix\n\t  // and optional suffixes. Matches appear as:\n\t  //\n\t  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n\t  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n\t  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n\t  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n\t].join('|'), 'g')\n\n\t/**\n\t * Parse a string for the raw tokens.\n\t *\n\t * @param  {string} str\n\t * @return {!Array}\n\t */\n\tfunction parse (str) {\n\t  var tokens = []\n\t  var key = 0\n\t  var index = 0\n\t  var path = ''\n\t  var res\n\n\t  while ((res = PATH_REGEXP.exec(str)) != null) {\n\t    var m = res[0]\n\t    var escaped = res[1]\n\t    var offset = res.index\n\t    path += str.slice(index, offset)\n\t    index = offset + m.length\n\n\t    // Ignore already escaped sequences.\n\t    if (escaped) {\n\t      path += escaped[1]\n\t      continue\n\t    }\n\n\t    var next = str[index]\n\t    var prefix = res[2]\n\t    var name = res[3]\n\t    var capture = res[4]\n\t    var group = res[5]\n\t    var modifier = res[6]\n\t    var asterisk = res[7]\n\n\t    // Push the current path onto the tokens.\n\t    if (path) {\n\t      tokens.push(path)\n\t      path = ''\n\t    }\n\n\t    var partial = prefix != null && next != null && next !== prefix\n\t    var repeat = modifier === '+' || modifier === '*'\n\t    var optional = modifier === '?' || modifier === '*'\n\t    var delimiter = res[2] || '/'\n\t    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n\t    tokens.push({\n\t      name: name || key++,\n\t      prefix: prefix || '',\n\t      delimiter: delimiter,\n\t      optional: optional,\n\t      repeat: repeat,\n\t      partial: partial,\n\t      asterisk: !!asterisk,\n\t      pattern: escapeGroup(pattern)\n\t    })\n\t  }\n\n\t  // Match any characters still remaining.\n\t  if (index < str.length) {\n\t    path += str.substr(index)\n\t  }\n\n\t  // If the path exists, push it onto the end.\n\t  if (path) {\n\t    tokens.push(path)\n\t  }\n\n\t  return tokens\n\t}\n\n\t/**\n\t * Compile a string to a template function for the path.\n\t *\n\t * @param  {string}             str\n\t * @return {!function(Object=, Object=)}\n\t */\n\tfunction compile (str) {\n\t  return tokensToFunction(parse(str))\n\t}\n\n\t/**\n\t * Prettier encoding of URI path segments.\n\t *\n\t * @param  {string}\n\t * @return {string}\n\t */\n\tfunction encodeURIComponentPretty (str) {\n\t  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n\t    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n\t  })\n\t}\n\n\t/**\n\t * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n\t *\n\t * @param  {string}\n\t * @return {string}\n\t */\n\tfunction encodeAsterisk (str) {\n\t  return encodeURI(str).replace(/[?#]/g, function (c) {\n\t    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n\t  })\n\t}\n\n\t/**\n\t * Expose a method for transforming tokens into the path function.\n\t */\n\tfunction tokensToFunction (tokens) {\n\t  // Compile all the tokens into regexps.\n\t  var matches = new Array(tokens.length)\n\n\t  // Compile all the patterns before compilation.\n\t  for (var i = 0; i < tokens.length; i++) {\n\t    if (typeof tokens[i] === 'object') {\n\t      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n\t    }\n\t  }\n\n\t  return function (obj, opts) {\n\t    var path = ''\n\t    var data = obj || {}\n\t    var options = opts || {}\n\t    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n\t    for (var i = 0; i < tokens.length; i++) {\n\t      var token = tokens[i]\n\n\t      if (typeof token === 'string') {\n\t        path += token\n\n\t        continue\n\t      }\n\n\t      var value = data[token.name]\n\t      var segment\n\n\t      if (value == null) {\n\t        if (token.optional) {\n\t          // Prepend partial segment prefixes.\n\t          if (token.partial) {\n\t            path += token.prefix\n\t          }\n\n\t          continue\n\t        } else {\n\t          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n\t        }\n\t      }\n\n\t      if (isarray(value)) {\n\t        if (!token.repeat) {\n\t          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n\t        }\n\n\t        if (value.length === 0) {\n\t          if (token.optional) {\n\t            continue\n\t          } else {\n\t            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n\t          }\n\t        }\n\n\t        for (var j = 0; j < value.length; j++) {\n\t          segment = encode(value[j])\n\n\t          if (!matches[i].test(segment)) {\n\t            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n\t          }\n\n\t          path += (j === 0 ? token.prefix : token.delimiter) + segment\n\t        }\n\n\t        continue\n\t      }\n\n\t      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n\t      if (!matches[i].test(segment)) {\n\t        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n\t      }\n\n\t      path += token.prefix + segment\n\t    }\n\n\t    return path\n\t  }\n\t}\n\n\t/**\n\t * Escape a regular expression string.\n\t *\n\t * @param  {string} str\n\t * @return {string}\n\t */\n\tfunction escapeString (str) {\n\t  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n\t}\n\n\t/**\n\t * Escape the capturing group by escaping special characters and meaning.\n\t *\n\t * @param  {string} group\n\t * @return {string}\n\t */\n\tfunction escapeGroup (group) {\n\t  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n\t}\n\n\t/**\n\t * Attach the keys as a property of the regexp.\n\t *\n\t * @param  {!RegExp} re\n\t * @param  {Array}   keys\n\t * @return {!RegExp}\n\t */\n\tfunction attachKeys (re, keys) {\n\t  re.keys = keys\n\t  return re\n\t}\n\n\t/**\n\t * Get the flags for a regexp from the options.\n\t *\n\t * @param  {Object} options\n\t * @return {string}\n\t */\n\tfunction flags (options) {\n\t  return options.sensitive ? '' : 'i'\n\t}\n\n\t/**\n\t * Pull out keys from a regexp.\n\t *\n\t * @param  {!RegExp} path\n\t * @param  {!Array}  keys\n\t * @return {!RegExp}\n\t */\n\tfunction regexpToRegexp (path, keys) {\n\t  // Use a negative lookahead to match only capturing groups.\n\t  var groups = path.source.match(/\\((?!\\?)/g)\n\n\t  if (groups) {\n\t    for (var i = 0; i < groups.length; i++) {\n\t      keys.push({\n\t        name: i,\n\t        prefix: null,\n\t        delimiter: null,\n\t        optional: false,\n\t        repeat: false,\n\t        partial: false,\n\t        asterisk: false,\n\t        pattern: null\n\t      })\n\t    }\n\t  }\n\n\t  return attachKeys(path, keys)\n\t}\n\n\t/**\n\t * Transform an array into a regexp.\n\t *\n\t * @param  {!Array}  path\n\t * @param  {Array}   keys\n\t * @param  {!Object} options\n\t * @return {!RegExp}\n\t */\n\tfunction arrayToRegexp (path, keys, options) {\n\t  var parts = []\n\n\t  for (var i = 0; i < path.length; i++) {\n\t    parts.push(pathToRegexp(path[i], keys, options).source)\n\t  }\n\n\t  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n\t  return attachKeys(regexp, keys)\n\t}\n\n\t/**\n\t * Create a path regexp from string input.\n\t *\n\t * @param  {string}  path\n\t * @param  {!Array}  keys\n\t * @param  {!Object} options\n\t * @return {!RegExp}\n\t */\n\tfunction stringToRegexp (path, keys, options) {\n\t  var tokens = parse(path)\n\t  var re = tokensToRegExp(tokens, options)\n\n\t  // Attach keys back to the regexp.\n\t  for (var i = 0; i < tokens.length; i++) {\n\t    if (typeof tokens[i] !== 'string') {\n\t      keys.push(tokens[i])\n\t    }\n\t  }\n\n\t  return attachKeys(re, keys)\n\t}\n\n\t/**\n\t * Expose a function for taking tokens and returning a RegExp.\n\t *\n\t * @param  {!Array}  tokens\n\t * @param  {Object=} options\n\t * @return {!RegExp}\n\t */\n\tfunction tokensToRegExp (tokens, options) {\n\t  options = options || {}\n\n\t  var strict = options.strict\n\t  var end = options.end !== false\n\t  var route = ''\n\t  var lastToken = tokens[tokens.length - 1]\n\t  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n\t  // Iterate over the tokens and create our regexp string.\n\t  for (var i = 0; i < tokens.length; i++) {\n\t    var token = tokens[i]\n\n\t    if (typeof token === 'string') {\n\t      route += escapeString(token)\n\t    } else {\n\t      var prefix = escapeString(token.prefix)\n\t      var capture = '(?:' + token.pattern + ')'\n\n\t      if (token.repeat) {\n\t        capture += '(?:' + prefix + capture + ')*'\n\t      }\n\n\t      if (token.optional) {\n\t        if (!token.partial) {\n\t          capture = '(?:' + prefix + '(' + capture + '))?'\n\t        } else {\n\t          capture = prefix + '(' + capture + ')?'\n\t        }\n\t      } else {\n\t        capture = prefix + '(' + capture + ')'\n\t      }\n\n\t      route += capture\n\t    }\n\t  }\n\n\t  // In non-strict mode we allow a slash at the end of match. If the path to\n\t  // match already ends with a slash, we remove it for consistency. The slash\n\t  // is valid at the end of a path match, not in the middle. This is important\n\t  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n\t  if (!strict) {\n\t    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n\t  }\n\n\t  if (end) {\n\t    route += '$'\n\t  } else {\n\t    // In non-ending mode, we need the capturing groups to match as much as\n\t    // possible by using a positive lookahead to the end or next path segment.\n\t    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n\t  }\n\n\t  return new RegExp('^' + route, flags(options))\n\t}\n\n\t/**\n\t * Normalize the given path string, returning a regular expression.\n\t *\n\t * An empty array can be passed in for the keys, which will hold the\n\t * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n\t * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n\t *\n\t * @param  {(string|RegExp|Array)} path\n\t * @param  {(Array|Object)=}       keys\n\t * @param  {Object=}               options\n\t * @return {!RegExp}\n\t */\n\tfunction pathToRegexp (path, keys, options) {\n\t  keys = keys || []\n\n\t  if (!isarray(keys)) {\n\t    options = /** @type {!Object} */ (keys)\n\t    keys = []\n\t  } else if (!options) {\n\t    options = {}\n\t  }\n\n\t  if (path instanceof RegExp) {\n\t    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n\t  }\n\n\t  if (isarray(path)) {\n\t    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n\t  }\n\n\t  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n\t}\n\t});\n\n\tvar Regexp = interopDefault(index);\n\n\tfunction createRouteMap (routes                    )   \n\t                    \n\t                   \n\t  {\n\t  var pathMap           = Object.create(null)\n\t  var nameMap           = Object.create(null)\n\n\t  routes.forEach(function (route) {\n\t    addRouteRecord(pathMap, nameMap, route)\n\t  })\n\n\t  return {\n\t    pathMap: pathMap,\n\t    nameMap: nameMap\n\t  }\n\t}\n\n\tfunction addRouteRecord (\n\t  pathMap          ,\n\t  nameMap          ,\n\t  route             ,\n\t  parent              ,\n\t  matchAs         \n\t) {\n\t  var path = route.path;\n\t  var name = route.name;\n\t  assert(path != null, \"\\\"path\\\" is required in a route configuration.\")\n\n\t  var record              = {\n\t    path: normalizePath(path, parent),\n\t    components: route.components || { default: route.component },\n\t    instances: {},\n\t    name: name,\n\t    parent: parent,\n\t    matchAs: matchAs,\n\t    redirect: route.redirect,\n\t    beforeEnter: route.beforeEnter,\n\t    meta: route.meta || {}\n\t  }\n\n\t  if (route.children) {\n\t    route.children.forEach(function (child) {\n\t      addRouteRecord(pathMap, nameMap, child, record)\n\t    })\n\t  }\n\n\t  if (route.alias) {\n\t    if (Array.isArray(route.alias)) {\n\t      route.alias.forEach(function (alias) {\n\t        addRouteRecord(pathMap, nameMap, { path: alias }, parent, record.path)\n\t      })\n\t    } else {\n\t      addRouteRecord(pathMap, nameMap, { path: route.alias }, parent, record.path)\n\t    }\n\t  }\n\n\t  pathMap[record.path] = record\n\t  if (name) nameMap[name] = record\n\t}\n\n\tfunction normalizePath (path        , parent              )         {\n\t  path = path.replace(/\\/$/, '')\n\t  if (path[0] === '/') return path\n\t  if (parent == null) return path\n\t  return cleanPath(((parent.path) + \"/\" + path))\n\t}\n\n\tvar regexpCache   \n\t                  \n\t                                   \n\t                  \n\t   \n\t  = Object.create(null)\n\n\tvar regexpCompileCache   \n\t                         \n\t  = Object.create(null)\n\n\tfunction createMatcher (routes                    )          {\n\t  var ref = createRouteMap(routes);\n\t  var pathMap = ref.pathMap;\n\t  var nameMap = ref.nameMap;\n\n\t  function match (\n\t    raw             ,\n\t    currentRoute        ,\n\t    redirectedFrom           \n\t  )        {\n\t    var location = normalizeLocation(raw, currentRoute)\n\t    var name = location.name;\n\n\t    if (name) {\n\t      var record = nameMap[name]\n\t      if (record) {\n\t        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"))\n\t        return _createRoute(record, location, redirectedFrom)\n\t      }\n\t    } else if (location.path) {\n\t      location.params = {}\n\t      for (var path in pathMap) {\n\t        if (matchRoute(path, location.params, location.path)) {\n\t          return _createRoute(pathMap[path], location, redirectedFrom)\n\t        }\n\t      }\n\t    }\n\t    // no match\n\t    return _createRoute(null, location)\n\t  }\n\n\t  function redirect (\n\t    record             ,\n\t    location          \n\t  )        {\n\t    var query = location.query;\n\t    var hash = location.hash;\n\t    var params = location.params;\n\t    var redirect = record.redirect;\n\t    var name = redirect && typeof redirect === 'object' && redirect.name\n\t    if (name) {\n\t      // resolved named direct\n\t      var targetRecord = nameMap[name]\n\t      assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"))\n\t      return match({\n\t        _normalized: true,\n\t        name: name,\n\t        query: query,\n\t        hash: hash,\n\t        params: params\n\t      }, undefined, location)\n\t    } else if (typeof redirect === 'string') {\n\t      // 1. resolve relative redirect\n\t      var rawPath = resolveRecordPath(redirect, record)\n\t      // 2. resolve params\n\t      var path = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"))\n\t      // 3. rematch with existing query and hash\n\t      return match({\n\t        _normalized: true,\n\t        path: path,\n\t        query: query,\n\t        hash: hash\n\t      }, undefined, location)\n\t    } else {\n\t      warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))))\n\t      return _createRoute(null, location)\n\t    }\n\t  }\n\n\t  function alias (\n\t    record             ,\n\t    location          ,\n\t    matchAs        \n\t  )        {\n\t    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"))\n\t    var aliasedMatch = match({\n\t      _normalized: true,\n\t      path: aliasedPath\n\t    })\n\t    if (aliasedMatch) {\n\t      var matched = aliasedMatch.matched\n\t      var aliasedRecord = matched[matched.length - 1]\n\t      location.params = aliasedMatch.params\n\t      return _createRoute(aliasedRecord, location)\n\t    }\n\t    return _createRoute(null, location)\n\t  }\n\n\t  function _createRoute (\n\t    record              ,\n\t    location          ,\n\t    redirectedFrom           \n\t  )        {\n\t    if (record && record.redirect) {\n\t      return redirect(record, redirectedFrom || location)\n\t    }\n\t    if (record && record.matchAs) {\n\t      return alias(record, location, record.matchAs)\n\t    }\n\t    return createRoute(record, location, redirectedFrom)\n\t  }\n\n\t  return match\n\t}\n\n\tfunction createRoute (\n\t  record              ,\n\t  location          ,\n\t  redirectedFrom           \n\t)        {\n\t  var route        = {\n\t    name: location.name || (record && record.name),\n\t    meta: (record && record.meta) || {},\n\t    path: location.path || '/',\n\t    hash: location.hash || '',\n\t    query: location.query || {},\n\t    params: location.params || {},\n\t    fullPath: getFullPath(location),\n\t    matched: record ? formatMatch(record) : []\n\t  }\n\t  if (redirectedFrom) {\n\t    route.redirectedFrom = getFullPath(redirectedFrom)\n\t  }\n\t  return Object.freeze(route)\n\t}\n\n\tfunction matchRoute (\n\t  path        ,\n\t  params        ,\n\t  pathname        \n\t)          {\n\t  var keys, regexp\n\t  var hit = regexpCache[path]\n\t  if (hit) {\n\t    keys = hit.keys\n\t    regexp = hit.regexp\n\t  } else {\n\t    keys = []\n\t    regexp = Regexp(path, keys)\n\t    regexpCache[path] = { keys: keys, regexp: regexp }\n\t  }\n\t  var m = pathname.match(regexp)\n\n\t  if (!m) {\n\t    return false\n\t  } else if (!params) {\n\t    return true\n\t  }\n\n\t  for (var i = 1, len = m.length; i < len; ++i) {\n\t    var key = keys[i - 1]\n\t    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i]\n\t    if (key) params[key.name] = val\n\t  }\n\n\t  return true\n\t}\n\n\tfunction fillParams (\n\t  path        ,\n\t  params         ,\n\t  routeMsg        \n\t)         {\n\t  try {\n\t    var filler =\n\t      regexpCompileCache[path] ||\n\t      (regexpCompileCache[path] = Regexp.compile(path))\n\t    return filler(params || {}, { pretty: true })\n\t  } catch (e) {\n\t    assert(false, (\"missing param for \" + routeMsg + \": \" + (e.message)))\n\t    return ''\n\t  }\n\t}\n\n\tfunction formatMatch (record              )                     {\n\t  var res = []\n\t  while (record) {\n\t    res.unshift(record)\n\t    record = record.parent\n\t  }\n\t  return res\n\t}\n\n\tfunction resolveRecordPath (path        , record             )         {\n\t  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n\t}\n\n\tfunction getFullPath (ref) {\n\t  var path = ref.path;\n\t  var query = ref.query; if ( query === void 0 ) query = {};\n\t  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\n\t  return (path || '/') + stringifyQuery(query) + hash\n\t}\n\n\t/*       */\n\n\tvar inBrowser = typeof window !== 'undefined'\n\n\tvar supportsHistory = inBrowser && (function () {\n\t  var ua = window.navigator.userAgent\n\n\t  if (\n\t    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n\t    ua.indexOf('Mobile Safari') !== -1 &&\n\t    ua.indexOf('Chrome') === -1 &&\n\t    ua.indexOf('Windows Phone') === -1\n\t  ) {\n\t    return false\n\t  }\n\n\t  return window.history && 'pushState' in window.history\n\t})()\n\n\t/*       */\n\n\tfunction runQueue (queue            , fn          , cb          ) {\n\t  var step = function (index) {\n\t    if (index >= queue.length) {\n\t      cb()\n\t    } else {\n\t      fn(queue[index], function () {\n\t        step(index + 1)\n\t      })\n\t    }\n\t  }\n\t  step(0)\n\t}\n\n\tvar History = function History (router         , base       ) {\n\t  this.router = router\n\t  this.base = normalizeBase(base)\n\t  // start with a route object that stands for \"nowhere\"\n\t  this.current = createRoute(null, {\n\t    path: '__vue_router_init__'\n\t  })\n\t  this.pending = null\n\t};\n\n\tHistory.prototype.listen = function listen (cb        ) {\n\t  this.cb = cb\n\t};\n\n\tHistory.prototype.transitionTo = function transitionTo (location           , cb         ) {\n\t    var this$1 = this;\n\n\t  var route = this.router.match(location, this.current)\n\t  this.confirmTransition(route, function () {\n\t    this$1.updateRoute(route)\n\t    cb && cb(route)\n\t  })\n\t};\n\n\tHistory.prototype.confirmTransition = function confirmTransition (route     , cb        ) {\n\t    var this$1 = this;\n\n\t  if (isSameRoute(route, this.current)) {\n\t    return\n\t  }\n\n\t  var ref = resolveQueue(this.current.matched, route.matched);\n\t    var deactivated = ref.deactivated;\n\t    var activated = ref.activated;\n\n\t  var queue = [].concat(\n\t    // deactivate guards\n\t    extractLeaveGuards(deactivated),\n\t    // global before hooks\n\t    this.router.beforeHooks,\n\t    // activate guards\n\t    activated.map(function (m) { return m.beforeEnter; }),\n\t    // async components\n\t    resolveAsyncComponents(activated)\n\t  ).filter(function (_) { return _; })\n\n\t  this.pending = route\n\t  var redirect = function (location) { return this$1.push(location); }\n\n\t  runQueue(\n\t    queue,\n\t    function (hook, next) { hook(route, redirect, next) },\n\t    function () {\n\t      if (isSameRoute(route, this$1.pending)) {\n\t        this$1.pending = null\n\t        cb(route)\n\t      }\n\t    }\n\t  )\n\t};\n\n\tHistory.prototype.updateRoute = function updateRoute (route     ) {\n\t  this.current = route\n\t  this.cb && this.cb(route)\n\t  this.router.afterHooks.forEach(function (hook) {\n\t    hook && hook(route)\n\t  })\n\t};\n\n\tfunction normalizeBase (base         )         {\n\t  if (!base) {\n\t    if (inBrowser) {\n\t      // respect <base> tag\n\t      var baseEl = document.querySelector('base')\n\t      base = baseEl ? baseEl.getAttribute('href') : '/'\n\t    } else {\n\t      base = '/'\n\t    }\n\t  }\n\t  // make sure there's the starting slash\n\t  if (base.charAt(0) !== '/') {\n\t    base = '/' + base\n\t  }\n\t  // remove trailing slash\n\t  return base.replace(/\\/$/, '')\n\t}\n\n\tfunction resolveQueue (\n\t  current                    ,\n\t  next                    \n\t)   \n\t                                \n\t                                 \n\t  {\n\t  var i\n\t  var max = Math.max(current.length, next.length)\n\t  for (i = 0; i < max; i++) {\n\t    if (current[i] !== next[i]) {\n\t      break\n\t    }\n\t  }\n\t  return {\n\t    activated: next.slice(i),\n\t    deactivated: current.slice(i)\n\t  }\n\t}\n\n\tfunction extractLeaveGuards (matched                    )                   {\n\t  return flatMapComponents(matched, function (def, instance) {\n\t    var guard = def && def.beforeRouteLeave\n\t    if (guard) {\n\t      return function routeGuard () {\n\t        return guard.apply(instance, arguments)\n\t      }\n\t    }\n\t  }).reverse()\n\t}\n\n\tfunction resolveAsyncComponents (matched                    )                   {\n\t  return flatMapComponents(matched, function (def, _, match, key) {\n\t    // if it's a function and doesn't have Vue options attached,\n\t    // assume it's an async component resolve function.\n\t    // we are not using Vue's default async resolving mechanism because\n\t    // we want to halt the navigation until the incoming component has been\n\t    // resolved.\n\t    if (typeof def === 'function' && !def.options) {\n\t      return function (route, redirect, next) { return def(function (resolvedDef) {\n\t        match.components[key] = resolvedDef\n\t        next()\n\t      }); }\n\t    }\n\t  })\n\t}\n\n\tfunction flatMapComponents (\n\t  matched                    ,\n\t  fn          \n\t)                   {\n\t  return Array.prototype.concat.apply([], matched.map(function (m) {\n\t    return Object.keys(m.components).map(function (key) { return fn(\n\t      m.components[key],\n\t      m.instances[key] && m.instances[key].child,\n\t      m, key\n\t    ); })\n\t  }))\n\t}\n\n\t/*       */\n\n\tfunction saveScrollPosition (key        ) {\n\t  if (!key) return\n\t  window.sessionStorage.setItem(key, JSON.stringify({\n\t    x: window.pageXOffset,\n\t    y: window.pageYOffset\n\t  }))\n\t}\n\n\tfunction getScrollPosition (key        )          {\n\t  if (!key) return\n\t  return JSON.parse(window.sessionStorage.getItem(key))\n\t}\n\n\tfunction getElementPosition (el         )         {\n\t  var docRect = document.documentElement.getBoundingClientRect()\n\t  var elRect = el.getBoundingClientRect()\n\t  return {\n\t    x: elRect.left - docRect.left,\n\t    y: elRect.top - docRect.top\n\t  }\n\t}\n\n\tfunction isValidPosition (obj        )          {\n\t  return isNumber(obj.x) || isNumber(obj.y)\n\t}\n\n\tfunction normalizePosition (obj        )         {\n\t  return {\n\t    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n\t    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n\t  }\n\t}\n\n\tfunction isNumber (v     )          {\n\t  return typeof v === 'number'\n\t}\n\n\tvar genKey = function () { return String(Date.now()); }\n\tvar _key         = genKey()\n\n\tvar HTML5History = (function (History) {\n\t  function HTML5History (router           , base         ) {\n\t    var this$1 = this;\n\n\t    History.call(this, router, base)\n\n\t    var initialLocation = getLocation(this.base)\n\t    this.transitionTo(initialLocation, function (route) {\n\t      // possible redirect on start\n\t      var url = cleanPath(this$1.base + this$1.current.fullPath)\n\t      if (initialLocation !== url) {\n\t        replaceState(url)\n\t      }\n\t    })\n\n\t    var expectScroll = router.options.scrollBehavior\n\t    window.addEventListener('popstate', function (e) {\n\t      _key = e.state && e.state.key\n\t      var current = this$1.current\n\t      this$1.transitionTo(getLocation(this$1.base), function (next) {\n\t        if (expectScroll) {\n\t          this$1.handleScroll(next, current, true)\n\t        }\n\t      })\n\t    })\n\n\t    if (expectScroll) {\n\t      window.addEventListener('scroll', function () {\n\t        saveScrollPosition(_key)\n\t      })\n\t    }\n\t  }\n\n\t  if ( History ) HTML5History.__proto__ = History;\n\t  HTML5History.prototype = Object.create( History && History.prototype );\n\t  HTML5History.prototype.constructor = HTML5History;\n\n\t  HTML5History.prototype.go = function go (n        ) {\n\t    window.history.go(n)\n\t  };\n\n\t  HTML5History.prototype.push = function push (location             ) {\n\t    var this$1 = this;\n\n\t    var current = this.current\n\t    History.prototype.transitionTo.call(this, location, function (route) {\n\t      pushState(cleanPath(this$1.base + route.fullPath))\n\t      this$1.handleScroll(route, current, false)\n\t    })\n\t  };\n\n\t  HTML5History.prototype.replace = function replace (location             ) {\n\t    var this$1 = this;\n\n\t    var current = this.current\n\t    History.prototype.transitionTo.call(this, location, function (route) {\n\t      replaceState(cleanPath(this$1.base + route.fullPath))\n\t      this$1.handleScroll(route, current, false)\n\t    })\n\t  };\n\n\t  HTML5History.prototype.handleScroll = function handleScroll (to       , from       , isPop         ) {\n\t    var router = this.router\n\t    if (!router.app) {\n\t      return\n\t    }\n\n\t    var behavior = router.options.scrollBehavior\n\t    if (!behavior) {\n\t      return\n\t    }\n\t    assert(typeof behavior === 'function', \"scrollBehavior must be a function\")\n\n\t    // wait until re-render finishes before scrolling\n\t    router.app.$nextTick(function () {\n\t      var position = getScrollPosition(_key)\n\t      var shouldScroll = behavior(to, from, isPop ? position : null)\n\t      if (!shouldScroll) {\n\t        return\n\t      }\n\t      var isObject = typeof shouldScroll === 'object'\n\t      if (isObject && shouldScroll.selector) {\n\t        var el = document.querySelector(shouldScroll.selector)\n\t        if (el) {\n\t          position = getElementPosition(el)\n\t        } else if (isValidPosition(shouldScroll)) {\n\t          position = normalizePosition(shouldScroll)\n\t        }\n\t      } else if (isObject && isValidPosition(shouldScroll)) {\n\t        position = normalizePosition(shouldScroll)\n\t      }\n\n\t      if (position) {\n\t        window.scrollTo(position.x, position.y)\n\t      }\n\t    })\n\t  };\n\n\t  return HTML5History;\n\t}(History));\n\n\tfunction getLocation (base        )         {\n\t  var path = window.location.pathname\n\t  if (base && path.indexOf(base) === 0) {\n\t    path = path.slice(base.length)\n\t  }\n\t  return (path || '/') + window.location.search + window.location.hash\n\t}\n\n\tfunction pushState (url        , replace          ) {\n\t  // try...catch the pushState call to get around Safari\n\t  // DOM Exception 18 where it limits to 100 pushState calls\n\t  var history = window.history\n\t  try {\n\t    if (replace) {\n\t      history.replaceState({ key: _key }, '', url)\n\t    } else {\n\t      _key = genKey()\n\t      history.pushState({ key: _key }, '', url)\n\t    }\n\t    saveScrollPosition(_key)\n\t  } catch (e) {\n\t    window.location[replace ? 'assign' : 'replace'](url)\n\t  }\n\t}\n\n\tfunction replaceState (url        ) {\n\t  pushState(url, true)\n\t}\n\n\tvar HashHistory = (function (History) {\n\t  function HashHistory (router           , base         , fallback         ) {\n\t    var this$1 = this;\n\n\t    History.call(this, router, base)\n\n\t    // check history fallback deeplinking\n\t    if (fallback && this.checkFallback()) {\n\t      return\n\t    }\n\n\t    ensureSlash()\n\t    this.transitionTo(getHash(), function (route) {\n\t      // possible redirect on start\n\t      if (getHash() !== route.fullPath) {\n\t        replaceHash(route.fullPath)\n\t      }\n\t    })\n\n\t    window.addEventListener('hashchange', function () {\n\t      this$1.onHashChange()\n\t    })\n\t  }\n\n\t  if ( History ) HashHistory.__proto__ = History;\n\t  HashHistory.prototype = Object.create( History && History.prototype );\n\t  HashHistory.prototype.constructor = HashHistory;\n\n\t  HashHistory.prototype.checkFallback = function checkFallback () {\n\t    var location = getLocation(this.base)\n\t    if (!/^\\/#/.test(location)) {\n\t      window.location.replace(\n\t        cleanPath(this.base + '/#' + location)\n\t      )\n\t      return true\n\t    }\n\t  };\n\n\t  HashHistory.prototype.onHashChange = function onHashChange () {\n\t    if (!ensureSlash()) {\n\t      return\n\t    }\n\t    this.transitionTo(getHash(), function (route) {\n\t      replaceHash(route.fullPath)\n\t    })\n\t  };\n\n\t  HashHistory.prototype.push = function push (location             ) {\n\t    History.prototype.transitionTo.call(this, location, function (route) {\n\t      pushHash(route.fullPath)\n\t    })\n\t  };\n\n\t  HashHistory.prototype.replace = function replace (location             ) {\n\t    History.prototype.transitionTo.call(this, location, function (route) {\n\t      replaceHash(route.fullPath)\n\t    })\n\t  };\n\n\t  HashHistory.prototype.go = function go (n        ) {\n\t    window.history.go(n)\n\t  };\n\n\t  return HashHistory;\n\t}(History));\n\n\tfunction ensureSlash ()          {\n\t  var path = getHash()\n\t  if (path.charAt(0) === '/') {\n\t    return true\n\t  }\n\t  replaceHash('/' + path)\n\t  return false\n\t}\n\n\tfunction getHash ()         {\n\t  // We can't use window.location.hash here because it's not\n\t  // consistent across browsers - Firefox will pre-decode it!\n\t  var href = window.location.href\n\t  var index = href.indexOf('#')\n\t  return index === -1 ? '' : href.slice(index + 1)\n\t}\n\n\tfunction pushHash (path) {\n\t  window.location.hash = path\n\t}\n\n\tfunction replaceHash (path) {\n\t  var i = window.location.href.indexOf('#')\n\t  window.location.replace(\n\t    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n\t  )\n\t}\n\n\tvar AbstractHistory = (function (History) {\n\t  function AbstractHistory (router           ) {\n\t    History.call(this, router)\n\t    this.stack = []\n\t    this.index = 0\n\t  }\n\n\t  if ( History ) AbstractHistory.__proto__ = History;\n\t  AbstractHistory.prototype = Object.create( History && History.prototype );\n\t  AbstractHistory.prototype.constructor = AbstractHistory;\n\n\t  AbstractHistory.prototype.push = function push (location             ) {\n\t    var this$1 = this;\n\n\t    History.prototype.transitionTo.call(this, location, function (route) {\n\t      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route)\n\t      this$1.index++\n\t    })\n\t  };\n\n\t  AbstractHistory.prototype.replace = function replace (location             ) {\n\t    var this$1 = this;\n\n\t    History.prototype.transitionTo.call(this, location, function (route) {\n\t      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route)\n\t    })\n\t  };\n\n\t  AbstractHistory.prototype.go = function go (n        ) {\n\t    var this$1 = this;\n\n\t    var targetIndex = this.index + n\n\t    if (!this.stack) debugger\n\t    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n\t      return\n\t    }\n\t    var location = this.stack[targetIndex]\n\t    this.confirmTransition(location, function () {\n\t      this$1.index = targetIndex\n\t      this$1.updateRoute(location)\n\t    })\n\t  };\n\n\t  return AbstractHistory;\n\t}(History));\n\n\tvar VueRouter = function VueRouter (options) {\n\t  if ( options === void 0 ) options              = {};\n\n\t  this.app = null\n\t  this.options = options\n\t  this.beforeHooks = []\n\t  this.afterHooks = []\n\t  this.match = createMatcher(options.routes || [])\n\n\t  var mode = options.mode || 'hash'\n\t  this.fallback = mode === 'history' && !supportsHistory\n\t  if (this.fallback) {\n\t    mode = 'hash'\n\t  }\n\t  if (!inBrowser) {\n\t    mode = 'abstract'\n\t  }\n\t  this.mode = mode\n\t};\n\n\tvar prototypeAccessors = { currentRoute: {} };\n\n\tprototypeAccessors.currentRoute.get = function ()       {\n\t  return this.history && this.history.current\n\t};\n\n\tVueRouter.prototype.init = function init (app    /* Vue component instance */) {\n\t    var this$1 = this;\n\n\t  assert(\n\t    install.installed,\n\t    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n\t    \"before creating root instance.\"\n\t  )\n\n\t  var ref = this;\n\t    var mode = ref.mode;\n\t    var options = ref.options;\n\t    var fallback = ref.fallback;\n\t  switch (mode) {\n\t    case 'history':\n\t      this.history = new HTML5History(this, options.base)\n\t      break\n\t    case 'hash':\n\t      this.history = new HashHistory(this, options.base, fallback)\n\t      break\n\t    case 'abstract':\n\t      this.history = new AbstractHistory(this)\n\t      break\n\t    default:\n\t      assert(false, (\"invalid mode: \" + mode))\n\t  }\n\n\t  this.app = app\n\t  this.history.listen(function (route) {\n\t    this$1.app._route = route\n\t  })\n\t};\n\n\tVueRouter.prototype.beforeEach = function beforeEach (fn        ) {\n\t  this.beforeHooks.push(fn)\n\t};\n\n\tVueRouter.prototype.afterEach = function afterEach (fn        ) {\n\t  this.afterHooks.push(fn)\n\t};\n\n\tVueRouter.prototype.push = function push (location           ) {\n\t  this.history.push(location)\n\t};\n\n\tVueRouter.prototype.replace = function replace (location           ) {\n\t  this.history.replace(location)\n\t};\n\n\tVueRouter.prototype.go = function go (n      ) {\n\t  this.history.go(n)\n\t};\n\n\tVueRouter.prototype.back = function back () {\n\t  this.go(-1)\n\t};\n\n\tVueRouter.prototype.forward = function forward () {\n\t  this.go(1)\n\t};\n\n\tVueRouter.prototype.getMatchedComponents = function getMatchedComponents ()           {\n\t  if (!this.currentRoute) {\n\t    return []\n\t  }\n\t  return [].concat.apply([], this.currentRoute.matched.map(function (m) {\n\t    return Object.keys(m.components).map(function (key) {\n\t      return m.components[key]\n\t    })\n\t  }))\n\t};\n\n\tObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\n\tVueRouter.install = install\n\n\tif (inBrowser && window.Vue) {\n\t  window.Vue.use(VueRouter)\n\t}\n\n\treturn VueRouter;\n\n}));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuanM/YzcwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHZ1ZS1yb3V0ZXIgdjIuMC4wLXJjLjNcbiAqIChjKSAyMDE2IEV2YW4gWW91XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLlZ1ZVJvdXRlciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdHZhciBWaWV3ID0ge1xuXHQgIG5hbWU6ICdyb3V0ZXItdmlldycsXG5cdCAgZnVuY3Rpb25hbDogdHJ1ZSxcblx0ICBwcm9wczoge1xuXHQgICAgbmFtZToge1xuXHQgICAgICB0eXBlOiBTdHJpbmcsXG5cdCAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0J1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgsIHJlZikge1xuXHQgICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuXHQgICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuXHQgICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnQ7XG5cdCAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuXG5cdCAgICBkYXRhLnJvdXRlclZpZXcgPSB0cnVlXG5cblx0ICAgIHZhciByb3V0ZSA9IHBhcmVudC4kcm91dGVcblx0ICAgIHZhciBjYWNoZSA9IHBhcmVudC5fcm91dGVyVmlld0NhY2hlIHx8IChwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSA9IHt9KVxuXHQgICAgdmFyIGRlcHRoID0gMFxuXHQgICAgdmFyIGluYWN0aXZlID0gZmFsc2VcblxuXHQgICAgd2hpbGUgKHBhcmVudCkge1xuXHQgICAgICBpZiAocGFyZW50LiR2bm9kZSAmJiBwYXJlbnQuJHZub2RlLmRhdGEucm91dGVyVmlldykge1xuXHQgICAgICAgIGRlcHRoKytcblx0ICAgICAgfVxuXHQgICAgICBpZiAocGFyZW50Ll9pbmFjdGl2ZSkge1xuXHQgICAgICAgIGluYWN0aXZlID0gdHJ1ZVxuXHQgICAgICB9XG5cdCAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50XG5cdCAgICB9XG5cblx0ICAgIGRhdGEucm91dGVyVmlld0RlcHRoID0gZGVwdGhcblx0ICAgIHZhciBtYXRjaGVkID0gcm91dGUubWF0Y2hlZFtkZXB0aF1cblx0ICAgIGlmICghbWF0Y2hlZCkge1xuXHQgICAgICByZXR1cm4gaCgpXG5cdCAgICB9XG5cblx0ICAgIHZhciBjb21wb25lbnQgPSBpbmFjdGl2ZVxuXHQgICAgICA/IGNhY2hlW3Byb3BzLm5hbWVdXG5cdCAgICAgIDogKGNhY2hlW3Byb3BzLm5hbWVdID0gbWF0Y2hlZC5jb21wb25lbnRzW3Byb3BzLm5hbWVdKVxuXG5cdCAgICB2YXIgdm5vZGUgPSBoKGNvbXBvbmVudCwgZGF0YSwgY2hpbGRyZW4pXG5cdCAgICBpZiAoIWluYWN0aXZlKSB7XG5cdCAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW3Byb3BzLm5hbWVdID0gdm5vZGVcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZub2RlXG5cdCAgfVxuXHR9XG5cblx0LyogICAgICAgKi9cblxuXHRmdW5jdGlvbiByZXNvbHZlUGF0aCAoXG5cdCAgcmVsYXRpdmUgICAgICAgICxcblx0ICBiYXNlICAgICAgICAsXG5cdCAgYXBwZW5kICAgICAgICAgIFxuXHQpICAgICAgICAge1xuXHQgIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgPT09ICcvJykge1xuXHQgICAgcmV0dXJuIHJlbGF0aXZlXG5cdCAgfVxuXG5cdCAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSA9PT0gJz8nIHx8IHJlbGF0aXZlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG5cdCAgICByZXR1cm4gYmFzZSArIHJlbGF0aXZlXG5cdCAgfVxuXG5cdCAgdmFyIHN0YWNrID0gYmFzZS5zcGxpdCgnLycpXG5cblx0ICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcblx0ICAvLyAtIG5vdCBhcHBlbmRpbmdcblx0ICAvLyAtIGFwcGVuZGluZyB0byB0cmFpbGluZyBzbGFzaCAobGFzdCBzZWdtZW50IGlzIGVtcHR5KVxuXHQgIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuXHQgICAgc3RhY2sucG9wKClcblx0ICB9XG5cblx0ICAvLyByZXNvbHZlIHJlbGF0aXZlIHBhdGhcblx0ICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJylcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldXG5cdCAgICBpZiAoc2VnbWVudCA9PT0gJy4nKSB7XG5cdCAgICAgIGNvbnRpbnVlXG5cdCAgICB9IGVsc2UgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcblx0ICAgICAgc3RhY2sucG9wKClcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHN0YWNrLnB1c2goc2VnbWVudClcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBlbnN1cmUgbGVhZGluZyBzbGFzaFxuXHQgIGlmIChzdGFja1swXSAhPT0gJycpIHtcblx0ICAgIHN0YWNrLnVuc2hpZnQoJycpXG5cdCAgfVxuXG5cdCAgcmV0dXJuIHN0YWNrLmpvaW4oJy8nKVxuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoICAgICAgICApICAgXG5cdCAgICAgICAgICAgICAgIFxuXHQgICAgICAgICAgICAgICAgXG5cdCAgICAgICAgICAgICAgIFxuXHQgIHtcblx0ICB2YXIgaGFzaCA9ICcnXG5cdCAgdmFyIHF1ZXJ5ID0gJydcblxuXHQgIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKVxuXHQgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuXHQgICAgaGFzaCA9IHBhdGguc2xpY2UoaGFzaEluZGV4KVxuXHQgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgaGFzaEluZGV4KVxuXHQgIH1cblxuXHQgIHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jylcblx0ICBpZiAocXVlcnlJbmRleCA+PSAwKSB7XG5cdCAgICBxdWVyeSA9IHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEpXG5cdCAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBxdWVyeUluZGV4KVxuXHQgIH1cblxuXHQgIHJldHVybiB7XG5cdCAgICBwYXRoOiBwYXRoLFxuXHQgICAgcXVlcnk6IHF1ZXJ5LFxuXHQgICAgaGFzaDogaGFzaFxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNsZWFuUGF0aCAocGF0aCAgICAgICAgKSAgICAgICAgIHtcblx0ICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC9cXC8vZywgJy8nKVxuXHR9XG5cblx0LyogICAgICAgKi9cblxuXHRmdW5jdGlvbiBpc1NhbWVSb3V0ZSAoYSAgICAgICAsIGIgICAgICAgICkgICAgICAgICAge1xuXHQgIGlmICghYikge1xuXHQgICAgcmV0dXJuIGZhbHNlXG5cdCAgfSBlbHNlIGlmIChhLnBhdGggJiYgYi5wYXRoKSB7XG5cdCAgICByZXR1cm4gKFxuXHQgICAgICBhLnBhdGggPT09IGIucGF0aCAmJlxuXHQgICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxuXHQgICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpXG5cdCAgICApXG5cdCAgfSBlbHNlIGlmIChhLm5hbWUgJiYgYi5uYW1lKSB7XG5cdCAgICByZXR1cm4gKFxuXHQgICAgICBhLm5hbWUgPT09IGIubmFtZSAmJlxuXHQgICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxuXHQgICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpICYmXG5cdCAgICAgIGlzT2JqZWN0RXF1YWwoYS5wYXJhbXMsIGIucGFyYW1zKVxuXHQgICAgKVxuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gZmFsc2Vcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBpc09iamVjdEVxdWFsIChhLCBiKSAgICAgICAgICB7XG5cdCAgaWYgKCBhID09PSB2b2lkIDAgKSBhID0ge307XG5cdCAgaWYgKCBiID09PSB2b2lkIDAgKSBiID0ge307XG5cblx0ICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKVxuXHQgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpXG5cdCAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gZmFsc2Vcblx0ICB9XG5cdCAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFN0cmluZyhhW2tleV0pID09PSBTdHJpbmcoYltrZXldKTsgfSlcblx0fVxuXG5cdGZ1bmN0aW9uIGlzSW5jbHVkZWRSb3V0ZSAoY3VycmVudCAgICAgICAsIHRhcmdldCAgICAgICApICAgICAgICAgIHtcblx0ICByZXR1cm4gKFxuXHQgICAgY3VycmVudC5wYXRoLmluZGV4T2YodGFyZ2V0LnBhdGgpID09PSAwICYmXG5cdCAgICAoIXRhcmdldC5oYXNoIHx8IGN1cnJlbnQuaGFzaCA9PT0gdGFyZ2V0Lmhhc2gpICYmXG5cdCAgICBxdWVyeUluY2x1ZGVzKGN1cnJlbnQucXVlcnksIHRhcmdldC5xdWVyeSlcblx0ICApXG5cdH1cblxuXHRmdW5jdGlvbiBxdWVyeUluY2x1ZGVzIChjdXJyZW50ICAgICAgICAgICAgLCB0YXJnZXQgICAgICAgICAgICApICAgICAgICAgIHtcblx0ICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG5cdCAgICBpZiAoIShrZXkgaW4gY3VycmVudCkpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlXG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiB0cnVlXG5cdH1cblxuXHQvKiAgICAgICAqL1xuXG5cdGZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uICAgICAsIG1lc3NhZ2UgICAgICAgICkge1xuXHQgIGlmICghY29uZGl0aW9uKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpXG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gd2FybiAoY29uZGl0aW9uICAgICAsIG1lc3NhZ2UgICAgICAgICkge1xuXHQgIGlmICghY29uZGl0aW9uKSB7XG5cdCAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKVxuXHQgIH1cblx0fVxuXG5cdHZhciBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnRcblx0dmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudFxuXG5cdGZ1bmN0aW9uIHJlc29sdmVRdWVyeSAoXG5cdCAgcXVlcnkgICAgICAgICAsXG5cdCAgZXh0cmFRdWVyeVxuXHQpICAgICAgICAgICAgIHtcblx0ICBpZiAoIGV4dHJhUXVlcnkgPT09IHZvaWQgMCApIGV4dHJhUXVlcnkgICAgICAgICAgICAgPSB7fTtcblxuXHQgIGlmIChxdWVyeSkge1xuXHQgICAgdmFyIHBhcnNlZFF1ZXJ5XG5cdCAgICB0cnkge1xuXHQgICAgICBwYXJzZWRRdWVyeSA9IHBhcnNlUXVlcnkocXVlcnkpXG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIHdhcm4oZmFsc2UsIGUubWVzc2FnZSlcblx0ICAgICAgcGFyc2VkUXVlcnkgPSB7fVxuXHQgICAgfVxuXHQgICAgZm9yICh2YXIga2V5IGluIGV4dHJhUXVlcnkpIHtcblx0ICAgICAgcGFyc2VkUXVlcnlba2V5XSA9IGV4dHJhUXVlcnlba2V5XVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHBhcnNlZFF1ZXJ5XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBleHRyYVF1ZXJ5XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VRdWVyeSAocXVlcnkgICAgICAgICkgICAgICAgICAgICAge1xuXHQgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cblx0ICBxdWVyeSA9IHF1ZXJ5LnRyaW0oKS5yZXBsYWNlKC9eKFxcP3wjfCYpLywgJycpXG5cblx0ICBpZiAoIXF1ZXJ5KSB7XG5cdCAgICByZXR1cm4gcmVzXG5cdCAgfVxuXG5cdCAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuXHQgICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKVxuXHQgICAgdmFyIGtleSA9IGRlY29kZShwYXJ0cy5zaGlmdCgpKVxuXHQgICAgdmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDBcblx0ICAgICAgPyBkZWNvZGUocGFydHMuam9pbignPScpKVxuXHQgICAgICA6IG51bGxcblxuXHQgICAgaWYgKHJlc1trZXldID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgcmVzW2tleV0gPSB2YWxcblx0ICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXNba2V5XSkpIHtcblx0ICAgICAgcmVzW2tleV0ucHVzaCh2YWwpXG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXNba2V5XSA9IFtyZXNba2V5XSwgdmFsXVxuXHQgICAgfVxuXHQgIH0pXG5cblx0ICByZXR1cm4gcmVzXG5cdH1cblxuXHRmdW5jdGlvbiBzdHJpbmdpZnlRdWVyeSAob2JqICAgICAgICAgICAgKSAgICAgICAgIHtcblx0ICB2YXIgcmVzID0gb2JqID8gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgIHZhciB2YWwgPSBvYmpba2V5XVxuXG5cdCAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgcmV0dXJuICcnXG5cdCAgICB9XG5cblx0ICAgIGlmICh2YWwgPT09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIGVuY29kZShrZXkpXG5cdCAgICB9XG5cblx0ICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IFtdXG5cdCAgICAgIHZhbC5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKHZhbDIpIHtcblx0ICAgICAgICBpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICByZXR1cm5cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbDIgPT09IG51bGwpIHtcblx0ICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpKVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwyKSlcblx0ICAgICAgICB9XG5cdCAgICAgIH0pXG5cdCAgICAgIHJldHVybiByZXN1bHQuam9pbignJicpXG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwpXG5cdCAgfSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH0pLmpvaW4oJyYnKSA6IG51bGxcblx0ICByZXR1cm4gcmVzID8gKFwiP1wiICsgcmVzKSA6ICcnXG5cdH1cblxuXHRmdW5jdGlvbiBub3JtYWxpemVMb2NhdGlvbiAoXG5cdCAgcmF3ICAgICAgICAgICAgICxcblx0ICBjdXJyZW50ICAgICAgICAsXG5cdCAgYXBwZW5kICAgICAgICAgIFxuXHQpICAgICAgICAgICB7XG5cdCAgdmFyIG5leHQgICAgICAgICAgID0gdHlwZW9mIHJhdyA9PT0gJ3N0cmluZycgPyB7IHBhdGg6IHJhdyB9IDogcmF3XG5cdCAgaWYgKG5leHQubmFtZSB8fCBuZXh0Ll9ub3JtYWxpemVkKSB7XG5cdCAgICByZXR1cm4gbmV4dFxuXHQgIH1cblxuXHQgIHZhciBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKG5leHQucGF0aCB8fCAnJylcblx0ICB2YXIgYmFzZVBhdGggPSAoY3VycmVudCAmJiBjdXJyZW50LnBhdGgpIHx8ICcvJ1xuXHQgIHZhciBwYXRoID0gcGFyc2VkUGF0aC5wYXRoXG5cdCAgICA/IHJlc29sdmVQYXRoKHBhcnNlZFBhdGgucGF0aCwgYmFzZVBhdGgsIGFwcGVuZClcblx0ICAgIDogKGN1cnJlbnQgJiYgY3VycmVudC5wYXRoKSB8fCAnLydcblx0ICB2YXIgcXVlcnkgPSByZXNvbHZlUXVlcnkocGFyc2VkUGF0aC5xdWVyeSwgbmV4dC5xdWVyeSlcblx0ICB2YXIgaGFzaCA9IG5leHQuaGFzaCB8fCBwYXJzZWRQYXRoLmhhc2hcblx0ICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG5cdCAgICBoYXNoID0gXCIjXCIgKyBoYXNoXG5cdCAgfVxuXG5cdCAgcmV0dXJuIHtcblx0ICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuXHQgICAgcGF0aDogcGF0aCxcblx0ICAgIHF1ZXJ5OiBxdWVyeSxcblx0ICAgIGhhc2g6IGhhc2hcblx0ICB9XG5cdH1cblxuXHR2YXIgTGluayA9IHtcblx0ICBuYW1lOiAncm91dGVyLWxpbmsnLFxuXHQgIHByb3BzOiB7XG5cdCAgICB0bzoge1xuXHQgICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3RdLFxuXHQgICAgICByZXF1aXJlZDogdHJ1ZVxuXHQgICAgfSxcblx0ICAgIHRhZzoge1xuXHQgICAgICB0eXBlOiBTdHJpbmcsXG5cdCAgICAgIGRlZmF1bHQ6ICdhJ1xuXHQgICAgfSxcblx0ICAgIGV4YWN0OiBCb29sZWFuLFxuXHQgICAgYXBwZW5kOiBCb29sZWFuLFxuXHQgICAgcmVwbGFjZTogQm9vbGVhbixcblx0ICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmdcblx0ICB9LFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgdmFyIHJvdXRlciA9IHRoaXMuJHJvdXRlclxuXHQgICAgdmFyIGN1cnJlbnQgPSB0aGlzLiRyb3V0ZVxuXHQgICAgdmFyIHRvID0gbm9ybWFsaXplTG9jYXRpb24odGhpcy50bywgY3VycmVudCwgdGhpcy5hcHBlbmQpXG5cdCAgICB2YXIgcmVzb2x2ZWQgPSByb3V0ZXIubWF0Y2godG8pXG5cdCAgICB2YXIgZnVsbFBhdGggPSByZXNvbHZlZC5yZWRpcmVjdGVkRnJvbSB8fCByZXNvbHZlZC5mdWxsUGF0aFxuXHQgICAgdmFyIGJhc2UgPSByb3V0ZXIuaGlzdG9yeS5iYXNlXG5cdCAgICB2YXIgaHJlZiA9IGJhc2UgPyBjbGVhblBhdGgoYmFzZSArIGZ1bGxQYXRoKSA6IGZ1bGxQYXRoXG5cdCAgICB2YXIgY2xhc3NlcyA9IHt9XG5cdCAgICB2YXIgYWN0aXZlQ2xhc3MgPSB0aGlzLmFjdGl2ZUNsYXNzIHx8IHJvdXRlci5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcyB8fCAncm91dGVyLWxpbmstYWN0aXZlJ1xuXHQgICAgY2xhc3Nlc1thY3RpdmVDbGFzc10gPSB0aGlzLmV4YWN0XG5cdCAgICAgID8gaXNTYW1lUm91dGUoY3VycmVudCwgdG8pXG5cdCAgICAgIDogaXNJbmNsdWRlZFJvdXRlKGN1cnJlbnQsIHRvKVxuXG5cdCAgICB2YXIgZGF0YSA9IHtcblx0ICAgICAgY2xhc3M6IGNsYXNzZXMsXG5cdCAgICAgIG9uOiB7XG5cdCAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcblx0ICAgICAgICAgIGlmICh0aGlzJDEucmVwbGFjZSkge1xuXHQgICAgICAgICAgICByb3V0ZXIucmVwbGFjZSh0bylcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJvdXRlci5wdXNoKHRvKVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy50YWcgPT09ICdhJykge1xuXHQgICAgICBkYXRhLmF0dHJzID0geyBocmVmOiBocmVmIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IDxhPiBjaGlsZCBhbmQgYXBwbHkgaHJlZlxuXHQgICAgICB2YXIgYSA9IGZpbmRBbmNob3IodGhpcy4kc2xvdHMuZGVmYXVsdClcblx0ICAgICAgaWYgKGEpIHtcblx0ICAgICAgICB2YXIgYURhdGEgPSBhLmRhdGEgfHwgKGEuZGF0YSA9IHt9KVxuXHQgICAgICAgIHZhciBhQXR0cnMgPSBhRGF0YS5hdHRycyB8fCAoYURhdGEuYXR0cnMgPSB7fSlcblx0ICAgICAgICBhQXR0cnMuaHJlZiA9IGhyZWZcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gaCh0aGlzLnRhZywgZGF0YSwgdGhpcy4kc2xvdHMuZGVmYXVsdClcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBmaW5kQW5jaG9yIChjaGlsZHJlbikge1xuXHQgIGlmIChjaGlsZHJlbikge1xuXHQgICAgdmFyIGNoaWxkXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGNoaWxkID0gY2hpbGRyZW5baV1cblx0ICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ2EnKSB7XG5cdCAgICAgICAgcmV0dXJuIGNoaWxkXG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuICYmIChjaGlsZCA9IGZpbmRBbmNob3IoY2hpbGQuY2hpbGRyZW4pKSkge1xuXHQgICAgICAgIHJldHVybiBjaGlsZFxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5zdGFsbCAoVnVlKSB7XG5cdCAgaWYgKGluc3RhbGwuaW5zdGFsbGVkKSByZXR1cm5cblx0ICBpbnN0YWxsLmluc3RhbGxlZCA9IHRydWVcblxuXHQgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlcicsIHtcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuJHJvb3QuX3JvdXRlciB9XG5cdCAgfSlcblxuXHQgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlJywge1xuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQkMSAoKSB7IHJldHVybiB0aGlzLiRyb290Ll9yb3V0ZSB9XG5cdCAgfSlcblxuXHQgIFZ1ZS5taXhpbih7XG5cdCAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSAoKSB7XG5cdCAgICAgIGlmICh0aGlzLiRvcHRpb25zLnJvdXRlcikge1xuXHQgICAgICAgIHRoaXMuX3JvdXRlciA9IHRoaXMuJG9wdGlvbnMucm91dGVyXG5cdCAgICAgICAgdGhpcy5fcm91dGVyLmluaXQodGhpcylcblx0ICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLCAnX3JvdXRlJywgdGhpcy5fcm91dGVyLmhpc3RvcnkuY3VycmVudClcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pXG5cblx0ICBWdWUuY29tcG9uZW50KCdyb3V0ZXItdmlldycsIFZpZXcpXG5cdCAgVnVlLmNvbXBvbmVudCgncm91dGVyLWxpbmsnLCBMaW5rKVxuXHR9XG5cblx0ZnVuY3Rpb24gaW50ZXJvcERlZmF1bHQoZXgpIHtcblx0XHRyZXR1cm4gZXggJiYgdHlwZW9mIGV4ID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZXggPyBleFsnZGVmYXVsdCddIDogZXg7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0dmFyIGluZGV4JDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG5cdCAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cdH0pO1xuXG5cdHZhciBpbmRleCQyID0gaW50ZXJvcERlZmF1bHQoaW5kZXgkMSk7XG5cblxuXHR2YXIgcmVxdWlyZSQkMCA9IE9iamVjdC5mcmVlemUoe1xuXHQgIGRlZmF1bHQ6IGluZGV4JDJcblx0fSk7XG5cblx0dmFyIGluZGV4ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHR2YXIgaXNhcnJheSA9IGludGVyb3BEZWZhdWx0KHJlcXVpcmUkJDApXG5cblx0LyoqXG5cdCAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cblx0ICovXG5cdG1vZHVsZS5leHBvcnRzID0gcGF0aFRvUmVnZXhwXG5cdG1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcblx0bW9kdWxlLmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGVcblx0bW9kdWxlLmV4cG9ydHMudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25cblx0bW9kdWxlLmV4cG9ydHMudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cFxuXG5cdC8qKlxuXHQgKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuXHQgKlxuXHQgKiBAdHlwZSB7UmVnRXhwfVxuXHQgKi9cblx0dmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG5cdCAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cblx0ICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuXHQgICcoXFxcXFxcXFwuKScsXG5cdCAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcblx0ICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuXHQgIC8vXG5cdCAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuXHQgIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cblx0ICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG5cdCAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXHRdLmpvaW4oJ3wnKSwgJ2cnKVxuXG5cdC8qKlxuXHQgKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm4geyFBcnJheX1cblx0ICovXG5cdGZ1bmN0aW9uIHBhcnNlIChzdHIpIHtcblx0ICB2YXIgdG9rZW5zID0gW11cblx0ICB2YXIga2V5ID0gMFxuXHQgIHZhciBpbmRleCA9IDBcblx0ICB2YXIgcGF0aCA9ICcnXG5cdCAgdmFyIHJlc1xuXG5cdCAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcblx0ICAgIHZhciBtID0gcmVzWzBdXG5cdCAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXVxuXHQgICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleFxuXHQgICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldClcblx0ICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGhcblxuXHQgICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG5cdCAgICBpZiAoZXNjYXBlZCkge1xuXHQgICAgICBwYXRoICs9IGVzY2FwZWRbMV1cblx0ICAgICAgY29udGludWVcblx0ICAgIH1cblxuXHQgICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdXG5cdCAgICB2YXIgcHJlZml4ID0gcmVzWzJdXG5cdCAgICB2YXIgbmFtZSA9IHJlc1szXVxuXHQgICAgdmFyIGNhcHR1cmUgPSByZXNbNF1cblx0ICAgIHZhciBncm91cCA9IHJlc1s1XVxuXHQgICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdXG5cdCAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN11cblxuXHQgICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cblx0ICAgIGlmIChwYXRoKSB7XG5cdCAgICAgIHRva2Vucy5wdXNoKHBhdGgpXG5cdCAgICAgIHBhdGggPSAnJ1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXhcblx0ICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKidcblx0ICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuXHQgICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCAnLydcblx0ICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cCB8fCAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGRlbGltaXRlciArICddKz8nKVxuXG5cdCAgICB0b2tlbnMucHVzaCh7XG5cdCAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG5cdCAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuXHQgICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcblx0ICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuXHQgICAgICByZXBlYXQ6IHJlcGVhdCxcblx0ICAgICAgcGFydGlhbDogcGFydGlhbCxcblx0ICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG5cdCAgICAgIHBhdHRlcm46IGVzY2FwZUdyb3VwKHBhdHRlcm4pXG5cdCAgICB9KVxuXHQgIH1cblxuXHQgIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cblx0ICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG5cdCAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpXG5cdCAgfVxuXG5cdCAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cblx0ICBpZiAocGF0aCkge1xuXHQgICAgdG9rZW5zLnB1c2gocGF0aClcblx0ICB9XG5cblx0ICByZXR1cm4gdG9rZW5zXG5cdH1cblxuXHQvKipcblx0ICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cblx0ICpcblx0ICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcblx0ICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuXHQgKi9cblx0ZnVuY3Rpb24gY29tcGlsZSAoc3RyKSB7XG5cdCAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyKSlcblx0fVxuXG5cdC8qKlxuXHQgKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cblx0ICpcblx0ICogQHBhcmFtICB7c3RyaW5nfVxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuXHQgIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG5cdCAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG5cdCAgfSlcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9XG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcblx0ICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuXHQgICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuXHQgIH0pXG5cdH1cblxuXHQvKipcblx0ICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcblx0ICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cblx0ICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKVxuXG5cdCAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJylcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuXHQgICAgdmFyIHBhdGggPSAnJ1xuXHQgICAgdmFyIGRhdGEgPSBvYmogfHwge31cblx0ICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fVxuXHQgICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG5cdCAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgcGF0aCArPSB0b2tlblxuXG5cdCAgICAgICAgY29udGludWVcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV1cblx0ICAgICAgdmFyIHNlZ21lbnRcblxuXHQgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuXHQgICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG5cdCAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuXHQgICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeFxuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBjb250aW51ZVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuXHQgICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcblx0ICAgICAgICAgICAgY29udGludWVcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5Jylcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKVxuXG5cdCAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY29udGludWVcblx0ICAgICAgfVxuXG5cdCAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSlcblxuXHQgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuXHQgICAgICB9XG5cblx0ICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBwYXRoXG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG5cdCAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcblx0fVxuXG5cdC8qKlxuXHQgKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG5cdCAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG5cdH1cblxuXHQvKipcblx0ICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cblx0ICpcblx0ICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcblx0ICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuXHQgKiBAcmV0dXJuIHshUmVnRXhwfVxuXHQgKi9cblx0ZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcblx0ICByZS5rZXlzID0ga2V5c1xuXHQgIHJldHVybiByZVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuXHQgIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG5cdH1cblxuXHQvKipcblx0ICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuXHQgKlxuXHQgKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG5cdCAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcblx0ICogQHJldHVybiB7IVJlZ0V4cH1cblx0ICovXG5cdGZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG5cdCAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cblx0ICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZylcblxuXHQgIGlmIChncm91cHMpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGtleXMucHVzaCh7XG5cdCAgICAgICAgbmFtZTogaSxcblx0ICAgICAgICBwcmVmaXg6IG51bGwsXG5cdCAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuXHQgICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcblx0ICAgICAgICByZXBlYXQ6IGZhbHNlLFxuXHQgICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuXHQgICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcblx0ICAgICAgICBwYXR0ZXJuOiBudWxsXG5cdCAgICAgIH0pXG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cblx0ICpcblx0ICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuXHQgKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG5cdCAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcblx0ICogQHJldHVybiB7IVJlZ0V4cH1cblx0ICovXG5cdGZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcblx0ICB2YXIgcGFydHMgPSBbXVxuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpXG5cdCAgfVxuXG5cdCAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKVxuXG5cdCAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG5cdCAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcblx0ICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuXHQgKiBAcmV0dXJuIHshUmVnRXhwfVxuXHQgKi9cblx0ZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcblx0ICB2YXIgdG9rZW5zID0gcGFyc2UocGF0aClcblx0ICB2YXIgcmUgPSB0b2tlbnNUb1JlZ0V4cCh0b2tlbnMsIG9wdGlvbnMpXG5cblx0ICAvLyBBdHRhY2gga2V5cyBiYWNrIHRvIHRoZSByZWdleHAuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldICE9PSAnc3RyaW5nJykge1xuXHQgICAgICBrZXlzLnB1c2godG9rZW5zW2ldKVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBhdHRhY2hLZXlzKHJlLCBrZXlzKVxuXHR9XG5cblx0LyoqXG5cdCAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG5cdCAqXG5cdCAqIEBwYXJhbSAgeyFBcnJheX0gIHRva2Vuc1xuXHQgKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG5cdCAqIEByZXR1cm4geyFSZWdFeHB9XG5cdCAqL1xuXHRmdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBvcHRpb25zKSB7XG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuXHQgIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdFxuXHQgIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2Vcblx0ICB2YXIgcm91dGUgPSAnJ1xuXHQgIHZhciBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdXG5cdCAgdmFyIGVuZHNXaXRoU2xhc2ggPSB0eXBlb2YgbGFzdFRva2VuID09PSAnc3RyaW5nJyAmJiAvXFwvJC8udGVzdChsYXN0VG9rZW4pXG5cblx0ICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuXHQgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpXG5cdCAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknXG5cblx0ICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuXHQgICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJ1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG5cdCAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG5cdCAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPydcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nXG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknXG5cdCAgICAgIH1cblxuXHQgICAgICByb3V0ZSArPSBjYXB0dXJlXG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cblx0ICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcblx0ICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG5cdCAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuXHQgIGlmICghc3RyaWN0KSB7XG5cdCAgICByb3V0ZSA9IChlbmRzV2l0aFNsYXNoID8gcm91dGUuc2xpY2UoMCwgLTIpIDogcm91dGUpICsgJyg/OlxcXFwvKD89JCkpPydcblx0ICB9XG5cblx0ICBpZiAoZW5kKSB7XG5cdCAgICByb3V0ZSArPSAnJCdcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcblx0ICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG5cdCAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhTbGFzaCA/ICcnIDogJyg/PVxcXFwvfCQpJ1xuXHQgIH1cblxuXHQgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSlcblx0fVxuXG5cdC8qKlxuXHQgKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG5cdCAqXG5cdCAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG5cdCAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcblx0ICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG5cdCAqXG5cdCAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuXHQgKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcblx0ICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG5cdCAqIEByZXR1cm4geyFSZWdFeHB9XG5cdCAqL1xuXHRmdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcblx0ICBrZXlzID0ga2V5cyB8fCBbXVxuXG5cdCAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG5cdCAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cylcblx0ICAgIGtleXMgPSBbXVxuXHQgIH0gZWxzZSBpZiAoIW9wdGlvbnMpIHtcblx0ICAgIG9wdGlvbnMgPSB7fVxuXHQgIH1cblxuXHQgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdCAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcblx0ICB9XG5cblx0ICBpZiAoaXNhcnJheShwYXRoKSkge1xuXHQgICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcblx0ICB9XG5cblx0ICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcblx0fVxuXHR9KTtcblxuXHR2YXIgUmVnZXhwID0gaW50ZXJvcERlZmF1bHQoaW5kZXgpO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVJvdXRlTWFwIChyb3V0ZXMgICAgICAgICAgICAgICAgICAgICkgICBcblx0ICAgICAgICAgICAgICAgICAgICBcblx0ICAgICAgICAgICAgICAgICAgIFxuXHQgIHtcblx0ICB2YXIgcGF0aE1hcCAgICAgICAgICAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdCAgdmFyIG5hbWVNYXAgICAgICAgICAgID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG5cdCAgcm91dGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlKSB7XG5cdCAgICBhZGRSb3V0ZVJlY29yZChwYXRoTWFwLCBuYW1lTWFwLCByb3V0ZSlcblx0ICB9KVxuXG5cdCAgcmV0dXJuIHtcblx0ICAgIHBhdGhNYXA6IHBhdGhNYXAsXG5cdCAgICBuYW1lTWFwOiBuYW1lTWFwXG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkUm91dGVSZWNvcmQgKFxuXHQgIHBhdGhNYXAgICAgICAgICAgLFxuXHQgIG5hbWVNYXAgICAgICAgICAgLFxuXHQgIHJvdXRlICAgICAgICAgICAgICxcblx0ICBwYXJlbnQgICAgICAgICAgICAgICxcblx0ICBtYXRjaEFzICAgICAgICAgXG5cdCkge1xuXHQgIHZhciBwYXRoID0gcm91dGUucGF0aDtcblx0ICB2YXIgbmFtZSA9IHJvdXRlLm5hbWU7XG5cdCAgYXNzZXJ0KHBhdGggIT0gbnVsbCwgXCJcXFwicGF0aFxcXCIgaXMgcmVxdWlyZWQgaW4gYSByb3V0ZSBjb25maWd1cmF0aW9uLlwiKVxuXG5cdCAgdmFyIHJlY29yZCAgICAgICAgICAgICAgPSB7XG5cdCAgICBwYXRoOiBub3JtYWxpemVQYXRoKHBhdGgsIHBhcmVudCksXG5cdCAgICBjb21wb25lbnRzOiByb3V0ZS5jb21wb25lbnRzIHx8IHsgZGVmYXVsdDogcm91dGUuY29tcG9uZW50IH0sXG5cdCAgICBpbnN0YW5jZXM6IHt9LFxuXHQgICAgbmFtZTogbmFtZSxcblx0ICAgIHBhcmVudDogcGFyZW50LFxuXHQgICAgbWF0Y2hBczogbWF0Y2hBcyxcblx0ICAgIHJlZGlyZWN0OiByb3V0ZS5yZWRpcmVjdCxcblx0ICAgIGJlZm9yZUVudGVyOiByb3V0ZS5iZWZvcmVFbnRlcixcblx0ICAgIG1ldGE6IHJvdXRlLm1ldGEgfHwge31cblx0ICB9XG5cblx0ICBpZiAocm91dGUuY2hpbGRyZW4pIHtcblx0ICAgIHJvdXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG5cdCAgICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhNYXAsIG5hbWVNYXAsIGNoaWxkLCByZWNvcmQpXG5cdCAgICB9KVxuXHQgIH1cblxuXHQgIGlmIChyb3V0ZS5hbGlhcykge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkocm91dGUuYWxpYXMpKSB7XG5cdCAgICAgIHJvdXRlLmFsaWFzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG5cdCAgICAgICAgYWRkUm91dGVSZWNvcmQocGF0aE1hcCwgbmFtZU1hcCwgeyBwYXRoOiBhbGlhcyB9LCBwYXJlbnQsIHJlY29yZC5wYXRoKVxuXHQgICAgICB9KVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYWRkUm91dGVSZWNvcmQocGF0aE1hcCwgbmFtZU1hcCwgeyBwYXRoOiByb3V0ZS5hbGlhcyB9LCBwYXJlbnQsIHJlY29yZC5wYXRoKVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHBhdGhNYXBbcmVjb3JkLnBhdGhdID0gcmVjb3JkXG5cdCAgaWYgKG5hbWUpIG5hbWVNYXBbbmFtZV0gPSByZWNvcmRcblx0fVxuXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGggKHBhdGggICAgICAgICwgcGFyZW50ICAgICAgICAgICAgICApICAgICAgICAge1xuXHQgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJylcblx0ICBpZiAocGF0aFswXSA9PT0gJy8nKSByZXR1cm4gcGF0aFxuXHQgIGlmIChwYXJlbnQgPT0gbnVsbCkgcmV0dXJuIHBhdGhcblx0ICByZXR1cm4gY2xlYW5QYXRoKCgocGFyZW50LnBhdGgpICsgXCIvXCIgKyBwYXRoKSlcblx0fVxuXG5cdHZhciByZWdleHBDYWNoZSAgIFxuXHQgICAgICAgICAgICAgICAgICBcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblx0ICAgICAgICAgICAgICAgICAgXG5cdCAgIFxuXHQgID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG5cdHZhciByZWdleHBDb21waWxlQ2FjaGUgICBcblx0ICAgICAgICAgICAgICAgICAgICAgICAgIFxuXHQgID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIgKHJvdXRlcyAgICAgICAgICAgICAgICAgICAgKSAgICAgICAgICB7XG5cdCAgdmFyIHJlZiA9IGNyZWF0ZVJvdXRlTWFwKHJvdXRlcyk7XG5cdCAgdmFyIHBhdGhNYXAgPSByZWYucGF0aE1hcDtcblx0ICB2YXIgbmFtZU1hcCA9IHJlZi5uYW1lTWFwO1xuXG5cdCAgZnVuY3Rpb24gbWF0Y2ggKFxuXHQgICAgcmF3ICAgICAgICAgICAgICxcblx0ICAgIGN1cnJlbnRSb3V0ZSAgICAgICAgLFxuXHQgICAgcmVkaXJlY3RlZEZyb20gICAgICAgICAgIFxuXHQgICkgICAgICAgIHtcblx0ICAgIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKHJhdywgY3VycmVudFJvdXRlKVxuXHQgICAgdmFyIG5hbWUgPSBsb2NhdGlvbi5uYW1lO1xuXG5cdCAgICBpZiAobmFtZSkge1xuXHQgICAgICB2YXIgcmVjb3JkID0gbmFtZU1hcFtuYW1lXVxuXHQgICAgICBpZiAocmVjb3JkKSB7XG5cdCAgICAgICAgbG9jYXRpb24ucGF0aCA9IGZpbGxQYXJhbXMocmVjb3JkLnBhdGgsIGxvY2F0aW9uLnBhcmFtcywgKFwibmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSlcblx0ICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGgpIHtcblx0ICAgICAgbG9jYXRpb24ucGFyYW1zID0ge31cblx0ICAgICAgZm9yICh2YXIgcGF0aCBpbiBwYXRoTWFwKSB7XG5cdCAgICAgICAgaWYgKG1hdGNoUm91dGUocGF0aCwgbG9jYXRpb24ucGFyYW1zLCBsb2NhdGlvbi5wYXRoKSkge1xuXHQgICAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShwYXRoTWFwW3BhdGhdLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICAvLyBubyBtYXRjaFxuXHQgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcblx0ICB9XG5cblx0ICBmdW5jdGlvbiByZWRpcmVjdCAoXG5cdCAgICByZWNvcmQgICAgICAgICAgICAgLFxuXHQgICAgbG9jYXRpb24gICAgICAgICAgXG5cdCAgKSAgICAgICAge1xuXHQgICAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnk7XG5cdCAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cdCAgICB2YXIgcGFyYW1zID0gbG9jYXRpb24ucGFyYW1zO1xuXHQgICAgdmFyIHJlZGlyZWN0ID0gcmVjb3JkLnJlZGlyZWN0O1xuXHQgICAgdmFyIG5hbWUgPSByZWRpcmVjdCAmJiB0eXBlb2YgcmVkaXJlY3QgPT09ICdvYmplY3QnICYmIHJlZGlyZWN0Lm5hbWVcblx0ICAgIGlmIChuYW1lKSB7XG5cdCAgICAgIC8vIHJlc29sdmVkIG5hbWVkIGRpcmVjdFxuXHQgICAgICB2YXIgdGFyZ2V0UmVjb3JkID0gbmFtZU1hcFtuYW1lXVxuXHQgICAgICBhc3NlcnQodGFyZ2V0UmVjb3JkLCAoXCJyZWRpcmVjdCBmYWlsZWQ6IG5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgbm90IGZvdW5kLlwiKSlcblx0ICAgICAgcmV0dXJuIG1hdGNoKHtcblx0ICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcblx0ICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgIHF1ZXJ5OiBxdWVyeSxcblx0ICAgICAgICBoYXNoOiBoYXNoLFxuXHQgICAgICAgIHBhcmFtczogcGFyYW1zXG5cdCAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWRpcmVjdCA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgLy8gMS4gcmVzb2x2ZSByZWxhdGl2ZSByZWRpcmVjdFxuXHQgICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHJlZGlyZWN0LCByZWNvcmQpXG5cdCAgICAgIC8vIDIuIHJlc29sdmUgcGFyYW1zXG5cdCAgICAgIHZhciBwYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMsIChcInJlZGlyZWN0IHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyByYXdQYXRoICsgXCJcXFwiXCIpKVxuXHQgICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcblx0ICAgICAgcmV0dXJuIG1hdGNoKHtcblx0ICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcblx0ICAgICAgICBwYXRoOiBwYXRoLFxuXHQgICAgICAgIHF1ZXJ5OiBxdWVyeSxcblx0ICAgICAgICBoYXNoOiBoYXNoXG5cdCAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB3YXJuKGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSkpXG5cdCAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gYWxpYXMgKFxuXHQgICAgcmVjb3JkICAgICAgICAgICAgICxcblx0ICAgIGxvY2F0aW9uICAgICAgICAgICxcblx0ICAgIG1hdGNoQXMgICAgICAgIFxuXHQgICkgICAgICAgIHtcblx0ICAgIHZhciBhbGlhc2VkUGF0aCA9IGZpbGxQYXJhbXMobWF0Y2hBcywgbG9jYXRpb24ucGFyYW1zLCAoXCJhbGlhc2VkIHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyBtYXRjaEFzICsgXCJcXFwiXCIpKVxuXHQgICAgdmFyIGFsaWFzZWRNYXRjaCA9IG1hdGNoKHtcblx0ICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG5cdCAgICAgIHBhdGg6IGFsaWFzZWRQYXRoXG5cdCAgICB9KVxuXHQgICAgaWYgKGFsaWFzZWRNYXRjaCkge1xuXHQgICAgICB2YXIgbWF0Y2hlZCA9IGFsaWFzZWRNYXRjaC5tYXRjaGVkXG5cdCAgICAgIHZhciBhbGlhc2VkUmVjb3JkID0gbWF0Y2hlZFttYXRjaGVkLmxlbmd0aCAtIDFdXG5cdCAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IGFsaWFzZWRNYXRjaC5wYXJhbXNcblx0ICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShhbGlhc2VkUmVjb3JkLCBsb2NhdGlvbilcblx0ICAgIH1cblx0ICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gX2NyZWF0ZVJvdXRlIChcblx0ICAgIHJlY29yZCAgICAgICAgICAgICAgLFxuXHQgICAgbG9jYXRpb24gICAgICAgICAgLFxuXHQgICAgcmVkaXJlY3RlZEZyb20gICAgICAgICAgIFxuXHQgICkgICAgICAgIHtcblx0ICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLnJlZGlyZWN0KSB7XG5cdCAgICAgIHJldHVybiByZWRpcmVjdChyZWNvcmQsIHJlZGlyZWN0ZWRGcm9tIHx8IGxvY2F0aW9uKVxuXHQgICAgfVxuXHQgICAgaWYgKHJlY29yZCAmJiByZWNvcmQubWF0Y2hBcykge1xuXHQgICAgICByZXR1cm4gYWxpYXMocmVjb3JkLCBsb2NhdGlvbiwgcmVjb3JkLm1hdGNoQXMpXG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG5cdCAgfVxuXG5cdCAgcmV0dXJuIG1hdGNoXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVSb3V0ZSAoXG5cdCAgcmVjb3JkICAgICAgICAgICAgICAsXG5cdCAgbG9jYXRpb24gICAgICAgICAgLFxuXHQgIHJlZGlyZWN0ZWRGcm9tICAgICAgICAgICBcblx0KSAgICAgICAge1xuXHQgIHZhciByb3V0ZSAgICAgICAgPSB7XG5cdCAgICBuYW1lOiBsb2NhdGlvbi5uYW1lIHx8IChyZWNvcmQgJiYgcmVjb3JkLm5hbWUpLFxuXHQgICAgbWV0YTogKHJlY29yZCAmJiByZWNvcmQubWV0YSkgfHwge30sXG5cdCAgICBwYXRoOiBsb2NhdGlvbi5wYXRoIHx8ICcvJyxcblx0ICAgIGhhc2g6IGxvY2F0aW9uLmhhc2ggfHwgJycsXG5cdCAgICBxdWVyeTogbG9jYXRpb24ucXVlcnkgfHwge30sXG5cdCAgICBwYXJhbXM6IGxvY2F0aW9uLnBhcmFtcyB8fCB7fSxcblx0ICAgIGZ1bGxQYXRoOiBnZXRGdWxsUGF0aChsb2NhdGlvbiksXG5cdCAgICBtYXRjaGVkOiByZWNvcmQgPyBmb3JtYXRNYXRjaChyZWNvcmQpIDogW11cblx0ICB9XG5cdCAgaWYgKHJlZGlyZWN0ZWRGcm9tKSB7XG5cdCAgICByb3V0ZS5yZWRpcmVjdGVkRnJvbSA9IGdldEZ1bGxQYXRoKHJlZGlyZWN0ZWRGcm9tKVxuXHQgIH1cblx0ICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyb3V0ZSlcblx0fVxuXG5cdGZ1bmN0aW9uIG1hdGNoUm91dGUgKFxuXHQgIHBhdGggICAgICAgICxcblx0ICBwYXJhbXMgICAgICAgICxcblx0ICBwYXRobmFtZSAgICAgICAgXG5cdCkgICAgICAgICAge1xuXHQgIHZhciBrZXlzLCByZWdleHBcblx0ICB2YXIgaGl0ID0gcmVnZXhwQ2FjaGVbcGF0aF1cblx0ICBpZiAoaGl0KSB7XG5cdCAgICBrZXlzID0gaGl0LmtleXNcblx0ICAgIHJlZ2V4cCA9IGhpdC5yZWdleHBcblx0ICB9IGVsc2Uge1xuXHQgICAga2V5cyA9IFtdXG5cdCAgICByZWdleHAgPSBSZWdleHAocGF0aCwga2V5cylcblx0ICAgIHJlZ2V4cENhY2hlW3BhdGhdID0geyBrZXlzOiBrZXlzLCByZWdleHA6IHJlZ2V4cCB9XG5cdCAgfVxuXHQgIHZhciBtID0gcGF0aG5hbWUubWF0Y2gocmVnZXhwKVxuXG5cdCAgaWYgKCFtKSB7XG5cdCAgICByZXR1cm4gZmFsc2Vcblx0ICB9IGVsc2UgaWYgKCFwYXJhbXMpIHtcblx0ICAgIHJldHVybiB0cnVlXG5cdCAgfVxuXG5cdCAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IG0ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0ICAgIHZhciBrZXkgPSBrZXlzW2kgLSAxXVxuXHQgICAgdmFyIHZhbCA9IHR5cGVvZiBtW2ldID09PSAnc3RyaW5nJyA/IGRlY29kZVVSSUNvbXBvbmVudChtW2ldKSA6IG1baV1cblx0ICAgIGlmIChrZXkpIHBhcmFtc1trZXkubmFtZV0gPSB2YWxcblx0ICB9XG5cblx0ICByZXR1cm4gdHJ1ZVxuXHR9XG5cblx0ZnVuY3Rpb24gZmlsbFBhcmFtcyAoXG5cdCAgcGF0aCAgICAgICAgLFxuXHQgIHBhcmFtcyAgICAgICAgICxcblx0ICByb3V0ZU1zZyAgICAgICAgXG5cdCkgICAgICAgICB7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBmaWxsZXIgPVxuXHQgICAgICByZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gfHxcblx0ICAgICAgKHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSA9IFJlZ2V4cC5jb21waWxlKHBhdGgpKVxuXHQgICAgcmV0dXJuIGZpbGxlcihwYXJhbXMgfHwge30sIHsgcHJldHR5OiB0cnVlIH0pXG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgICAgYXNzZXJ0KGZhbHNlLCAoXCJtaXNzaW5nIHBhcmFtIGZvciBcIiArIHJvdXRlTXNnICsgXCI6IFwiICsgKGUubWVzc2FnZSkpKVxuXHQgICAgcmV0dXJuICcnXG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0TWF0Y2ggKHJlY29yZCAgICAgICAgICAgICAgKSAgICAgICAgICAgICAgICAgICAgIHtcblx0ICB2YXIgcmVzID0gW11cblx0ICB3aGlsZSAocmVjb3JkKSB7XG5cdCAgICByZXMudW5zaGlmdChyZWNvcmQpXG5cdCAgICByZWNvcmQgPSByZWNvcmQucGFyZW50XG5cdCAgfVxuXHQgIHJldHVybiByZXNcblx0fVxuXG5cdGZ1bmN0aW9uIHJlc29sdmVSZWNvcmRQYXRoIChwYXRoICAgICAgICAsIHJlY29yZCAgICAgICAgICAgICApICAgICAgICAge1xuXHQgIHJldHVybiByZXNvbHZlUGF0aChwYXRoLCByZWNvcmQucGFyZW50ID8gcmVjb3JkLnBhcmVudC5wYXRoIDogJy8nLCB0cnVlKVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RnVsbFBhdGggKHJlZikge1xuXHQgIHZhciBwYXRoID0gcmVmLnBhdGg7XG5cdCAgdmFyIHF1ZXJ5ID0gcmVmLnF1ZXJ5OyBpZiAoIHF1ZXJ5ID09PSB2b2lkIDAgKSBxdWVyeSA9IHt9O1xuXHQgIHZhciBoYXNoID0gcmVmLmhhc2g7IGlmICggaGFzaCA9PT0gdm9pZCAwICkgaGFzaCA9ICcnO1xuXG5cdCAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyBzdHJpbmdpZnlRdWVyeShxdWVyeSkgKyBoYXNoXG5cdH1cblxuXHQvKiAgICAgICAqL1xuXG5cdHZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuXG5cdHZhciBzdXBwb3J0c0hpc3RvcnkgPSBpbkJyb3dzZXIgJiYgKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudFxuXG5cdCAgaWYgKFxuXHQgICAgKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmXG5cdCAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG5cdCAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcblx0ICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTFcblx0ICApIHtcblx0ICAgIHJldHVybiBmYWxzZVxuXHQgIH1cblxuXHQgIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeVxuXHR9KSgpXG5cblx0LyogICAgICAgKi9cblxuXHRmdW5jdGlvbiBydW5RdWV1ZSAocXVldWUgICAgICAgICAgICAsIGZuICAgICAgICAgICwgY2IgICAgICAgICAgKSB7XG5cdCAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcblx0ICAgIGlmIChpbmRleCA+PSBxdWV1ZS5sZW5ndGgpIHtcblx0ICAgICAgY2IoKVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZm4ocXVldWVbaW5kZXhdLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgc3RlcChpbmRleCArIDEpXG5cdCAgICAgIH0pXG5cdCAgICB9XG5cdCAgfVxuXHQgIHN0ZXAoMClcblx0fVxuXG5cdHZhciBIaXN0b3J5ID0gZnVuY3Rpb24gSGlzdG9yeSAocm91dGVyICAgICAgICAgLCBiYXNlICAgICAgICkge1xuXHQgIHRoaXMucm91dGVyID0gcm91dGVyXG5cdCAgdGhpcy5iYXNlID0gbm9ybWFsaXplQmFzZShiYXNlKVxuXHQgIC8vIHN0YXJ0IHdpdGggYSByb3V0ZSBvYmplY3QgdGhhdCBzdGFuZHMgZm9yIFwibm93aGVyZVwiXG5cdCAgdGhpcy5jdXJyZW50ID0gY3JlYXRlUm91dGUobnVsbCwge1xuXHQgICAgcGF0aDogJ19fdnVlX3JvdXRlcl9pbml0X18nXG5cdCAgfSlcblx0ICB0aGlzLnBlbmRpbmcgPSBudWxsXG5cdH07XG5cblx0SGlzdG9yeS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuIChjYiAgICAgICAgKSB7XG5cdCAgdGhpcy5jYiA9IGNiXG5cdH07XG5cblx0SGlzdG9yeS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvIChsb2NhdGlvbiAgICAgICAgICAgLCBjYiAgICAgICAgICkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICB2YXIgcm91dGUgPSB0aGlzLnJvdXRlci5tYXRjaChsb2NhdGlvbiwgdGhpcy5jdXJyZW50KVxuXHQgIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSlcblx0ICAgIGNiICYmIGNiKHJvdXRlKVxuXHQgIH0pXG5cdH07XG5cblx0SGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUgICAgICwgY2IgICAgICAgICkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICBpZiAoaXNTYW1lUm91dGUocm91dGUsIHRoaXMuY3VycmVudCkpIHtcblx0ICAgIHJldHVyblxuXHQgIH1cblxuXHQgIHZhciByZWYgPSByZXNvbHZlUXVldWUodGhpcy5jdXJyZW50Lm1hdGNoZWQsIHJvdXRlLm1hdGNoZWQpO1xuXHQgICAgdmFyIGRlYWN0aXZhdGVkID0gcmVmLmRlYWN0aXZhdGVkO1xuXHQgICAgdmFyIGFjdGl2YXRlZCA9IHJlZi5hY3RpdmF0ZWQ7XG5cblx0ICB2YXIgcXVldWUgPSBbXS5jb25jYXQoXG5cdCAgICAvLyBkZWFjdGl2YXRlIGd1YXJkc1xuXHQgICAgZXh0cmFjdExlYXZlR3VhcmRzKGRlYWN0aXZhdGVkKSxcblx0ICAgIC8vIGdsb2JhbCBiZWZvcmUgaG9va3Ncblx0ICAgIHRoaXMucm91dGVyLmJlZm9yZUhvb2tzLFxuXHQgICAgLy8gYWN0aXZhdGUgZ3VhcmRzXG5cdCAgICBhY3RpdmF0ZWQubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmJlZm9yZUVudGVyOyB9KSxcblx0ICAgIC8vIGFzeW5jIGNvbXBvbmVudHNcblx0ICAgIHJlc29sdmVBc3luY0NvbXBvbmVudHMoYWN0aXZhdGVkKVxuXHQgICkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuXG5cdCAgdGhpcy5wZW5kaW5nID0gcm91dGVcblx0ICB2YXIgcmVkaXJlY3QgPSBmdW5jdGlvbiAobG9jYXRpb24pIHsgcmV0dXJuIHRoaXMkMS5wdXNoKGxvY2F0aW9uKTsgfVxuXG5cdCAgcnVuUXVldWUoXG5cdCAgICBxdWV1ZSxcblx0ICAgIGZ1bmN0aW9uIChob29rLCBuZXh0KSB7IGhvb2socm91dGUsIHJlZGlyZWN0LCBuZXh0KSB9LFxuXHQgICAgZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoaXNTYW1lUm91dGUocm91dGUsIHRoaXMkMS5wZW5kaW5nKSkge1xuXHQgICAgICAgIHRoaXMkMS5wZW5kaW5nID0gbnVsbFxuXHQgICAgICAgIGNiKHJvdXRlKVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgKVxuXHR9O1xuXG5cdEhpc3RvcnkucHJvdG90eXBlLnVwZGF0ZVJvdXRlID0gZnVuY3Rpb24gdXBkYXRlUm91dGUgKHJvdXRlICAgICApIHtcblx0ICB0aGlzLmN1cnJlbnQgPSByb3V0ZVxuXHQgIHRoaXMuY2IgJiYgdGhpcy5jYihyb3V0ZSlcblx0ICB0aGlzLnJvdXRlci5hZnRlckhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcblx0ICAgIGhvb2sgJiYgaG9vayhyb3V0ZSlcblx0ICB9KVxuXHR9O1xuXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZUJhc2UgKGJhc2UgICAgICAgICApICAgICAgICAge1xuXHQgIGlmICghYmFzZSkge1xuXHQgICAgaWYgKGluQnJvd3Nlcikge1xuXHQgICAgICAvLyByZXNwZWN0IDxiYXNlPiB0YWdcblx0ICAgICAgdmFyIGJhc2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKVxuXHQgICAgICBiYXNlID0gYmFzZUVsID8gYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpIDogJy8nXG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBiYXNlID0gJy8nXG5cdCAgICB9XG5cdCAgfVxuXHQgIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIHRoZSBzdGFydGluZyBzbGFzaFxuXHQgIGlmIChiYXNlLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG5cdCAgICBiYXNlID0gJy8nICsgYmFzZVxuXHQgIH1cblx0ICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2hcblx0ICByZXR1cm4gYmFzZS5yZXBsYWNlKC9cXC8kLywgJycpXG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlUXVldWUgKFxuXHQgIGN1cnJlbnQgICAgICAgICAgICAgICAgICAgICxcblx0ICBuZXh0ICAgICAgICAgICAgICAgICAgICBcblx0KSAgIFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblx0ICB7XG5cdCAgdmFyIGlcblx0ICB2YXIgbWF4ID0gTWF0aC5tYXgoY3VycmVudC5sZW5ndGgsIG5leHQubGVuZ3RoKVxuXHQgIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuXHQgICAgaWYgKGN1cnJlbnRbaV0gIT09IG5leHRbaV0pIHtcblx0ICAgICAgYnJlYWtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHtcblx0ICAgIGFjdGl2YXRlZDogbmV4dC5zbGljZShpKSxcblx0ICAgIGRlYWN0aXZhdGVkOiBjdXJyZW50LnNsaWNlKGkpXG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZXh0cmFjdExlYXZlR3VhcmRzIChtYXRjaGVkICAgICAgICAgICAgICAgICAgICApICAgICAgICAgICAgICAgICAgIHtcblx0ICByZXR1cm4gZmxhdE1hcENvbXBvbmVudHMobWF0Y2hlZCwgZnVuY3Rpb24gKGRlZiwgaW5zdGFuY2UpIHtcblx0ICAgIHZhciBndWFyZCA9IGRlZiAmJiBkZWYuYmVmb3JlUm91dGVMZWF2ZVxuXHQgICAgaWYgKGd1YXJkKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiByb3V0ZUd1YXJkICgpIHtcblx0ICAgICAgICByZXR1cm4gZ3VhcmQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cylcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pLnJldmVyc2UoKVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyAobWF0Y2hlZCAgICAgICAgICAgICAgICAgICAgKSAgICAgICAgICAgICAgICAgICB7XG5cdCAgcmV0dXJuIGZsYXRNYXBDb21wb25lbnRzKG1hdGNoZWQsIGZ1bmN0aW9uIChkZWYsIF8sIG1hdGNoLCBrZXkpIHtcblx0ICAgIC8vIGlmIGl0J3MgYSBmdW5jdGlvbiBhbmQgZG9lc24ndCBoYXZlIFZ1ZSBvcHRpb25zIGF0dGFjaGVkLFxuXHQgICAgLy8gYXNzdW1lIGl0J3MgYW4gYXN5bmMgY29tcG9uZW50IHJlc29sdmUgZnVuY3Rpb24uXG5cdCAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIFZ1ZSdzIGRlZmF1bHQgYXN5bmMgcmVzb2x2aW5nIG1lY2hhbmlzbSBiZWNhdXNlXG5cdCAgICAvLyB3ZSB3YW50IHRvIGhhbHQgdGhlIG5hdmlnYXRpb24gdW50aWwgdGhlIGluY29taW5nIGNvbXBvbmVudCBoYXMgYmVlblxuXHQgICAgLy8gcmVzb2x2ZWQuXG5cdCAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhZGVmLm9wdGlvbnMpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyb3V0ZSwgcmVkaXJlY3QsIG5leHQpIHsgcmV0dXJuIGRlZihmdW5jdGlvbiAocmVzb2x2ZWREZWYpIHtcblx0ICAgICAgICBtYXRjaC5jb21wb25lbnRzW2tleV0gPSByZXNvbHZlZERlZlxuXHQgICAgICAgIG5leHQoKVxuXHQgICAgICB9KTsgfVxuXHQgICAgfVxuXHQgIH0pXG5cdH1cblxuXHRmdW5jdGlvbiBmbGF0TWFwQ29tcG9uZW50cyAoXG5cdCAgbWF0Y2hlZCAgICAgICAgICAgICAgICAgICAgLFxuXHQgIGZuICAgICAgICAgIFxuXHQpICAgICAgICAgICAgICAgICAgIHtcblx0ICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgbWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcblx0ICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihcblx0ICAgICAgbS5jb21wb25lbnRzW2tleV0sXG5cdCAgICAgIG0uaW5zdGFuY2VzW2tleV0gJiYgbS5pbnN0YW5jZXNba2V5XS5jaGlsZCxcblx0ICAgICAgbSwga2V5XG5cdCAgICApOyB9KVxuXHQgIH0pKVxuXHR9XG5cblx0LyogICAgICAgKi9cblxuXHRmdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24gKGtleSAgICAgICAgKSB7XG5cdCAgaWYgKCFrZXkpIHJldHVyblxuXHQgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoe1xuXHQgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuXHQgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG5cdCAgfSkpXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTY3JvbGxQb3NpdGlvbiAoa2V5ICAgICAgICApICAgICAgICAgIHtcblx0ICBpZiAoIWtleSkgcmV0dXJuXG5cdCAgcmV0dXJuIEpTT04ucGFyc2Uod2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KSlcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEVsZW1lbnRQb3NpdGlvbiAoZWwgICAgICAgICApICAgICAgICAge1xuXHQgIHZhciBkb2NSZWN0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cdCAgdmFyIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cdCAgcmV0dXJuIHtcblx0ICAgIHg6IGVsUmVjdC5sZWZ0IC0gZG9jUmVjdC5sZWZ0LFxuXHQgICAgeTogZWxSZWN0LnRvcCAtIGRvY1JlY3QudG9wXG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gaXNWYWxpZFBvc2l0aW9uIChvYmogICAgICAgICkgICAgICAgICAge1xuXHQgIHJldHVybiBpc051bWJlcihvYmoueCkgfHwgaXNOdW1iZXIob2JqLnkpXG5cdH1cblxuXHRmdW5jdGlvbiBub3JtYWxpemVQb3NpdGlvbiAob2JqICAgICAgICApICAgICAgICAge1xuXHQgIHJldHVybiB7XG5cdCAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcblx0ICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogd2luZG93LnBhZ2VZT2Zmc2V0XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gaXNOdW1iZXIgKHYgICAgICkgICAgICAgICAge1xuXHQgIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcidcblx0fVxuXG5cdHZhciBnZW5LZXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBTdHJpbmcoRGF0ZS5ub3coKSk7IH1cblx0dmFyIF9rZXkgICAgICAgICA9IGdlbktleSgpXG5cblx0dmFyIEhUTUw1SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSkge1xuXHQgIGZ1bmN0aW9uIEhUTUw1SGlzdG9yeSAocm91dGVyICAgICAgICAgICAsIGJhc2UgICAgICAgICApIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICBIaXN0b3J5LmNhbGwodGhpcywgcm91dGVyLCBiYXNlKVxuXG5cdCAgICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0TG9jYXRpb24odGhpcy5iYXNlKVxuXHQgICAgdGhpcy50cmFuc2l0aW9uVG8oaW5pdGlhbExvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcblx0ICAgICAgLy8gcG9zc2libGUgcmVkaXJlY3Qgb24gc3RhcnRcblx0ICAgICAgdmFyIHVybCA9IGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHRoaXMkMS5jdXJyZW50LmZ1bGxQYXRoKVxuXHQgICAgICBpZiAoaW5pdGlhbExvY2F0aW9uICE9PSB1cmwpIHtcblx0ICAgICAgICByZXBsYWNlU3RhdGUodXJsKVxuXHQgICAgICB9XG5cdCAgICB9KVxuXG5cdCAgICB2YXIgZXhwZWN0U2Nyb2xsID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3Jcblx0ICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIF9rZXkgPSBlLnN0YXRlICYmIGUuc3RhdGUua2V5XG5cdCAgICAgIHZhciBjdXJyZW50ID0gdGhpcyQxLmN1cnJlbnRcblx0ICAgICAgdGhpcyQxLnRyYW5zaXRpb25UbyhnZXRMb2NhdGlvbih0aGlzJDEuYmFzZSksIGZ1bmN0aW9uIChuZXh0KSB7XG5cdCAgICAgICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuXHQgICAgICAgICAgdGhpcyQxLmhhbmRsZVNjcm9sbChuZXh0LCBjdXJyZW50LCB0cnVlKVxuXHQgICAgICAgIH1cblx0ICAgICAgfSlcblx0ICAgIH0pXG5cblx0ICAgIGlmIChleHBlY3RTY3JvbGwpIHtcblx0ICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBzYXZlU2Nyb2xsUG9zaXRpb24oX2tleSlcblx0ICAgICAgfSlcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoIEhpc3RvcnkgKSBIVE1MNUhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeTtcblx0ICBIVE1MNUhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSAmJiBIaXN0b3J5LnByb3RvdHlwZSApO1xuXHQgIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MNUhpc3Rvcnk7XG5cblx0ICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4gICAgICAgICkge1xuXHQgICAgd2luZG93Lmhpc3RvcnkuZ28obilcblx0ICB9O1xuXG5cdCAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24gICAgICAgICAgICAgKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnRcblx0ICAgIEhpc3RvcnkucHJvdG90eXBlLnRyYW5zaXRpb25Uby5jYWxsKHRoaXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcblx0ICAgICAgcHVzaFN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSlcblx0ICAgICAgdGhpcyQxLmhhbmRsZVNjcm9sbChyb3V0ZSwgY3VycmVudCwgZmFsc2UpXG5cdCAgICB9KVxuXHQgIH07XG5cblx0ICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiAgICAgICAgICAgICApIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudFxuXHQgICAgSGlzdG9yeS5wcm90b3R5cGUudHJhbnNpdGlvblRvLmNhbGwodGhpcywgbG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuXHQgICAgICByZXBsYWNlU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKVxuXHQgICAgICB0aGlzJDEuaGFuZGxlU2Nyb2xsKHJvdXRlLCBjdXJyZW50LCBmYWxzZSlcblx0ICAgIH0pXG5cdCAgfTtcblxuXHQgIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsID0gZnVuY3Rpb24gaGFuZGxlU2Nyb2xsICh0byAgICAgICAsIGZyb20gICAgICAgLCBpc1BvcCAgICAgICAgICkge1xuXHQgICAgdmFyIHJvdXRlciA9IHRoaXMucm91dGVyXG5cdCAgICBpZiAoIXJvdXRlci5hcHApIHtcblx0ICAgICAgcmV0dXJuXG5cdCAgICB9XG5cblx0ICAgIHZhciBiZWhhdmlvciA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yXG5cdCAgICBpZiAoIWJlaGF2aW9yKSB7XG5cdCAgICAgIHJldHVyblxuXHQgICAgfVxuXHQgICAgYXNzZXJ0KHR5cGVvZiBiZWhhdmlvciA9PT0gJ2Z1bmN0aW9uJywgXCJzY3JvbGxCZWhhdmlvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblxuXHQgICAgLy8gd2FpdCB1bnRpbCByZS1yZW5kZXIgZmluaXNoZXMgYmVmb3JlIHNjcm9sbGluZ1xuXHQgICAgcm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgcG9zaXRpb24gPSBnZXRTY3JvbGxQb3NpdGlvbihfa2V5KVxuXHQgICAgICB2YXIgc2hvdWxkU2Nyb2xsID0gYmVoYXZpb3IodG8sIGZyb20sIGlzUG9wID8gcG9zaXRpb24gOiBudWxsKVxuXHQgICAgICBpZiAoIXNob3VsZFNjcm9sbCkge1xuXHQgICAgICAgIHJldHVyblxuXHQgICAgICB9XG5cdCAgICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBzaG91bGRTY3JvbGwgPT09ICdvYmplY3QnXG5cdCAgICAgIGlmIChpc09iamVjdCAmJiBzaG91bGRTY3JvbGwuc2VsZWN0b3IpIHtcblx0ICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNob3VsZFNjcm9sbC5zZWxlY3Rvcilcblx0ICAgICAgICBpZiAoZWwpIHtcblx0ICAgICAgICAgIHBvc2l0aW9uID0gZ2V0RWxlbWVudFBvc2l0aW9uKGVsKVxuXHQgICAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcblx0ICAgICAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKVxuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGlmIChpc09iamVjdCAmJiBpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuXHQgICAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHBvc2l0aW9uKSB7XG5cdCAgICAgICAgd2luZG93LnNjcm9sbFRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpXG5cdCAgICAgIH1cblx0ICAgIH0pXG5cdCAgfTtcblxuXHQgIHJldHVybiBIVE1MNUhpc3Rvcnk7XG5cdH0oSGlzdG9yeSkpO1xuXG5cdGZ1bmN0aW9uIGdldExvY2F0aW9uIChiYXNlICAgICAgICApICAgICAgICAge1xuXHQgIHZhciBwYXRoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lXG5cdCAgaWYgKGJhc2UgJiYgcGF0aC5pbmRleE9mKGJhc2UpID09PSAwKSB7XG5cdCAgICBwYXRoID0gcGF0aC5zbGljZShiYXNlLmxlbmd0aClcblx0ICB9XG5cdCAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2hcblx0fVxuXG5cdGZ1bmN0aW9uIHB1c2hTdGF0ZSAodXJsICAgICAgICAsIHJlcGxhY2UgICAgICAgICAgKSB7XG5cdCAgLy8gdHJ5Li4uY2F0Y2ggdGhlIHB1c2hTdGF0ZSBjYWxsIHRvIGdldCBhcm91bmQgU2FmYXJpXG5cdCAgLy8gRE9NIEV4Y2VwdGlvbiAxOCB3aGVyZSBpdCBsaW1pdHMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxsc1xuXHQgIHZhciBoaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnlcblx0ICB0cnkge1xuXHQgICAgaWYgKHJlcGxhY2UpIHtcblx0ICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybClcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIF9rZXkgPSBnZW5LZXkoKVxuXHQgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKVxuXHQgICAgfVxuXHQgICAgc2F2ZVNjcm9sbFBvc2l0aW9uKF9rZXkpXG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgICAgd2luZG93LmxvY2F0aW9uW3JlcGxhY2UgPyAnYXNzaWduJyA6ICdyZXBsYWNlJ10odXJsKVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAodXJsICAgICAgICApIHtcblx0ICBwdXNoU3RhdGUodXJsLCB0cnVlKVxuXHR9XG5cblx0dmFyIEhhc2hIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5KSB7XG5cdCAgZnVuY3Rpb24gSGFzaEhpc3RvcnkgKHJvdXRlciAgICAgICAgICAgLCBiYXNlICAgICAgICAgLCBmYWxsYmFjayAgICAgICAgICkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIEhpc3RvcnkuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpXG5cblx0ICAgIC8vIGNoZWNrIGhpc3RvcnkgZmFsbGJhY2sgZGVlcGxpbmtpbmdcblx0ICAgIGlmIChmYWxsYmFjayAmJiB0aGlzLmNoZWNrRmFsbGJhY2soKSkge1xuXHQgICAgICByZXR1cm5cblx0ICAgIH1cblxuXHQgICAgZW5zdXJlU2xhc2goKVxuXHQgICAgdGhpcy50cmFuc2l0aW9uVG8oZ2V0SGFzaCgpLCBmdW5jdGlvbiAocm91dGUpIHtcblx0ICAgICAgLy8gcG9zc2libGUgcmVkaXJlY3Qgb24gc3RhcnRcblx0ICAgICAgaWYgKGdldEhhc2goKSAhPT0gcm91dGUuZnVsbFBhdGgpIHtcblx0ICAgICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aClcblx0ICAgICAgfVxuXHQgICAgfSlcblxuXHQgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMkMS5vbkhhc2hDaGFuZ2UoKVxuXHQgICAgfSlcblx0ICB9XG5cblx0ICBpZiAoIEhpc3RvcnkgKSBIYXNoSGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5O1xuXHQgIEhhc2hIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkgJiYgSGlzdG9yeS5wcm90b3R5cGUgKTtcblx0ICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIYXNoSGlzdG9yeTtcblxuXHQgIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5jaGVja0ZhbGxiYWNrID0gZnVuY3Rpb24gY2hlY2tGYWxsYmFjayAoKSB7XG5cdCAgICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbih0aGlzLmJhc2UpXG5cdCAgICBpZiAoIS9eXFwvIy8udGVzdChsb2NhdGlvbikpIHtcblx0ICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoXG5cdCAgICAgICAgY2xlYW5QYXRoKHRoaXMuYmFzZSArICcvIycgKyBsb2NhdGlvbilcblx0ICAgICAgKVxuXHQgICAgICByZXR1cm4gdHJ1ZVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBIYXNoSGlzdG9yeS5wcm90b3R5cGUub25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gb25IYXNoQ2hhbmdlICgpIHtcblx0ICAgIGlmICghZW5zdXJlU2xhc2goKSkge1xuXHQgICAgICByZXR1cm5cblx0ICAgIH1cblx0ICAgIHRoaXMudHJhbnNpdGlvblRvKGdldEhhc2goKSwgZnVuY3Rpb24gKHJvdXRlKSB7XG5cdCAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKVxuXHQgICAgfSlcblx0ICB9O1xuXG5cdCAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiAgICAgICAgICAgICApIHtcblx0ICAgIEhpc3RvcnkucHJvdG90eXBlLnRyYW5zaXRpb25Uby5jYWxsKHRoaXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcblx0ICAgICAgcHVzaEhhc2gocm91dGUuZnVsbFBhdGgpXG5cdCAgICB9KVxuXHQgIH07XG5cblx0ICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uICAgICAgICAgICAgICkge1xuXHQgICAgSGlzdG9yeS5wcm90b3R5cGUudHJhbnNpdGlvblRvLmNhbGwodGhpcywgbG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuXHQgICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aClcblx0ICAgIH0pXG5cdCAgfTtcblxuXHQgIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuICAgICAgICApIHtcblx0ICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pXG5cdCAgfTtcblxuXHQgIHJldHVybiBIYXNoSGlzdG9yeTtcblx0fShIaXN0b3J5KSk7XG5cblx0ZnVuY3Rpb24gZW5zdXJlU2xhc2ggKCkgICAgICAgICAge1xuXHQgIHZhciBwYXRoID0gZ2V0SGFzaCgpXG5cdCAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHtcblx0ICAgIHJldHVybiB0cnVlXG5cdCAgfVxuXHQgIHJlcGxhY2VIYXNoKCcvJyArIHBhdGgpXG5cdCAgcmV0dXJuIGZhbHNlXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRIYXNoICgpICAgICAgICAge1xuXHQgIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3Rcblx0ICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuXHQgIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcblx0ICB2YXIgaW5kZXggPSBocmVmLmluZGV4T2YoJyMnKVxuXHQgIHJldHVybiBpbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc2xpY2UoaW5kZXggKyAxKVxuXHR9XG5cblx0ZnVuY3Rpb24gcHVzaEhhc2ggKHBhdGgpIHtcblx0ICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGhcblx0fVxuXG5cdGZ1bmN0aW9uIHJlcGxhY2VIYXNoIChwYXRoKSB7XG5cdCAgdmFyIGkgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJylcblx0ICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShcblx0ICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNsaWNlKDAsIGkgPj0gMCA/IGkgOiAwKSArICcjJyArIHBhdGhcblx0ICApXG5cdH1cblxuXHR2YXIgQWJzdHJhY3RIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5KSB7XG5cdCAgZnVuY3Rpb24gQWJzdHJhY3RIaXN0b3J5IChyb3V0ZXIgICAgICAgICAgICkge1xuXHQgICAgSGlzdG9yeS5jYWxsKHRoaXMsIHJvdXRlcilcblx0ICAgIHRoaXMuc3RhY2sgPSBbXVxuXHQgICAgdGhpcy5pbmRleCA9IDBcblx0ICB9XG5cblx0ICBpZiAoIEhpc3RvcnkgKSBBYnN0cmFjdEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeTtcblx0ICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSAmJiBIaXN0b3J5LnByb3RvdHlwZSApO1xuXHQgIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBYnN0cmFjdEhpc3Rvcnk7XG5cblx0ICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiAgICAgICAgICAgICApIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICBIaXN0b3J5LnByb3RvdHlwZS50cmFuc2l0aW9uVG8uY2FsbCh0aGlzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG5cdCAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXggKyAxKS5jb25jYXQocm91dGUpXG5cdCAgICAgIHRoaXMkMS5pbmRleCsrXG5cdCAgICB9KVxuXHQgIH07XG5cblx0ICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiAgICAgICAgICAgICApIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICBIaXN0b3J5LnByb3RvdHlwZS50cmFuc2l0aW9uVG8uY2FsbCh0aGlzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG5cdCAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXgpLmNvbmNhdChyb3V0ZSlcblx0ICAgIH0pXG5cdCAgfTtcblxuXHQgIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobiAgICAgICAgKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgdmFyIHRhcmdldEluZGV4ID0gdGhpcy5pbmRleCArIG5cblx0ICAgIGlmICghdGhpcy5zdGFjaykgZGVidWdnZXJcblx0ICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGhpcy5zdGFjay5sZW5ndGgpIHtcblx0ICAgICAgcmV0dXJuXG5cdCAgICB9XG5cdCAgICB2YXIgbG9jYXRpb24gPSB0aGlzLnN0YWNrW3RhcmdldEluZGV4XVxuXHQgICAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihsb2NhdGlvbiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzJDEuaW5kZXggPSB0YXJnZXRJbmRleFxuXHQgICAgICB0aGlzJDEudXBkYXRlUm91dGUobG9jYXRpb24pXG5cdCAgICB9KVxuXHQgIH07XG5cblx0ICByZXR1cm4gQWJzdHJhY3RIaXN0b3J5O1xuXHR9KEhpc3RvcnkpKTtcblxuXHR2YXIgVnVlUm91dGVyID0gZnVuY3Rpb24gVnVlUm91dGVyIChvcHRpb25zKSB7XG5cdCAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zICAgICAgICAgICAgICA9IHt9O1xuXG5cdCAgdGhpcy5hcHAgPSBudWxsXG5cdCAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuXHQgIHRoaXMuYmVmb3JlSG9va3MgPSBbXVxuXHQgIHRoaXMuYWZ0ZXJIb29rcyA9IFtdXG5cdCAgdGhpcy5tYXRjaCA9IGNyZWF0ZU1hdGNoZXIob3B0aW9ucy5yb3V0ZXMgfHwgW10pXG5cblx0ICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCAnaGFzaCdcblx0ICB0aGlzLmZhbGxiYWNrID0gbW9kZSA9PT0gJ2hpc3RvcnknICYmICFzdXBwb3J0c0hpc3Rvcnlcblx0ICBpZiAodGhpcy5mYWxsYmFjaykge1xuXHQgICAgbW9kZSA9ICdoYXNoJ1xuXHQgIH1cblx0ICBpZiAoIWluQnJvd3Nlcikge1xuXHQgICAgbW9kZSA9ICdhYnN0cmFjdCdcblx0ICB9XG5cdCAgdGhpcy5tb2RlID0gbW9kZVxuXHR9O1xuXG5cdHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGN1cnJlbnRSb3V0ZToge30gfTtcblxuXHRwcm90b3R5cGVBY2Nlc3NvcnMuY3VycmVudFJvdXRlLmdldCA9IGZ1bmN0aW9uICgpICAgICAgIHtcblx0ICByZXR1cm4gdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5jdXJyZW50XG5cdH07XG5cblx0VnVlUm91dGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoYXBwICAgIC8qIFZ1ZSBjb21wb25lbnQgaW5zdGFuY2UgKi8pIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgYXNzZXJ0KFxuXHQgICAgaW5zdGFsbC5pbnN0YWxsZWQsXG5cdCAgICBcIm5vdCBpbnN0YWxsZWQuIE1ha2Ugc3VyZSB0byBjYWxsIGBWdWUudXNlKFZ1ZVJvdXRlcilgIFwiICtcblx0ICAgIFwiYmVmb3JlIGNyZWF0aW5nIHJvb3QgaW5zdGFuY2UuXCJcblx0ICApXG5cblx0ICB2YXIgcmVmID0gdGhpcztcblx0ICAgIHZhciBtb2RlID0gcmVmLm1vZGU7XG5cdCAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuXHQgICAgdmFyIGZhbGxiYWNrID0gcmVmLmZhbGxiYWNrO1xuXHQgIHN3aXRjaCAobW9kZSkge1xuXHQgICAgY2FzZSAnaGlzdG9yeSc6XG5cdCAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIVE1MNUhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKVxuXHQgICAgICBicmVha1xuXHQgICAgY2FzZSAnaGFzaCc6XG5cdCAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIYXNoSGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UsIGZhbGxiYWNrKVxuXHQgICAgICBicmVha1xuXHQgICAgY2FzZSAnYWJzdHJhY3QnOlxuXHQgICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgQWJzdHJhY3RIaXN0b3J5KHRoaXMpXG5cdCAgICAgIGJyZWFrXG5cdCAgICBkZWZhdWx0OlxuXHQgICAgICBhc3NlcnQoZmFsc2UsIChcImludmFsaWQgbW9kZTogXCIgKyBtb2RlKSlcblx0ICB9XG5cblx0ICB0aGlzLmFwcCA9IGFwcFxuXHQgIHRoaXMuaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKHJvdXRlKSB7XG5cdCAgICB0aGlzJDEuYXBwLl9yb3V0ZSA9IHJvdXRlXG5cdCAgfSlcblx0fTtcblxuXHRWdWVSb3V0ZXIucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiBiZWZvcmVFYWNoIChmbiAgICAgICAgKSB7XG5cdCAgdGhpcy5iZWZvcmVIb29rcy5wdXNoKGZuKVxuXHR9O1xuXG5cdFZ1ZVJvdXRlci5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gYWZ0ZXJFYWNoIChmbiAgICAgICAgKSB7XG5cdCAgdGhpcy5hZnRlckhvb2tzLnB1c2goZm4pXG5cdH07XG5cblx0VnVlUm91dGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24gICAgICAgICAgICkge1xuXHQgIHRoaXMuaGlzdG9yeS5wdXNoKGxvY2F0aW9uKVxuXHR9O1xuXG5cdFZ1ZVJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uICAgICAgICAgICApIHtcblx0ICB0aGlzLmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbilcblx0fTtcblxuXHRWdWVSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4gICAgICApIHtcblx0ICB0aGlzLmhpc3RvcnkuZ28obilcblx0fTtcblxuXHRWdWVSb3V0ZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiBiYWNrICgpIHtcblx0ICB0aGlzLmdvKC0xKVxuXHR9O1xuXG5cdFZ1ZVJvdXRlci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIGZvcndhcmQgKCkge1xuXHQgIHRoaXMuZ28oMSlcblx0fTtcblxuXHRWdWVSb3V0ZXIucHJvdG90eXBlLmdldE1hdGNoZWRDb21wb25lbnRzID0gZnVuY3Rpb24gZ2V0TWF0Y2hlZENvbXBvbmVudHMgKCkgICAgICAgICAgIHtcblx0ICBpZiAoIXRoaXMuY3VycmVudFJvdXRlKSB7XG5cdCAgICByZXR1cm4gW11cblx0ICB9XG5cdCAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgdGhpcy5jdXJyZW50Um91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcblx0ICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgIHJldHVybiBtLmNvbXBvbmVudHNba2V5XVxuXHQgICAgfSlcblx0ICB9KSlcblx0fTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVnVlUm91dGVyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cblx0VnVlUm91dGVyLmluc3RhbGwgPSBpbnN0YWxsXG5cblx0aWYgKGluQnJvd3NlciAmJiB3aW5kb3cuVnVlKSB7XG5cdCAgd2luZG93LlZ1ZS51c2UoVnVlUm91dGVyKVxuXHR9XG5cblx0cmV0dXJuIFZ1ZVJvdXRlcjtcblxufSkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuanMiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7OztBQUdBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Vue.js v2.0.0-rc.2\n * (c) 2014-2016 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Vue = factory());\n}(this, function () { 'use strict';\n\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n  function _toString(val) {\n    return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val);\n  }\n\n  /**\n   * Convert a input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n  function toNumber(val) {\n    var n = parseFloat(val, 10);\n    return n || n === 0 ? n : val;\n  }\n\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n  function makeMap(str, expectsLowerCase) {\n    var map = Object.create(null);\n    var list = str.split(',');\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase ? function (val) {\n      return map[val.toLowerCase()];\n    } : function (val) {\n      return map[val];\n    };\n  }\n\n  /**\n   * Check if a tag is a built-in tag.\n   */\n  var isBuiltInTag = makeMap('slot,component', true);\n\n  /**\n   * Remove an item from an array\n   */\n  function remove(arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n      if (index > -1) {\n        return arr.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Check whether the object has the property.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n\n  /**\n   * Check if value is primitive\n   */\n  function isPrimitive(value) {\n    return typeof value === 'string' || typeof value === 'number';\n  }\n\n  /**\n   * Create a cached version of a pure function.\n   */\n  function cached(fn) {\n    var cache = Object.create(null);\n    return function cachedFn(str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  }\n\n  /**\n   * Camelize a hyphen-delmited string.\n   */\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) {\n      return c ? c.toUpperCase() : '';\n    });\n  });\n\n  /**\n   * Capitalize a string.\n   */\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  });\n\n  /**\n   * Hyphenate a camelCase string.\n   */\n  var hyphenateRE = /([^-])([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();\n  });\n\n  /**\n   * Simple bind, faster than native\n   */\n  function bind(fn, ctx) {\n    function boundFn(a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    }\n    // record original fn length\n    boundFn._length = fn.length;\n    return boundFn;\n  }\n\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n    return ret;\n  }\n\n  /**\n   * Mix properties into target object.\n   */\n  function extend(to, _from) {\n    for (var _key in _from) {\n      to[_key] = _from[_key];\n    }\n    return to;\n  }\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n  function isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n  }\n\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n  var toString = Object.prototype.toString;\n  var OBJECT_STRING = '[object Object]';\n  function isPlainObject(obj) {\n    return toString.call(obj) === OBJECT_STRING;\n  }\n\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n  function toObject(arr) {\n    var res = arr[0] || {};\n    for (var i = 1; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Perform no operation.\n   */\n  function noop() {}\n\n  /**\n   * Always return false.\n   */\n  var no = function no() {\n    return false;\n  };\n\n  /**\n   * Generate a static keys string from compiler modules.\n   */\n  function genStaticKeys(modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || []);\n    }, []).join(',');\n  }\n\n  var config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: null,\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * List of asset types that a component can own.\n     */\n    _assetTypes: ['component', 'directive', 'filter'],\n\n    /**\n     * List of lifecycle hooks.\n     */\n    _lifecycleHooks: ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'],\n\n    /**\n     * Max circular updates allowed in a scheduler flush cycle.\n     */\n    _maxUpdateCount: 100,\n\n    /**\n     * Server rendering?\n     */\n    _isServer: \"client\" === 'server'\n  };\n\n  /**\n   * Check if a string starts with $ or _\n   */\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n\n  /**\n   * Define a property.\n   */\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /**\n   * Parse simple path.\n   */\n  var bailRE = /[^\\w\\.\\$]/;\n  function parsePath(path) {\n    if (bailRE.test(path)) {\n      return;\n    } else {\n      var _ret = function () {\n        var segments = path.split('.');\n        return {\n          v: function v(obj) {\n            for (var i = 0; i < segments.length; i++) {\n              if (!obj) return;\n              obj = obj[segments[i]];\n            }\n            return obj;\n          }\n        };\n      }();\n\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n  }\n\n  /* global MutationObserver */\n  // can we use __proto__?\n  var hasProto = '__proto__' in {};\n\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\n  // detect devtools\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  // UA sniffing for working around browser-specific quirks\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);\n  var iosVersionMatch = UA && isIos && UA.match(/os ([\\d_]+)/);\n  var iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');\n\n  // MutationObserver is unreliable in iOS 9.3 UIWebView\n  // detecting it by checking presence of IndexedDB\n  // ref #3027\n  var hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;\n\n  /**\n   * Defer a task to execute it asynchronously. Ideally this\n   * should be executed as a microtask, so we leverage\n   * MutationObserver if it's available, and fallback to\n   * setTimeout(0).\n   *\n   * @param {Function} cb\n   * @param {Object} ctx\n   */\n  var nextTick = function () {\n    var callbacks = [];\n    var pending = false;\n    var timerFunc = void 0;\n    function nextTickHandler() {\n      pending = false;\n      var copies = callbacks.slice(0);\n      callbacks = [];\n      for (var i = 0; i < copies.length; i++) {\n        copies[i]();\n      }\n    }\n\n    /* istanbul ignore else */\n    if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {\n      (function () {\n        var counter = 1;\n        var observer = new MutationObserver(nextTickHandler);\n        var textNode = document.createTextNode(String(counter));\n        observer.observe(textNode, {\n          characterData: true\n        });\n        timerFunc = function timerFunc() {\n          counter = (counter + 1) % 2;\n          textNode.data = String(counter);\n        };\n      })();\n    } else {\n      // webpack attempts to inject a shim for setImmediate\n      // if it is used as a global, so we have to work around that to\n      // avoid bundling unnecessary code.\n      var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\n      timerFunc = context.setImmediate || setTimeout;\n    }\n    return function (cb, ctx) {\n      var func = ctx ? function () {\n        cb.call(ctx);\n      } : cb;\n      callbacks.push(func);\n      if (pending) return;\n      pending = true;\n      timerFunc(nextTickHandler, 0);\n    };\n  }();\n\n  var _Set = void 0;\n  /* istanbul ignore if */\n  if (typeof Set !== 'undefined' && /native code/.test(Set.toString())) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = function () {\n      function Set() {\n        this.set = Object.create(null);\n      }\n\n      Set.prototype.has = function has(key) {\n        return this.set[key] !== undefined;\n      };\n\n      Set.prototype.add = function add(key) {\n        this.set[key] = 1;\n      };\n\n      Set.prototype.clear = function clear() {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }();\n  }\n\n  var hasProxy = void 0;\n  var proxyHandlers = void 0;\n  var initProxy = void 0;\n  if (true) {\n    (function () {\n      var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require,__webpack_require__' // for Webpack/Browserify\n      );\n\n      hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);\n\n      proxyHandlers = {\n        has: function has(target, key) {\n          var has = key in target;\n          var isAllowedGlobal = allowedGlobals(key);\n          if (!has && !isAllowedGlobal) {\n            warn('Property or method \"' + key + '\" is not defined on the instance but ' + 'referenced during render. Make sure to declare reactive data ' + 'properties in the data option.', target);\n          }\n          return !isAllowedGlobal;\n        }\n      };\n\n      initProxy = function initProxy(vm) {\n        if (hasProxy) {\n          vm._renderProxy = new Proxy(vm, proxyHandlers);\n        } else {\n          vm._renderProxy = vm;\n        }\n      };\n    })();\n  }\n\n  var uid$2 = 0;\n\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n\n  var Dep = function () {\n    function Dep() {\n      this.id = uid$2++;\n      this.subs = [];\n    }\n\n    Dep.prototype.addSub = function addSub(sub) {\n      this.subs.push(sub);\n    };\n\n    Dep.prototype.removeSub = function removeSub(sub) {\n      remove(this.subs, sub);\n    };\n\n    Dep.prototype.depend = function depend() {\n      if (Dep.target) {\n        Dep.target.addDep(this);\n      }\n    };\n\n    Dep.prototype.notify = function notify() {\n      // stablize the subscriber list first\n      var subs = this.subs.slice();\n      for (var i = 0, l = subs.length; i < l; i++) {\n        subs[i].update();\n      }\n    };\n\n    return Dep;\n  }();\n\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget(_target) {\n    if (Dep.target) targetStack.push(Dep.target);\n    Dep.target = _target;\n  }\n\n  function popTarget() {\n    Dep.target = targetStack.pop();\n  }\n\n  var queue = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n\n  /**\n   * Reset the scheduler's state.\n   */\n  function resetSchedulerState() {\n    queue.length = 0;\n    has = {};\n    if (true) {\n      circular = {};\n    }\n    waiting = flushing = false;\n  }\n\n  /**\n   * Flush both queues and run the watchers.\n   */\n  function flushSchedulerQueue() {\n    flushing = true;\n\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n    queue.sort(function (a, b) {\n      return a.id - b.id;\n    });\n\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (index = 0; index < queue.length; index++) {\n      var watcher = queue[index];\n      var id = watcher.id;\n      has[id] = null;\n      watcher.run();\n      // in dev build, check and stop circular updates.\n      if (\"development\" !== 'production' && has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n        if (circular[id] > config._maxUpdateCount) {\n          warn('You may have an infinite update loop ' + (watcher.user ? 'in watcher with expression \"' + watcher.expression + '\"' : 'in a component render function.'), watcher.vm);\n          break;\n        }\n      }\n    }\n\n    // devtool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n\n    resetSchedulerState();\n  }\n\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n  function queueWatcher(watcher) {\n    var id = watcher.id;\n    if (has[id] == null) {\n      has[id] = true;\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n        while (i >= 0 && queue[i].id > watcher.id) {\n          i--;\n        }\n        queue.splice(Math.max(i, index) + 1, 0, watcher);\n      }\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n\n  var uid$1 = 0;\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n\n  var Watcher = function () {\n    function Watcher(vm, expOrFn, cb) {\n      var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n      this.vm = vm;\n      vm._watchers.push(this);\n      // options\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.expression = expOrFn.toString();\n      this.cb = cb;\n      this.id = ++uid$1; // uid for batching\n      this.active = true;\n      this.dirty = this.lazy; // for lazy watchers\n      this.deps = [];\n      this.newDeps = [];\n      this.depIds = new _Set();\n      this.newDepIds = new _Set();\n      // parse expression for getter\n      if (typeof expOrFn === 'function') {\n        this.getter = expOrFn;\n      } else {\n        this.getter = parsePath(expOrFn);\n        if (!this.getter) {\n          this.getter = function () {};\n          \"development\" !== 'production' && warn('Failed watching path: \"' + expOrFn + '\" ' + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n        }\n      }\n      this.value = this.lazy ? undefined : this.get();\n    }\n\n    /**\n     * Evaluate the getter, and re-collect dependencies.\n     */\n\n\n    Watcher.prototype.get = function get() {\n      pushTarget(this);\n      var value = this.getter.call(this.vm, this.vm);\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n      popTarget();\n      this.cleanupDeps();\n      return value;\n    };\n\n    /**\n     * Add a dependency to this directive.\n     */\n\n\n    Watcher.prototype.addDep = function addDep(dep) {\n      var id = dep.id;\n      if (!this.newDepIds.has(id)) {\n        this.newDepIds.add(id);\n        this.newDeps.push(dep);\n        if (!this.depIds.has(id)) {\n          dep.addSub(this);\n        }\n      }\n    };\n\n    /**\n     * Clean up for dependency collection.\n     */\n\n\n    Watcher.prototype.cleanupDeps = function cleanupDeps() {\n      var this$1 = this;\n\n      var i = this.deps.length;\n      while (i--) {\n        var dep = this$1.deps[i];\n        if (!this$1.newDepIds.has(dep.id)) {\n          dep.removeSub(this$1);\n        }\n      }\n      var tmp = this.depIds;\n      this.depIds = this.newDepIds;\n      this.newDepIds = tmp;\n      this.newDepIds.clear();\n      tmp = this.deps;\n      this.deps = this.newDeps;\n      this.newDeps = tmp;\n      this.newDeps.length = 0;\n    };\n\n    /**\n     * Subscriber interface.\n     * Will be called when a dependency changes.\n     */\n\n\n    Watcher.prototype.update = function update() {\n      /* istanbul ignore else */\n      if (this.lazy) {\n        this.dirty = true;\n      } else if (this.sync) {\n        this.run();\n      } else {\n        queueWatcher(this);\n      }\n    };\n\n    /**\n     * Scheduler job interface.\n     * Will be called by the scheduler.\n     */\n\n\n    Watcher.prototype.run = function run() {\n      if (this.active) {\n        var value = this.get();\n        if (value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        isObject(value) || this.deep) {\n          // set new value\n          var oldValue = this.value;\n          this.value = value;\n          if (this.user) {\n            try {\n              this.cb.call(this.vm, value, oldValue);\n            } catch (e) {\n              \"development\" !== 'production' && warn('Error in watcher \"' + this.expression + '\"', this.vm);\n              /* istanbul ignore else */\n              if (config.errorHandler) {\n                config.errorHandler.call(null, e, this.vm);\n              } else {\n                throw e;\n              }\n            }\n          } else {\n            this.cb.call(this.vm, value, oldValue);\n          }\n        }\n      }\n    };\n\n    /**\n     * Evaluate the value of the watcher.\n     * This only gets called for lazy watchers.\n     */\n\n\n    Watcher.prototype.evaluate = function evaluate() {\n      this.value = this.get();\n      this.dirty = false;\n    };\n\n    /**\n     * Depend on all deps collected by this watcher.\n     */\n\n\n    Watcher.prototype.depend = function depend() {\n      var this$1 = this;\n\n      var i = this.deps.length;\n      while (i--) {\n        this$1.deps[i].depend();\n      }\n    };\n\n    /**\n     * Remove self from all dependencies' subcriber list.\n     */\n\n\n    Watcher.prototype.teardown = function teardown() {\n      var this$1 = this;\n\n      if (this.active) {\n        // remove self from vm's watcher list\n        // this is a somewhat expensive operation so we skip it\n        // if the vm is being destroyed or is performing a v-for\n        // re-render (the watcher list is then filtered by v-for).\n        if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n          remove(this.vm._watchers, this);\n        }\n        var i = this.deps.length;\n        while (i--) {\n          this$1.deps[i].removeSub(this$1);\n        }\n        this.active = false;\n      }\n    };\n\n    return Watcher;\n  }();\n\n  var seenObjects = new _Set();\n  function traverse(val, seen) {\n    var i = void 0,\n        keys = void 0;\n    if (!seen) {\n      seen = seenObjects;\n      seen.clear();\n    }\n    var isA = Array.isArray(val);\n    var isO = isObject(val);\n    if ((isA || isO) && Object.isExtensible(val)) {\n      if (val.__ob__) {\n        var depId = val.__ob__.dep.id;\n        if (seen.has(depId)) {\n          return;\n        } else {\n          seen.add(depId);\n        }\n      }\n      if (isA) {\n        i = val.length;\n        while (i--) {\n          traverse(val[i], seen);\n        }\n      } else if (isO) {\n        keys = Object.keys(val);\n        i = keys.length;\n        while (i--) {\n          traverse(val[keys[i]], seen);\n        }\n      }\n    }\n  }\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto)\n\n  /**\n   * Intercept mutating methods and emit events\n   */\n  ;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      var arguments$1 = arguments;\n\n      // avoid leaking arguments:\n      // http://jsperf.com/closure-with-arguments\n      var i = arguments.length;\n      var args = new Array(i);\n      while (i--) {\n        args[i] = arguments$1[i];\n      }\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted = void 0;\n      switch (method) {\n        case 'push':\n          inserted = args;\n          break;\n        case 'unshift':\n          inserted = args;\n          break;\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n      if (inserted) ob.observeArray(inserted);\n      // notify change\n      ob.dep.notify();\n      return result;\n    });\n  });\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n  /**\n   * By default, when a reactive property is set, the new value is\n   * also converted to become reactive. However when passing down props,\n   * we don't want to force conversion because the value may be a nested value\n   * under a frozen data structure. Converting it would defeat the optimization.\n   */\n  var observerState = {\n    shouldConvert: true,\n    isSettingProps: false\n  };\n\n  /**\n   * Observer class that are attached to each observed\n   * object. Once attached, the observer converts target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatches updates.\n   */\n  var Observer = function () {\n    // number of vms that has this object as root $data\n\n    function Observer(value) {\n      this.value = value;\n      this.dep = new Dep();\n      this.vmCount = 0;\n      def(value, '__ob__', this);\n      if (Array.isArray(value)) {\n        var augment = hasProto ? protoAugment : copyAugment;\n        augment(value, arrayMethods, arrayKeys);\n        this.observeArray(value);\n      } else {\n        this.walk(value);\n      }\n    }\n\n    /**\n     * Walk through each property and convert them into\n     * getter/setters. This method should only be called when\n     * value type is Object.\n     */\n\n\n    Observer.prototype.walk = function walk(obj) {\n      var val = this.value;\n      for (var key in obj) {\n        defineReactive(val, key, obj[key]);\n      }\n    };\n\n    /**\n     * Observe a list of Array items.\n     */\n\n\n    Observer.prototype.observeArray = function observeArray(items) {\n      for (var i = 0, l = items.length; i < l; i++) {\n        observe(items[i]);\n      }\n    };\n\n    return Observer;\n  }();\n\n  // helpers\n\n  /**\n   * Augment an target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n  function protoAugment(target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n\n  /**\n   * Augment an target Object or Array by defining\n   * hidden properties.\n   *\n   * istanbul ignore next\n   */\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n  function observe(value) {\n    if (!isObject(value)) {\n      return;\n    }\n    var ob = void 0;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (observerState.shouldConvert && !config._isServer && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n    return ob;\n  }\n\n  /**\n   * Define a reactive property on an Object.\n   */\n  function defineReactive(obj, key, val, customSetter) {\n    var dep = new Dep();\n\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n      return;\n    }\n\n    // cater for pre-defined getter/setters\n    var getter = property && property.get;\n    var setter = property && property.set;\n\n    var childOb = observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n        if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n          }\n          if (Array.isArray(value)) {\n            for (var e, i = 0, l = value.length; i < l; i++) {\n              e = value[i];\n              e && e.__ob__ && e.__ob__.dep.depend();\n            }\n          }\n        }\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        if (newVal === value) {\n          return;\n        }\n        if (\"development\" !== 'production' && customSetter) {\n          customSetter();\n        }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        childOb = observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n  function set(obj, key, val) {\n    if (Array.isArray(obj)) {\n      obj.splice(key, 1, val);\n      return val;\n    }\n    if (hasOwn(obj, key)) {\n      obj[key] = val;\n      return;\n    }\n    var ob = obj.__ob__;\n    if (obj._isVue || ob && ob.vmCount) {\n      \"development\" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - delcare it upfront in the data option.');\n      return;\n    }\n    if (!ob) {\n      obj[key] = val;\n      return;\n    }\n    defineReactive(ob.value, key, val);\n    ob.dep.notify();\n    return val;\n  }\n\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n  function del(obj, key) {\n    var ob = obj.__ob__;\n    if (obj._isVue || ob && ob.vmCount) {\n      \"development\" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n      return;\n    }\n    if (!hasOwn(obj, key)) {\n      return;\n    }\n    delete obj[key];\n    if (!ob) {\n      return;\n    }\n    ob.dep.notify();\n  }\n\n  function initState(vm) {\n    vm._watchers = [];\n    initProps(vm);\n    initData(vm);\n    initComputed(vm);\n    initMethods(vm);\n    initWatch(vm);\n  }\n\n  function initProps(vm) {\n    var props = vm.$options.props;\n    var propsData = vm.$options.propsData;\n    if (props) {\n      var keys = vm.$options._propKeys = Object.keys(props);\n      var isRoot = !vm.$parent;\n      // root instance props should be converted\n      observerState.shouldConvert = isRoot;\n\n      var _loop = function _loop(i) {\n        var key = keys[i];\n        /* istanbul ignore else */\n        if (true) {\n          defineReactive(vm, key, validateProp(key, props, propsData, vm), function () {\n            if (vm.$parent && !observerState.isSettingProps) {\n              warn('Avoid mutating a prop directly since the value will be ' + 'overwritten whenever the parent component re-renders. ' + 'Instead, use a data or computed property based on the prop\\'s ' + ('value. Prop being mutated: \"' + key + '\"'), vm);\n            }\n          });\n        } else {}\n      };\n\n      for (var i = 0; i < keys.length; i++) {\n        _loop(i);\n      }\n      observerState.shouldConvert = true;\n    }\n  }\n\n  function initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function' ? data.call(vm) : data || {};\n    if (!isPlainObject(data)) {\n      data = {};\n      \"development\" !== 'production' && warn('data functions should return an object.', vm);\n    }\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var i = keys.length;\n    while (i--) {\n      if (props && hasOwn(props, keys[i])) {\n        \"development\" !== 'production' && warn('The data property \"' + keys[i] + '\" is already declared as a prop. ' + 'Use prop default value instead.', vm);\n      } else {\n        proxy(vm, keys[i]);\n      }\n    }\n    // observe data\n    observe(data);\n    data.__ob__ && data.__ob__.vmCount++;\n  }\n\n  var computedSharedDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function initComputed(vm) {\n    var computed = vm.$options.computed;\n    if (computed) {\n      for (var _key in computed) {\n        var userDef = computed[_key];\n        if (typeof userDef === 'function') {\n          computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n          computedSharedDefinition.set = noop;\n        } else {\n          computedSharedDefinition.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, vm) : bind(userDef.get, vm) : noop;\n          computedSharedDefinition.set = userDef.set ? bind(userDef.set, vm) : noop;\n        }\n        Object.defineProperty(vm, _key, computedSharedDefinition);\n      }\n    }\n  }\n\n  function makeComputedGetter(getter, owner) {\n    var watcher = new Watcher(owner, getter, noop, {\n      lazy: true\n    });\n    return function computedGetter() {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value;\n    };\n  }\n\n  function initMethods(vm) {\n    var methods = vm.$options.methods;\n    if (methods) {\n      for (var _key2 in methods) {\n        vm[_key2] = bind(methods[_key2], vm);\n      }\n    }\n  }\n\n  function initWatch(vm) {\n    var watch = vm.$options.watch;\n    if (watch) {\n      for (var _key3 in watch) {\n        var handler = watch[_key3];\n        if (Array.isArray(handler)) {\n          for (var i = 0; i < handler.length; i++) {\n            createWatcher(vm, _key3, handler[i]);\n          }\n        } else {\n          createWatcher(vm, _key3, handler);\n        }\n      }\n    }\n  }\n\n  function createWatcher(vm, key, handler) {\n    var options = void 0;\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n    vm.$watch(key, handler, options);\n  }\n\n  function stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n    dataDef.get = function () {\n      return this._data;\n    };\n    if (true) {\n      dataDef.set = function (newData) {\n        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n      if (options.immediate) {\n        cb.call(vm, watcher.value);\n      }\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n  }\n\n  function proxy(vm, key) {\n    if (!isReserved(key)) {\n      Object.defineProperty(vm, key, {\n        configurable: true,\n        enumerable: true,\n        get: function proxyGetter() {\n          return vm._data[key];\n        },\n        set: function proxySetter(val) {\n          vm._data[key] = val;\n        }\n      });\n    }\n  }\n\n  var VNode = // hoisted static node\n  // compoennt placeholder node\n  // rendered in this component's scope\n  function VNode(tag, data, children, text, elm, ns, context, componentOptions) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = ns;\n    this.context = context;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.child = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    // apply construct hook.\n    // this is applied during render, before patch happens.\n    // unlike other hooks, this is applied on both client and server.\n    var constructHook = data && data.hook && data.hook.construct;\n    if (constructHook) {\n      constructHook(this);\n    }\n  } // necessary for enter transition check\n  // contains raw HTML\n  // component instance\n  ;\n\n  var emptyVNode = function emptyVNode() {\n    var node = new VNode();\n    node.text = '';\n    node.isComment = true;\n    return node;\n  };\n\n  function normalizeChildren(children, ns) {\n    if (isPrimitive(children)) {\n      return [createTextVNode(children)];\n    }\n    if (Array.isArray(children)) {\n      var res = [];\n      for (var i = 0, l = children.length; i < l; i++) {\n        var c = children[i];\n        var last = res[res.length - 1];\n        //  nested\n        if (Array.isArray(c)) {\n          res.push.apply(res, normalizeChildren(c, ns));\n        } else if (isPrimitive(c)) {\n          if (last && last.text) {\n            last.text += String(c);\n          } else if (c !== '') {\n            // convert primitive to vnode\n            res.push(createTextVNode(c));\n          }\n        } else if (c instanceof VNode) {\n          if (c.text && last && last.text) {\n            last.text += c.text;\n          } else {\n            // inherit parent namespace\n            if (ns) {\n              applyNS(c, ns);\n            }\n            res.push(c);\n          }\n        }\n      }\n      return res;\n    }\n  }\n\n  function createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n  }\n\n  function applyNS(vnode, ns) {\n    if (vnode.tag && !vnode.ns) {\n      vnode.ns = ns;\n      if (vnode.children) {\n        for (var i = 0, l = vnode.children.length; i < l; i++) {\n          applyNS(vnode.children[i], ns);\n        }\n      }\n    }\n  }\n\n  function getFirstComponentChild(children) {\n    return children && children.filter(function (c) {\n      return c && c.componentOptions;\n    })[0];\n  }\n\n  function mergeVNodeHook(def, key, hook) {\n    var oldHook = def[key];\n    if (oldHook) {\n      def[key] = function () {\n        oldHook.apply(this, arguments);\n        hook.apply(this, arguments);\n      };\n    } else {\n      def[key] = hook;\n    }\n  }\n\n  function updateListeners(on, oldOn, add, remove) {\n    var name = void 0,\n        cur = void 0,\n        old = void 0,\n        fn = void 0,\n        event = void 0,\n        capture = void 0;\n    for (name in on) {\n      cur = on[name];\n      old = oldOn[name];\n      if (!cur) {\n        \"development\" !== 'production' && warn('Handler for event \"' + name + '\" is undefined.');\n      } else if (!old) {\n        capture = name.charAt(0) === '!';\n        event = capture ? name.slice(1) : name;\n        if (Array.isArray(cur)) {\n          add(event, cur.invoker = arrInvoker(cur), capture);\n        } else {\n          fn = cur;\n          cur = on[name] = {};\n          cur.fn = fn;\n          add(event, cur.invoker = fnInvoker(cur), capture);\n        }\n      } else if (Array.isArray(old)) {\n        old.length = cur.length;\n        for (var i = 0; i < old.length; i++) {\n          old[i] = cur[i];\n        }on[name] = old;\n      } else {\n        old.fn = cur;\n        on[name] = old;\n      }\n    }\n    for (name in oldOn) {\n      if (!on[name]) {\n        event = name.charAt(0) === '!' ? name.slice(1) : name;\n        remove(event, oldOn[name].invoker);\n      }\n    }\n  }\n\n  function arrInvoker(arr) {\n    return function (ev) {\n      var arguments$1 = arguments;\n\n      var single = arguments.length === 1;\n      for (var i = 0; i < arr.length; i++) {\n        single ? arr[i](ev) : arr[i].apply(null, arguments$1);\n      }\n    };\n  }\n\n  function fnInvoker(o) {\n    return function (ev) {\n      var single = arguments.length === 1;\n      single ? o.fn(ev) : o.fn.apply(null, arguments);\n    };\n  }\n\n  var activeInstance = null;\n\n  function initLifecycle(vm) {\n    var options = vm.$options;\n\n    // locate first non-abstract parent\n    var parent = options.parent;\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n\n    vm.$children = [];\n    vm.$refs = {};\n\n    vm._watcher = null;\n    vm._inactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin(Vue) {\n    Vue.prototype._mount = function (el, hydrating) {\n      var vm = this;\n      vm.$el = el;\n      if (!vm.$options.render) {\n        vm.$options.render = emptyVNode;\n        if (true) {\n          /* istanbul ignore if */\n          if (vm.$options.template) {\n            warn('You are using the runtime-only build of Vue where the template ' + 'option is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n          } else {\n            warn('Failed to mount component: template or render function not defined.', vm);\n          }\n        }\n      }\n      callHook(vm, 'beforeMount');\n      vm._watcher = new Watcher(vm, function () {\n        vm._update(vm._render(), hydrating);\n      }, noop);\n      hydrating = false;\n      // root instance, call mounted on self\n      // mounted is called for child components in its inserted hook\n      if (vm.$root === vm) {\n        vm._isMounted = true;\n        callHook(vm, 'mounted');\n      }\n      return vm;\n    };\n\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      if (vm._isMounted) {\n        callHook(vm, 'beforeUpdate');\n      }\n      var prevEl = vm.$el;\n      var prevActiveInstance = activeInstance;\n      activeInstance = vm;\n      var prevVnode = vm._vnode;\n      vm._vnode = vnode;\n      if (!prevVnode) {\n        // Vue.prototype.__patch__ is injected in entry points\n        // based on the rendering backend used.\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating);\n      } else {\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n      activeInstance = prevActiveInstance;\n      // update __vue__ reference\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      }\n      // if parent is an HOC, update its $el as well\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      }\n      if (vm._isMounted) {\n        callHook(vm, 'updated');\n      }\n    };\n\n    Vue.prototype._updateFromParent = function (propsData, listeners, parentVnode, renderChildren) {\n      var vm = this;\n      var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n      vm.$options._parentVnode = parentVnode;\n      vm.$options._renderChildren = renderChildren;\n      // update props\n      if (propsData && vm.$options.props) {\n        observerState.shouldConvert = false;\n        if (true) {\n          observerState.isSettingProps = true;\n        }\n        var propKeys = vm.$options._propKeys || [];\n        for (var i = 0; i < propKeys.length; i++) {\n          var key = propKeys[i];\n          vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n        }\n        observerState.shouldConvert = true;\n        if (true) {\n          observerState.isSettingProps = false;\n        }\n      }\n      // update listeners\n      if (listeners) {\n        var oldListeners = vm.$options._parentListeners;\n        vm.$options._parentListeners = listeners;\n        vm._updateListeners(listeners, oldListeners);\n      }\n      // resolve slots + force update if has children\n      if (hasChildren) {\n        vm.$slots = resolveSlots(renderChildren);\n        vm.$forceUpdate();\n      }\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n      if (vm._isBeingDestroyed) {\n        return;\n      }\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true;\n      // remove self from parent\n      var parent = vm.$parent;\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      }\n      // teardown watchers\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n      var i = vm._watchers.length;\n      while (i--) {\n        vm._watchers[i].teardown();\n      }\n      // remove reference from data ob\n      // frozen object may not have observer.\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      }\n      // call the last hook...\n      vm._isDestroyed = true;\n      callHook(vm, 'destroyed');\n      // turn off all instance listeners.\n      vm.$off();\n      // remove __vue__ reference\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      }\n    };\n  }\n\n  function callHook(vm, hook) {\n    var handlers = vm.$options[hook];\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        handlers[i].call(vm);\n      }\n    }\n    vm.$emit('hook:' + hook);\n  }\n\n  var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy };\n  var hooksToMerge = Object.keys(hooks);\n\n  function createComponent(Ctor, data, context, children, tag) {\n    if (!Ctor) {\n      return;\n    }\n\n    if (isObject(Ctor)) {\n      Ctor = Vue.extend(Ctor);\n    }\n\n    if (typeof Ctor !== 'function') {\n      if (true) {\n        warn('Invalid Component definition: ' + Ctor, context);\n      }\n      return;\n    }\n\n    // async component\n    if (!Ctor.cid) {\n      if (Ctor.resolved) {\n        Ctor = Ctor.resolved;\n      } else {\n        Ctor = resolveAsyncComponent(Ctor, function () {\n          // it's ok to queue this on every render because\n          // $forceUpdate is buffered by the scheduler.\n          context.$forceUpdate();\n        });\n        if (!Ctor) {\n          // return nothing if this is indeed an async component\n          // wait for the callback to trigger parent update.\n          return;\n        }\n      }\n    }\n\n    data = data || {};\n\n    // extract props\n    var propsData = extractProps(data, Ctor);\n\n    // functional component\n    if (Ctor.options.functional) {\n      var _ret = function () {\n        var props = {};\n        var propOptions = Ctor.options.props;\n        if (propOptions) {\n          Object.keys(propOptions).forEach(function (key) {\n            props[key] = validateProp(key, propOptions, propsData);\n          });\n        }\n        return {\n          v: Ctor.options.render.call(null, context.$createElement, {\n            props: props,\n            data: data,\n            parent: context,\n            children: normalizeChildren(children),\n            slots: function slots() {\n              return resolveSlots(children);\n            }\n          })\n        };\n      }();\n\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n\n    // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n    var listeners = data.on;\n    // replace with listeners with .native modifier\n    data.on = data.nativeOn;\n\n    if (Ctor.options.abstract) {\n      // abstract components do not keep anything\n      // other than props & listeners\n      data = {};\n    }\n\n    // merge component management hooks onto the placeholder node\n    mergeHooks(data);\n\n    // return a placeholder vnode\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode('vue-component-' + Ctor.cid + (name ? '-' + name : ''), data, undefined, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });\n    return vnode;\n  }\n\n  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n  ) {\n    var vnodeComponentOptions = vnode.componentOptions;\n    var options = {\n      _isComponent: true,\n      parent: parent,\n      propsData: vnodeComponentOptions.propsData,\n      _componentTag: vnodeComponentOptions.tag,\n      _parentVnode: vnode,\n      _parentListeners: vnodeComponentOptions.listeners,\n      _renderChildren: vnodeComponentOptions.children\n    };\n    // check inline-template render functions\n    var inlineTemplate = vnode.data.inlineTemplate;\n    if (inlineTemplate) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnodeComponentOptions.Ctor(options);\n  }\n\n  function init(vnode, hydrating) {\n    if (!vnode.child || vnode.child._isDestroyed) {\n      var child = vnode.child = createComponentInstanceForVnode(vnode, activeInstance);\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  }\n\n  function prepatch(oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.child = oldVnode.child;\n    child._updateFromParent(options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n    );\n  }\n\n  function insert(vnode) {\n    if (!vnode.child._isMounted) {\n      vnode.child._isMounted = true;\n      callHook(vnode.child, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      vnode.child._inactive = false;\n      callHook(vnode.child, 'activated');\n    }\n  }\n\n  function destroy(vnode) {\n    if (!vnode.child._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        vnode.child.$destroy();\n      } else {\n        vnode.child._inactive = true;\n        callHook(vnode.child, 'deactivated');\n      }\n    }\n  }\n\n  function resolveAsyncComponent(factory, cb) {\n    if (factory.requested) {\n      // pool callbacks\n      factory.pendingCallbacks.push(cb);\n    } else {\n      var _ret2 = function () {\n        factory.requested = true;\n        var cbs = factory.pendingCallbacks = [cb];\n        var sync = true;\n        factory(\n        // resolve\n        function (res) {\n          if (isObject(res)) {\n            res = Vue.extend(res);\n          }\n          // cache resolved\n          factory.resolved = res;\n          // invoke callbacks only if this is not a synchronous resolve\n          // (async resolves are shimmed as synchronous during SSR)\n          if (!sync) {\n            for (var i = 0, l = cbs.length; i < l; i++) {\n              cbs[i](res);\n            }\n          }\n        },\n        // reject\n        function (reason) {\n          \"development\" !== 'production' && warn('Failed to resolve async component: ' + factory + (reason ? '\\nReason: ' + reason : ''));\n        });\n        sync = false;\n        // return in case resolved synchronously\n        return {\n          v: factory.resolved\n        };\n      }();\n\n      if (typeof _ret2 === \"object\") return _ret2.v;\n    }\n  }\n\n  function extractProps(data, Ctor) {\n    // we are only extrating raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n    if (!propOptions) {\n      return;\n    }\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n    var domProps = data.domProps;\n\n    if (attrs || props || domProps) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey) || checkProp(res, domProps, key, altKey);\n      }\n    }\n    return res;\n  }\n\n  function checkProp(res, hash, key, altKey, preserve) {\n    if (hash) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n        if (!preserve) {\n          delete hash[key];\n        }\n        return true;\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n        if (!preserve) {\n          delete hash[altKey];\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function mergeHooks(data) {\n    if (!data.hook) {\n      data.hook = {};\n    }\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var fromParent = data.hook[key];\n      var ours = hooks[key];\n      data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n    }\n  }\n\n  function mergeHook$1(a, b) {\n    // since all hooks have at most two args, use fixed args\n    // to avoid having to use fn.apply().\n    return function (_, __) {\n      a(_, __);\n      b(_, __);\n    };\n  }\n\n  // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n  function createElement(tag, data, children) {\n    if (data && (Array.isArray(data) || typeof data !== 'object')) {\n      children = data;\n      data = undefined;\n    }\n    // make sure to use real instance instead of proxy as context\n    return _createElement(this._self, tag, data, children);\n  }\n\n  function _createElement(context, tag, data, children) {\n    if (data && data.__ob__) {\n      \"development\" !== 'production' && warn('Avoid using observed data object as vnode data: ' + JSON.stringify(data) + '\\n' + 'Always create fresh vnode data objects in each render!', context);\n      return;\n    }\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return emptyVNode();\n    }\n    if (typeof tag === 'string') {\n      var Ctor = void 0;\n      var ns = config.getTagNamespace(tag);\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        return new VNode(tag, data, normalizeChildren(children, ns), undefined, undefined, ns, context);\n      } else if (Ctor = resolveAsset(context.$options, 'components', tag)) {\n        // component\n        return createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        return new VNode(tag, data, normalizeChildren(children, ns), undefined, undefined, ns, context);\n      }\n    } else {\n      // direct component options / constructor\n      return createComponent(tag, data, context, children);\n    }\n  }\n\n  function initRender(vm) {\n    vm.$vnode = null; // the placeholder node in parent tree\n    vm._vnode = null; // the root of the child tree\n    vm._staticTrees = null;\n    vm.$slots = resolveSlots(vm.$options._renderChildren);\n    // bind the public createElement fn to this instance\n    // so that we get proper render context inside it.\n    vm.$createElement = bind(createElement, vm);\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  }\n\n  function renderMixin(Vue) {\n    Vue.prototype.$nextTick = function (fn) {\n      nextTick(fn, this);\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var _vm$$options = vm.$options;\n      var render = _vm$$options.render;\n      var staticRenderFns = _vm$$options.staticRenderFns;\n      var _parentVnode = _vm$$options._parentVnode;\n\n\n      if (staticRenderFns && !vm._staticTrees) {\n        vm._staticTrees = [];\n      }\n      // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n      vm.$vnode = _parentVnode;\n      // render self\n      var vnode = void 0;\n      try {\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        if (true) {\n          warn('Error when rendering ' + formatComponentName(vm) + ':');\n        }\n        /* istanbul ignore else */\n        if (config.errorHandler) {\n          config.errorHandler.call(null, e, vm);\n        } else {\n          if (config._isServer) {\n            throw e;\n          } else {\n            setTimeout(function () {\n              throw e;\n            }, 0);\n          }\n        }\n        // return previous vnode to prevent render error causing blank component\n        vnode = vm._vnode;\n      }\n      // return empty vnode in case the render function errored out\n      if (!(vnode instanceof VNode)) {\n        if (\"development\" !== 'production' && Array.isArray(vnode)) {\n          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n        }\n        vnode = emptyVNode();\n      }\n      // set parent\n      vnode.parent = _parentVnode;\n      return vnode;\n    };\n\n    // shorthands used in render functions\n    Vue.prototype._h = createElement;\n    // toString for mustaches\n    Vue.prototype._s = _toString;\n    // number conversion\n    Vue.prototype._n = toNumber;\n\n    // render static tree by index\n    Vue.prototype._m = function renderStatic(index, isInFor) {\n      var tree = this._staticTrees[index];\n      // if has already-rendered static tree and not inside v-for,\n      // we can reuse the same tree by indentity.\n      if (tree && !isInFor) {\n        return tree;\n      }\n      // otherwise, render a fresh tree.\n      tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n      if (Array.isArray(tree)) {\n        for (var i = 0; i < tree.length; i++) {\n          tree[i].isStatic = true;\n          tree[i].key = '__static__' + index + '_' + i;\n        }\n      } else {\n        tree.isStatic = true;\n        tree.key = '__static__' + index;\n      }\n      return tree;\n    };\n\n    // filter resolution helper\n    var identity = function identity(_) {\n      return _;\n    };\n    Vue.prototype._f = function resolveFilter(id) {\n      return resolveAsset(this.$options, 'filters', id, true) || identity;\n    };\n\n    // render v-for\n    Vue.prototype._l = function renderList(val, render) {\n      var ret = void 0,\n          i = void 0,\n          l = void 0,\n          keys = void 0,\n          key = void 0;\n      if (Array.isArray(val)) {\n        ret = new Array(val.length);\n        for (i = 0, l = val.length; i < l; i++) {\n          ret[i] = render(val[i], i);\n        }\n      } else if (typeof val === 'number') {\n        ret = new Array(val);\n        for (i = 0; i < val; i++) {\n          ret[i] = render(i + 1, i);\n        }\n      } else if (isObject(val)) {\n        keys = Object.keys(val);\n        ret = new Array(keys.length);\n        for (i = 0, l = keys.length; i < l; i++) {\n          key = keys[i];\n          ret[i] = render(val[key], key, i);\n        }\n      }\n      return ret;\n    };\n\n    // apply v-bind object\n    Vue.prototype._b = function bindProps(vnode, value, asProp) {\n      if (value) {\n        if (!isObject(value)) {\n          \"development\" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);\n        } else {\n          if (Array.isArray(value)) {\n            value = toObject(value);\n          }\n          var data = vnode.data;\n          for (var _key in value) {\n            if (_key === 'class' || _key === 'style') {\n              data[_key] = value[_key];\n            } else {\n              var hash = asProp || config.mustUseProp(_key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n              hash[_key] = value[_key];\n            }\n          }\n        }\n      }\n    };\n\n    // expose v-on keyCodes\n    Vue.prototype._k = function getKeyCodes(key) {\n      return config.keyCodes[key];\n    };\n  }\n\n  function resolveSlots(renderChildren) {\n    var slots = {};\n    if (!renderChildren) {\n      return slots;\n    }\n    var children = normalizeChildren(renderChildren) || [];\n    var defaultSlot = [];\n    var name = void 0,\n        child = void 0;\n    for (var i = 0, l = children.length; i < l; i++) {\n      child = children[i];\n      if (child.data && (name = child.data.slot)) {\n        delete child.data.slot;\n        var slot = slots[name] || (slots[name] = []);\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        defaultSlot.push(child);\n      }\n    }\n    // ignore single whitespace\n    if (defaultSlot.length && !(defaultSlot.length === 1 && defaultSlot[0].text === ' ')) {\n      slots.default = defaultSlot;\n    }\n    return slots;\n  }\n\n  function initEvents(vm) {\n    vm._events = Object.create(null);\n    // init parent attached events\n    var listeners = vm.$options._parentListeners;\n    var on = bind(vm.$on, vm);\n    var off = bind(vm.$off, vm);\n    vm._updateListeners = function (listeners, oldListeners) {\n      updateListeners(listeners, oldListeners || {}, on, off);\n    };\n    if (listeners) {\n      vm._updateListeners(listeners);\n    }\n  }\n\n  function eventsMixin(Vue) {\n    Vue.prototype.$on = function (event, fn) {\n      var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n      return vm;\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n      function on() {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm;\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var vm = this;\n      // all\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm;\n      }\n      // specific event\n      var cbs = vm._events[event];\n      if (!cbs) {\n        return vm;\n      }\n      if (arguments.length === 1) {\n        vm._events[event] = null;\n        return vm;\n      }\n      // specific handler\n      var cb = void 0;\n      var i = cbs.length;\n      while (i--) {\n        cb = cbs[i];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break;\n        }\n      }\n      return vm;\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      var cbs = vm._events[event];\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i].apply(vm, args);\n        }\n      }\n      return vm;\n    };\n  }\n\n  var uid = 0;\n\n  function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this;\n      // a uid\n      vm._uid = uid++;\n      // a flag to avoid this being observed\n      vm._isVue = true;\n      // merge options\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(resolveConstructorOptions(vm), options || {}, vm);\n      }\n      /* istanbul ignore else */\n      if (true) {\n        initProxy(vm);\n      } else {}\n      // expose real self\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      callHook(vm, 'beforeCreate');\n      initState(vm);\n      callHook(vm, 'created');\n      initRender(vm);\n    };\n\n    function initInternalComponent(vm, options) {\n      var opts = vm.$options = Object.create(resolveConstructorOptions(vm));\n      // doing this because it's faster than dynamic enumeration.\n      opts.parent = options.parent;\n      opts.propsData = options.propsData;\n      opts._parentVnode = options._parentVnode;\n      opts._parentListeners = options._parentListeners;\n      opts._renderChildren = options._renderChildren;\n      opts._componentTag = options._componentTag;\n      if (options.render) {\n        opts.render = options.render;\n        opts.staticRenderFns = options.staticRenderFns;\n      }\n    }\n\n    function resolveConstructorOptions(vm) {\n      var Ctor = vm.constructor;\n      var options = Ctor.options;\n      if (Ctor.super) {\n        var superOptions = Ctor.super.options;\n        var cachedSuperOptions = Ctor.superOptions;\n        if (superOptions !== cachedSuperOptions) {\n          // super option changed\n          Ctor.superOptions = superOptions;\n          options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n          if (options.name) {\n            options.components[options.name] = Ctor;\n          }\n        }\n      }\n      return options;\n    }\n  }\n\n  function Vue(options) {\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n\n  var warn = void 0;\n  var formatComponentName = void 0;\n\n  if (true) {\n    (function () {\n      var hasConsole = typeof console !== 'undefined';\n\n      warn = function warn(msg, vm) {\n        if (hasConsole && !config.silent) {\n          console.error('[Vue warn]: ' + msg + ' ' + (vm ? formatLocation(formatComponentName(vm)) : ''));\n        }\n      };\n\n      formatComponentName = function formatComponentName(vm) {\n        if (vm.$root === vm) {\n          return 'root instance';\n        }\n        var name = vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;\n        return name ? 'component <' + name + '>' : 'anonymous component';\n      };\n\n      var formatLocation = function formatLocation(str) {\n        if (str === 'anonymous component') {\n          str += ' - use the \"name\" option for better debugging messages.)';\n        }\n        return '(found in ' + str + ')';\n      };\n    })();\n  }\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n  var strats = config.optionMergeStrategies;\n\n  /**\n   * Options with restrictions\n   */\n  if (true) {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn('option \"' + key + '\" can only be used during instance ' + 'creation with the `new` keyword.');\n      }\n      return defaultStrat(parent, child);\n    };\n\n    strats.name = function (parent, child, vm) {\n      if (vm) {\n        warn('options \"name\" can only be used as a component definition option, ' + 'not during instance creation.');\n      }\n      return defaultStrat(parent, child);\n    };\n  }\n\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n  function mergeData(to, from) {\n    var key = void 0,\n        toVal = void 0,\n        fromVal = void 0;\n    for (key in from) {\n      toVal = to[key];\n      fromVal = from[key];\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (isObject(toVal) && isObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n    return to;\n  }\n\n  /**\n   * Data\n   */\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n      if (typeof childVal !== 'function') {\n        \"development\" !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n        return parentVal;\n      }\n      if (!parentVal) {\n        return childVal;\n      }\n      // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n      return function mergedDataFn() {\n        return mergeData(childVal.call(this), parentVal.call(this));\n      };\n    } else if (parentVal || childVal) {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  };\n\n  /**\n   * Hooks and param attributes are merged as arrays.\n   */\n  function mergeHook(parentVal, childVal) {\n    return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n  }\n\n  config._lifecycleHooks.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n  function mergeAssets(parentVal, childVal) {\n    var res = Object.create(parentVal || null);\n    return childVal ? extend(res, childVal) : res;\n  }\n\n  config._assetTypes.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n  strats.watch = function (parentVal, childVal) {\n    /* istanbul ignore if */\n    if (!childVal) return parentVal;\n    if (!parentVal) return childVal;\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key in childVal) {\n      var parent = ret[key];\n      var child = childVal[key];\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n      ret[key] = parent ? parent.concat(child) : [child];\n    }\n    return ret;\n  };\n\n  /**\n   * Other object hashes.\n   */\n  strats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n    if (!childVal) return parentVal;\n    if (!parentVal) return childVal;\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n    extend(ret, childVal);\n    return ret;\n  };\n\n  /**\n   * Default strategy.\n   */\n  var defaultStrat = function defaultStrat(parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n\n  /**\n   * Make sure component options get converted to actual\n   * constructors.\n   */\n  function normalizeComponents(options) {\n    if (options.components) {\n      var components = options.components;\n      var def = void 0;\n      for (var key in components) {\n        var lower = key.toLowerCase();\n        if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n          \"development\" !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n          continue;\n        }\n        def = components[key];\n        if (isPlainObject(def)) {\n          components[key] = Vue.extend(def);\n        }\n      }\n    }\n  }\n\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n  function normalizeProps(options) {\n    var props = options.props;\n    if (!props) return;\n    var res = {};\n    var i = void 0,\n        val = void 0,\n        name = void 0;\n    if (Array.isArray(props)) {\n      i = props.length;\n      while (i--) {\n        val = props[i];\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = { type: null };\n        } else if (true) {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val) ? val : { type: val };\n      }\n    }\n    options.props = res;\n  }\n\n  /**\n   * Normalize raw function directives into object format.\n   */\n  function normalizeDirectives(options) {\n    var dirs = options.directives;\n    if (dirs) {\n      for (var key in dirs) {\n        var def = dirs[key];\n        if (typeof def === 'function') {\n          dirs[key] = { bind: def, update: def };\n        }\n      }\n    }\n  }\n\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n  function mergeOptions(parent, child, vm) {\n    normalizeComponents(child);\n    normalizeProps(child);\n    normalizeDirectives(child);\n    var extendsFrom = child.extends;\n    if (extendsFrom) {\n      parent = typeof extendsFrom === 'function' ? mergeOptions(parent, extendsFrom.options, vm) : mergeOptions(parent, extendsFrom, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        var mixin = child.mixins[i];\n        if (mixin.prototype instanceof Vue) {\n          mixin = mixin.options;\n        }\n        parent = mergeOptions(parent, mixin, vm);\n      }\n    }\n    var options = {};\n    var key = void 0;\n    for (key in parent) {\n      mergeField(key);\n    }\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options;\n  }\n\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n  function resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return;\n    }\n    var assets = options[type];\n    var res = assets[id] ||\n    // camelCase ID\n    assets[camelize(id)] ||\n    // Pascal Case ID\n    assets[capitalize(camelize(id))];\n    if (\"development\" !== 'production' && warnMissing && !res) {\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n    }\n    return res;\n  }\n\n  function validateProp(key, propOptions, propsData, vm) {\n    /* istanbul ignore if */\n    if (!propsData) return;\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key];\n    // handle boolean props\n    if (getType(prop.type) === 'Boolean') {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        value = true;\n      }\n    }\n    // check default value\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key);\n      // since the default value is a fresh copy,\n      // make sure to observe it.\n      var prevShouldConvert = observerState.shouldConvert;\n      observerState.shouldConvert = true;\n      observe(value);\n      observerState.shouldConvert = prevShouldConvert;\n    }\n    if (true) {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n  }\n\n  /**\n   * Get the default value of a prop.\n   */\n  function getPropDefaultValue(vm, prop, name) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined;\n    }\n    var def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (isObject(def)) {\n      \"development\" !== 'production' && warn('Invalid default value for prop \"' + name + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n    }\n    // call factory function for non-Function types\n    return typeof def === 'function' && prop.type !== Function ? def.call(vm) : def;\n  }\n\n  /**\n   * Assert whether a prop is valid.\n   */\n  function assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n      warn('Missing required prop: \"' + name + '\"', vm);\n      return;\n    }\n    if (value == null && !prop.required) {\n      return;\n    }\n    var type = prop.type;\n    var valid = !type;\n    var expectedTypes = [];\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType);\n        valid = assertedType.valid;\n      }\n    }\n    if (!valid) {\n      warn('Invalid prop: type check failed for prop \"' + name + '\".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);\n      return;\n    }\n    var validator = prop.validator;\n    if (validator) {\n      if (!validator(value)) {\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n      }\n    }\n  }\n\n  /**\n   * Assert the type of a value\n   */\n  function assertType(value, type) {\n    var valid = void 0;\n    var expectedType = getType(type);\n    if (expectedType === 'String') {\n      valid = typeof value === (expectedType = 'string');\n    } else if (expectedType === 'Number') {\n      valid = typeof value === (expectedType = 'number');\n    } else if (expectedType === 'Boolean') {\n      valid = typeof value === (expectedType = 'boolean');\n    } else if (expectedType === 'Function') {\n      valid = typeof value === (expectedType = 'function');\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n    return {\n      valid: valid,\n      expectedType: expectedType\n    };\n  }\n\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n  function getType(fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match && match[1];\n  }\n\n\n\n  var util = Object.freeze({\n  \tdefineReactive: defineReactive,\n  \t_toString: _toString,\n  \ttoNumber: toNumber,\n  \tmakeMap: makeMap,\n  \tisBuiltInTag: isBuiltInTag,\n  \tremove: remove,\n  \thasOwn: hasOwn,\n  \tisPrimitive: isPrimitive,\n  \tcached: cached,\n  \tcamelize: camelize,\n  \tcapitalize: capitalize,\n  \thyphenate: hyphenate,\n  \tbind: bind,\n  \ttoArray: toArray,\n  \textend: extend,\n  \tisObject: isObject,\n  \tisPlainObject: isPlainObject,\n  \ttoObject: toObject,\n  \tnoop: noop,\n  \tno: no,\n  \tgenStaticKeys: genStaticKeys,\n  \tisReserved: isReserved,\n  \tdef: def,\n  \tparsePath: parsePath,\n  \thasProto: hasProto,\n  \tinBrowser: inBrowser,\n  \tdevtools: devtools,\n  \tUA: UA,\n  \tnextTick: nextTick,\n  \tget _Set () { return _Set; },\n  \tmergeOptions: mergeOptions,\n  \tresolveAsset: resolveAsset,\n  \tget warn () { return warn; },\n  \tget formatComponentName () { return formatComponentName; },\n  \tvalidateProp: validateProp\n  });\n\n  function initUse(Vue) {\n    Vue.use = function (plugin) {\n      /* istanbul ignore if */\n      if (plugin.installed) {\n        return;\n      }\n      // additional parameters\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else {\n        plugin.apply(null, args);\n      }\n      plugin.installed = true;\n      return this;\n    };\n  }\n\n  function initMixin$1(Vue) {\n    Vue.mixin = function (mixin) {\n      Vue.options = mergeOptions(Vue.options, mixin);\n    };\n  }\n\n  function initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n\n    /**\n     * Class inheritance\n     */\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var isFirstExtend = Super.cid === 0;\n      if (isFirstExtend && extendOptions._Ctor) {\n        return extendOptions._Ctor;\n      }\n      var name = extendOptions.name || Super.options.name;\n      if (true) {\n        if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n          warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');\n          name = null;\n        }\n      }\n      var Sub = function VueComponent(options) {\n        this._init(options);\n      };\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super;\n      // allow further extension\n      Sub.extend = Super.extend;\n      // create asset registers, so extended classes\n      // can have their private assets too.\n      config._assetTypes.forEach(function (type) {\n        Sub[type] = Super[type];\n      });\n      // enable recursive self-lookup\n      if (name) {\n        Sub.options.components[name] = Sub;\n      }\n      // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      // cache constructor\n      if (isFirstExtend) {\n        extendOptions._Ctor = Sub;\n      }\n      return Sub;\n    };\n  }\n\n  function initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    config._assetTypes.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          if (true) {\n            if (type === 'component' && config.isReservedTag(id)) {\n              warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n            }\n          }\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = Vue.extend(definition);\n          }\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = { bind: definition, update: definition };\n          }\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n  }\n\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n    created: function created() {\n      this.cache = Object.create(null);\n    },\n    render: function render() {\n      var vnode = getFirstComponentChild(this.$slots.default);\n      if (vnode && vnode.componentOptions) {\n        var opts = vnode.componentOptions;\n        var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? opts.Ctor.cid + '::' + opts.tag : vnode.key;\n        if (this.cache[key]) {\n          vnode.child = this.cache[key].child;\n        } else {\n          this.cache[key] = vnode;\n        }\n        vnode.data.keepAlive = true;\n      }\n      return vnode;\n    },\n    destroyed: function destroyed() {\n      var this$1 = this;\n\n      for (var key in this.cache) {\n        var vnode = this$1.cache[key];\n        callHook(vnode.child, 'deactivated');\n        vnode.child.$destroy();\n      }\n    }\n  };\n\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n\n  function initGlobalAPI(Vue) {\n    // config\n    var configDef = {};\n    configDef.get = function () {\n      return config;\n    };\n    if (true) {\n      configDef.set = function () {\n        warn('Do not replace the Vue.config object, set individual fields instead.');\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef);\n    Vue.util = util;\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n\n    Vue.options = Object.create(null);\n    config._assetTypes.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    });\n\n    extend(Vue.options.components, builtInComponents);\n\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: function get() {\n      return config._isServer;\n    }\n  });\n\n  Vue.version = '2.0.0-rc.2';\n\n  // attributes that should be using props for binding\n  var mustUseProp = makeMap('value,selected,checked,muted');\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n\n  var isAttr = makeMap('accept,accept-charset,accesskey,action,align,alt,async,autocomplete,' + 'autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,' + 'checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,' + 'name,contenteditable,contextmenu,controls,coords,data,datetime,default,' + 'defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,' + 'form,formaction,headers,<th>,height,hidden,high,href,hreflang,http-equiv,' + 'icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,' + 'manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,' + 'muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,' + 'preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,' + 'scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,' + 'spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,' + 'target,title,type,usemap,value,width,wrap');\n\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function isXlink(name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n  };\n\n  var getXlinkProp = function getXlinkProp(name) {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n  };\n\n  var isFalsyAttrValue = function isFalsyAttrValue(val) {\n    return val == null || val === false;\n  };\n\n  function genClassForVnode(vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n    while (childNode.child) {\n      childNode = childNode.child._vnode;\n      if (childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n    while (parentNode = parentNode.parent) {\n      if (parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n    return genClassFromData(data);\n  }\n\n  function mergeClassData(child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: child.class ? [child.class, parent.class] : parent.class\n    };\n  }\n\n  function genClassFromData(data) {\n    var dynamicClass = data.class;\n    var staticClass = data.staticClass;\n    if (staticClass || dynamicClass) {\n      return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n    return '';\n  }\n\n  function concat(a, b) {\n    return a ? b ? a + ' ' + b : a : b || '';\n  }\n\n  function stringifyClass(value) {\n    var res = '';\n    if (!value) {\n      return res;\n    }\n    if (typeof value === 'string') {\n      return value;\n    }\n    if (Array.isArray(value)) {\n      var stringified = void 0;\n      for (var i = 0, l = value.length; i < l; i++) {\n        if (value[i]) {\n          if (stringified = stringifyClass(value[i])) {\n            res += stringified + ' ';\n          }\n        }\n      }\n      return res.slice(0, -1);\n    }\n    if (isObject(value)) {\n      for (var key in value) {\n        if (value[key]) res += key + ' ';\n      }\n      return res.slice(0, -1);\n    }\n    /* istanbul ignore next */\n    return res;\n  }\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n\n  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');\n\n  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr', true);\n\n  // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source', true);\n\n  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track', true);\n\n  // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,' + 'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n  var isPreTag = function isPreTag(tag) {\n    return tag === 'pre';\n  };\n\n  var isReservedTag = function isReservedTag(tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n  };\n\n  function getTagNamespace(tag) {\n    if (isSVG(tag)) {\n      return 'svg';\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n      return 'math';\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n  function isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true;\n    }\n    if (isReservedTag(tag)) {\n      return false;\n    }\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag];\n    }\n    var el = document.createElement(tag);\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n    }\n  }\n\n  var UA$1 = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA$1 && /msie|trident/.test(UA$1);\n  var isIE9 = UA$1 && UA$1.indexOf('msie 9.0') > 0;\n  var isAndroid = UA$1 && UA$1.indexOf('android') > 0;\n\n  // According to\n  // https://w3c.github.io/DOM-Parsing/#dfn-serializing-an-attribute-value\n  // when serializing innerHTML, <, >, \", & should be encoded as entities.\n  // However, only some browsers, e.g. PhantomJS, encodes < and >.\n  // this causes problems with the in-browser parser.\n  var shouldDecodeTags = inBrowser ? function () {\n    var div = document.createElement('div');\n    div.innerHTML = '<div a=\">\">';\n    return div.innerHTML.indexOf('&gt;') > 0;\n  }() : false;\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n  function query(el) {\n    if (typeof el === 'string') {\n      var selector = el;\n      el = document.querySelector(el);\n      if (!el) {\n        \"development\" !== 'production' && warn('Cannot find element: ' + selector);\n        return document.createElement('div');\n      }\n    }\n    return el;\n  }\n\n  function createElement$1(tagName) {\n    return document.createElement(tagName);\n  }\n\n  function createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n  }\n\n  function createTextNode(text) {\n    return document.createTextNode(text);\n  }\n\n  function createComment(text) {\n    return document.createComment(text);\n  }\n\n  function insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild(node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild(node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode(node) {\n    return node.parentNode;\n  }\n\n  function nextSibling(node) {\n    return node.nextSibling;\n  }\n\n  function tagName(node) {\n    return node.tagName;\n  }\n\n  function setTextContent(node, text) {\n    node.textContent = text;\n  }\n\n  function childNodes(node) {\n    return node.childNodes;\n  }\n\n  function setAttribute(node, key, val) {\n    node.setAttribute(key, val);\n  }\n\nvar nodeOps = Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    childNodes: childNodes,\n    setAttribute: setAttribute\n  });\n\n  var emptyData = {};\n  var emptyNode = new VNode('', emptyData, []);\n  var hooks$1 = ['create', 'update', 'postpatch', 'remove', 'destroy'];\n\n  function isUndef(s) {\n    return s == null;\n  }\n\n  function isDef(s) {\n    return s != null;\n  }\n\n  function sameVnode(vnode1, vnode2) {\n    return vnode1.key === vnode2.key && vnode1.tag === vnode2.tag && vnode1.isComment === vnode2.isComment && !vnode1.data === !vnode2.data;\n  }\n\n  function createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i = void 0,\n        key = void 0;\n    var map = {};\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n      if (isDef(key)) map[key] = i;\n    }\n    return map;\n  }\n\n  function createPatchFunction(backend) {\n    var i = void 0,\n        j = void 0;\n    var cbs = {};\n\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n\n    for (i = 0; i < hooks$1.length; ++i) {\n      cbs[hooks$1[i]] = [];\n      for (j = 0; j < modules.length; ++j) {\n        if (modules[j][hooks$1[i]] !== undefined) cbs[hooks$1[i]].push(modules[j][hooks$1[i]]);\n      }\n    }\n\n    function emptyNodeAt(elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n\n    function createRmCb(childElm, listeners) {\n      function remove() {\n        if (--remove.listeners === 0) {\n          removeElement(childElm);\n        }\n      }\n      remove.listeners = listeners;\n      return remove;\n    }\n\n    function removeElement(el) {\n      var parent = nodeOps.parentNode(el);\n      nodeOps.removeChild(parent, el);\n    }\n\n    function createElm(vnode, insertedVnodeQueue, nested) {\n      var i = void 0,\n          elm = void 0;\n      var data = vnode.data;\n      vnode.isRootInsert = !nested;\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) i(vnode);\n        // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n        if (isDef(i = vnode.child)) {\n          initComponent(vnode, insertedVnodeQueue);\n          return vnode.elm;\n        }\n      }\n      var children = vnode.children;\n      var tag = vnode.tag;\n      if (isDef(tag)) {\n        if (true) {\n          if (!vnode.ns && !(config.ignoredElements && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n          }\n        }\n        elm = vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag);\n        setScope(vnode);\n        if (Array.isArray(children)) {\n          for (i = 0; i < children.length; ++i) {\n            nodeOps.appendChild(elm, createElm(children[i], insertedVnodeQueue, true));\n          }\n        } else if (isPrimitive(vnode.text)) {\n          nodeOps.appendChild(elm, nodeOps.createTextNode(vnode.text));\n        }\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n      } else if (vnode.isComment) {\n        elm = vnode.elm = nodeOps.createComment(vnode.text);\n      } else {\n        elm = vnode.elm = nodeOps.createTextNode(vnode.text);\n      }\n      return vnode.elm;\n    }\n\n    function isPatchable(vnode) {\n      while (vnode.child) {\n        vnode = vnode.child._vnode;\n      }\n      return isDef(vnode.tag);\n    }\n\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n      for (var _i = 0; _i < cbs.create.length; ++_i) {\n        cbs.create[_i](emptyNode, vnode);\n      }\n      i = vnode.data.hook; // Reuse variable\n      if (isDef(i)) {\n        if (i.create) i.create(emptyNode, vnode);\n        if (i.insert) insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function initComponent(vnode, insertedVnodeQueue) {\n      if (vnode.data.pendingInsert) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      }\n      vnode.elm = vnode.child.$el;\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n    function setScope(vnode) {\n      var i = void 0;\n      if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n    }\n\n    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        nodeOps.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);\n      }\n    }\n\n    function invokeDestroyHook(vnode) {\n      var i = void 0,\n          j = void 0;\n      var data = vnode.data;\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);\n        for (i = 0; i < cbs.destroy.length; ++i) {\n          cbs.destroy[i](vnode);\n        }\n      }\n      if (isDef(i = vnode.child) && !data.keepAlive) {\n        invokeDestroyHook(i._vnode);\n      }\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            invokeDestroyHook(ch);\n            removeAndInvokeRemoveHook(ch);\n          } else {\n            // Text node\n            nodeOps.removeChild(parentElm, ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook(vnode, rm) {\n      if (rm || isDef(vnode.data)) {\n        var listeners = cbs.remove.length + 1;\n        if (!rm) {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        } else {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        }\n        // recursively invoke hooks on child component root node\n        if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeElement(vnode.elm);\n      }\n    }\n\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx = void 0,\n          idxInOld = void 0,\n          elmToMove = void 0,\n          before = void 0;\n\n      // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n      var canMove = !removeOnly;\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) {\n          // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) {\n          // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n          if (isUndef(idxInOld)) {\n            // New element\n            nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            elmToMove = oldCh[idxInOld];\n            /* istanbul ignore if */\n            if (\"development\" !== 'production' && !elmToMove) {\n              warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');\n            }\n            if (elmToMove.tag !== newStartVnode.tag) {\n              // same key but different element. treat as new element\n              nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n              newStartVnode = newCh[++newStartIdx];\n            } else {\n              patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n              newStartVnode = newCh[++newStartIdx];\n            }\n          }\n        }\n      }\n      if (oldStartIdx > oldEndIdx) {\n        before = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n      if (oldVnode === vnode) {\n        return;\n      }\n      if (vnode.isStatic && oldVnode.isStatic && vnode.key === oldVnode.key) {\n        vnode.elm = oldVnode.elm;\n        return;\n      }\n      var i = void 0,\n          hook = void 0;\n      var hasData = isDef(i = vnode.data);\n      if (hasData && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {\n        i(oldVnode, vnode);\n      }\n      var elm = vnode.elm = oldVnode.elm;\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n      if (hasData && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) {\n          cbs.update[i](oldVnode, vnode);\n        }if (isDef(hook) && isDef(i = hook.update)) i(oldVnode, vnode);\n      }\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n        } else if (isDef(ch)) {\n          if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '');\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n      if (hasData) {\n        for (i = 0; i < cbs.postpatch.length; ++i) {\n          cbs.postpatch[i](oldVnode, vnode);\n        }if (isDef(hook) && isDef(i = hook.postpatch)) i(oldVnode, vnode);\n      }\n    }\n\n    function invokeInsertHook(vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (initial && vnode.parent) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var _i2 = 0; _i2 < queue.length; ++_i2) {\n          queue[_i2].data.hook.insert(queue[_i2]);\n        }\n      }\n    }\n\n    var bailed = false;\n    function hydrate(elm, vnode, insertedVnodeQueue) {\n      if (true) {\n        if (!assertNodeMatch(elm, vnode)) {\n          return false;\n        }\n      }\n      vnode.elm = elm;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) i(vnode, true /* hydrating */);\n        if (isDef(i = vnode.child)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true;\n        }\n      }\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          var childNodes = nodeOps.childNodes(elm);\n          var childrenMatch = true;\n          if (childNodes.length !== children.length) {\n            childrenMatch = false;\n          } else {\n            for (var _i3 = 0; _i3 < children.length; _i3++) {\n              if (!hydrate(childNodes[_i3], children[_i3], insertedVnodeQueue)) {\n                childrenMatch = false;\n                break;\n              }\n            }\n          }\n          if (!childrenMatch) {\n            if (\"development\" !== 'production' && typeof console !== 'undefined' && !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', childNodes, children);\n            }\n            return false;\n          }\n        }\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n      }\n      return true;\n    }\n\n    function assertNodeMatch(node, vnode) {\n      if (vnode.tag) {\n        return vnode.tag.indexOf('vue-component') === 0 || vnode.tag === nodeOps.tagName(node).toLowerCase();\n      } else {\n        return _toString(vnode.text) === node.data;\n      }\n    }\n\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\n      var elm = void 0,\n          parent = void 0;\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (!oldVnode) {\n        // empty mount, create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n              oldVnode.removeAttribute('server-rendered');\n              hydrating = true;\n            }\n            if (hydrating) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode;\n              } else if (true) {\n                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n              }\n            }\n            // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n            oldVnode = emptyNodeAt(oldVnode);\n          }\n          elm = oldVnode.elm;\n          parent = nodeOps.parentNode(elm);\n\n          createElm(vnode, insertedVnodeQueue);\n\n          // component root element replaced.\n          // update parent placeholder node element.\n          if (vnode.parent) {\n            vnode.parent.elm = vnode.elm;\n            if (isPatchable(vnode)) {\n              for (var _i4 = 0; _i4 < cbs.create.length; ++_i4) {\n                cbs.create[_i4](emptyNode, vnode.parent);\n              }\n            }\n          }\n\n          if (parent !== null) {\n            nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm));\n            removeVnodes(parent, [oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm;\n    };\n  }\n\n  var directives = {\n    create: function bindDirectives(oldVnode, vnode) {\n      applyDirectives(oldVnode, vnode, 'bind');\n    },\n    update: function updateDirectives(oldVnode, vnode) {\n      applyDirectives(oldVnode, vnode, 'update');\n    },\n    postpatch: function postupdateDirectives(oldVnode, vnode) {\n      applyDirectives(oldVnode, vnode, 'componentUpdated');\n    },\n    destroy: function unbindDirectives(vnode) {\n      applyDirectives(vnode, vnode, 'unbind');\n    }\n  };\n\n  var emptyModifiers = Object.create(null);\n\n  function applyDirectives(oldVnode, vnode, hook) {\n    var dirs = vnode.data.directives;\n    if (dirs) {\n      var oldDirs = oldVnode.data.directives;\n      var isUpdate = hook === 'update';\n      for (var i = 0; i < dirs.length; i++) {\n        var dir = dirs[i];\n        var def = resolveAsset(vnode.context.$options, 'directives', dir.name, true);\n        var fn = def && def[hook];\n        if (fn) {\n          if (isUpdate && oldDirs) {\n            dir.oldValue = oldDirs[i].value;\n          }\n          if (!dir.modifiers) {\n            dir.modifiers = emptyModifiers;\n          }\n          fn(vnode.elm, dir, vnode, oldVnode);\n        }\n      }\n    }\n  }\n\n  var ref = {\n    create: function create(_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update(oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy(vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef(vnode, isRemoval) {\n    var key = vnode.data.ref;\n    if (!key) return;\n\n    var vm = vnode.context;\n    var ref = vnode.child || vnode.elm;\n    var refs = vm.$refs;\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (Array.isArray(refs[key])) {\n          refs[key].push(ref);\n        } else {\n          refs[key] = [ref];\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n\n  var baseModules = [ref, directives];\n\n  function updateAttrs(oldVnode, vnode) {\n    if (!oldVnode.data.attrs && !vnode.data.attrs) {\n      return;\n    }\n    var key = void 0,\n        cur = void 0,\n        old = void 0;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (attrs.__ob__) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    }\n    for (key in oldAttrs) {\n      if (attrs[key] == null) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr(el, key, value) {\n    if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        el.setAttribute(key, key);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        el.setAttribute(key, value);\n      }\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n\n  function updateClass(oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n    if (!data.staticClass && !data.class && (!oldData || !oldData.staticClass && !oldData.class)) {\n      return;\n    }\n\n    var cls = genClassForVnode(vnode);\n\n    // handle transition classes\n    var transitionClass = el._transitionClasses;\n    if (transitionClass) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    }\n\n    // set the class\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n\n  function updateDOMListeners(oldVnode, vnode) {\n    if (!oldVnode.data.on && !vnode.data.on) {\n      return;\n    }\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    var add = vnode.elm._v_add || (vnode.elm._v_add = function (event, handler, capture) {\n      vnode.elm.addEventListener(event, handler, capture);\n    });\n    var remove = vnode.elm._v_remove || (vnode.elm._v_remove = function (event, handler) {\n      vnode.elm.removeEventListener(event, handler);\n    });\n    updateListeners(on, oldOn, add, remove);\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n\n  function updateDOMProps(oldVnode, vnode) {\n    if (!oldVnode.data.domProps && !vnode.data.domProps) {\n      return;\n    }\n    var key = void 0,\n        cur = void 0;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (props.__ob__) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (props[key] == null) {\n        elm[key] = undefined;\n      }\n    }\n    for (key in props) {\n      // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n      if ((key === 'textContent' || key === 'innerHTML') && vnode.children) {\n        vnode.children.length = 0;\n      }\n      cur = props[key];\n      if (key === 'value') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur;\n        // avoid resetting cursor position when value is the same\n        var strCur = cur == null ? '' : String(cur);\n        if (elm.value !== strCur) {\n          elm.value = strCur;\n        }\n      } else {\n        elm[key] = cur;\n      }\n    }\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n\n  var prefixes = ['Webkit', 'Moz', 'ms'];\n\n  var testEl = void 0;\n  var normalize = cached(function (prop) {\n    testEl = testEl || document.createElement('div');\n    prop = camelize(prop);\n    if (prop !== 'filter' && prop in testEl.style) {\n      return prop;\n    }\n    var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n    for (var i = 0; i < prefixes.length; i++) {\n      var prefixed = prefixes[i] + upper;\n      if (prefixed in testEl.style) {\n        return prefixed;\n      }\n    }\n  });\n\n  function updateStyle(oldVnode, vnode) {\n    if ((!oldVnode.data || !oldVnode.data.style) && !vnode.data.style) {\n      return;\n    }\n    var cur = void 0,\n        name = void 0;\n    var el = vnode.elm;\n    var oldStyle = oldVnode.data.style || {};\n    var style = vnode.data.style || {};\n\n    // handle string\n    if (typeof style === 'string') {\n      el.style.cssText = style;\n      return;\n    }\n\n    var needClone = style.__ob__;\n\n    // handle array syntax\n    if (Array.isArray(style)) {\n      style = vnode.data.style = toObject(style);\n    }\n\n    // clone the style for future updates,\n    // in case the user mutates the style object in-place.\n    if (needClone) {\n      style = vnode.data.style = extend({}, style);\n    }\n\n    for (name in oldStyle) {\n      if (!style[name]) {\n        el.style[normalize(name)] = '';\n      }\n    }\n    for (name in style) {\n      cur = style[name];\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        el.style[normalize(name)] = cur || '';\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function addClass(el, cls) {\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(/\\s+/).forEach(function (c) {\n          return el.classList.add(c);\n        });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = ' ' + el.getAttribute('class') + ' ';\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function removeClass(el, cls) {\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(/\\s+/).forEach(function (c) {\n          return el.classList.remove(c);\n        });\n      } else {\n        el.classList.remove(cls);\n      }\n    } else {\n      var cur = ' ' + el.getAttribute('class') + ' ';\n      var tar = ' ' + cls + ' ';\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n      el.setAttribute('class', cur.trim());\n    }\n  }\n\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation';\n\n  // Transition property/event sniffing\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  }\n\n  var raf = inBrowser && window.requestAnimationFrame || setTimeout;\n  function nextFrame(fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass(el, cls) {\n    (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n    addClass(el, cls);\n  }\n\n  function removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds(el, expectedType, cb) {\n    var _getTransitionInfo = getTransitionInfo(el, expectedType);\n\n    var type = _getTransitionInfo.type;\n    var timeout = _getTransitionInfo.timeout;\n    var propCount = _getTransitionInfo.propCount;\n\n    if (!type) return cb();\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n    var end = function end() {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n    var onEnd = function onEnd() {\n      if (++ended >= propCount) {\n        end();\n      }\n    };\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo(el, expectedType) {\n    var styles = window.getComputedStyle(el);\n    var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n    var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n    var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n    var animationDelays = styles[animationProp + 'Delay'].split(', ');\n    var animationDurations = styles[animationProp + 'Duration'].split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n    var type = void 0;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n    }\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    };\n  }\n\n  function getTimeout(delays, durations) {\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i]);\n    }));\n  }\n\n  function toMs(s) {\n    return Number(s.slice(0, -1)) * 1000;\n  }\n\n  function enter(vnode) {\n    var el = vnode.elm;\n\n    // call leave callback now\n    if (el._leaveCb) {\n      el._leaveCb.cancelled = true;\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (!data) {\n      return;\n    }\n\n    /* istanbul ignore if */\n    if (el._enterCb || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n\n    // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n\n    var transitionNode = activeInstance.$vnode;\n    var context = transitionNode && transitionNode.parent ? transitionNode.parent.context : activeInstance;\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return;\n    }\n\n    var startClass = isAppear ? appearClass : enterClass;\n    var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = enterHook &&\n    // enterHook may be a bound method which exposes\n    // the length of original fn as _length\n    (enterHook._length || enterHook.length) > 1;\n\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, activeClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent._pending && parent._pending[vnode.key];\n        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n          pendingNode.elm._leaveCb();\n        }\n        enterHook && enterHook(el, cb);\n      });\n    }\n\n    // start enter transition\n    beforeEnterHook && beforeEnterHook(el);\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n        if (!cb.cancelled && !userWantsControl) {\n          whenTransitionEnds(el, type, cb);\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave(vnode, rm) {\n    var el = vnode.elm;\n\n    // call enter callback now\n    if (el._enterCb) {\n      el._enterCb.cancelled = true;\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (!data) {\n      return rm();\n    }\n\n    /* istanbul ignore if */\n    if (el._leaveCb || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = leave &&\n    // leave hook may be a bound method which exposes\n    // the length of original fn as _length\n    (leave._length || leave.length) > 1;\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveActiveClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave() {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return;\n      }\n      // record leaving element\n      if (!vnode.data.show) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n      }\n      beforeLeave && beforeLeave(el);\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n          if (!cb.cancelled && !userWantsControl) {\n            whenTransitionEnds(el, type, cb);\n          }\n        });\n      }\n      leave && leave(el, cb);\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  }\n\n  function resolveTransition(def) {\n    if (!def) {\n      return;\n    }\n    /* istanbul ignore else */\n    if (typeof def === 'object') {\n      var res = {};\n      if (def.css !== false) {\n        extend(res, autoCssTransition(def.name || 'v'));\n      }\n      extend(res, def);\n      return res;\n    } else if (typeof def === 'string') {\n      return autoCssTransition(def);\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: name + '-enter',\n      leaveClass: name + '-leave',\n      appearClass: name + '-enter',\n      enterActiveClass: name + '-enter-active',\n      leaveActiveClass: name + '-leave-active',\n      appearActiveClass: name + '-enter-active'\n    };\n  });\n\n  function once(fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn();\n      }\n    };\n  }\n\n  var transition = inBrowser ? {\n    create: function create(_, vnode) {\n      if (!vnode.data.show) {\n        enter(vnode);\n      }\n    },\n    remove: function remove(vnode, rm) {\n      /* istanbul ignore else */\n      if (!vnode.data.show) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n\n  var platformModules = [attrs, klass, events, domProps, style, transition];\n\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n  var modules = platformModules.concat(baseModules);\n\n  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n  var modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_\\-]*)?$/;\n\n  /* istanbul ignore if */\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var model = {\n    bind: function bind(el, binding, vnode) {\n      if (true) {\n        if (!modelableTagRE.test(vnode.tag)) {\n          warn('v-model is not supported on element type: <' + vnode.tag + '>. ' + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', vnode.context);\n        }\n      }\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context);\n      } else {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    },\n    componentUpdated: function componentUpdated(el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context);\n        // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matchig\n        // option in the DOM.\n        var needReset = el.multiple ? binding.value.some(function (v) {\n          return hasNoMatchingOption(v, el.options);\n        }) : hasNoMatchingOption(binding.value, el.options);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  };\n\n  function setSelected(el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    } else if (!Array.isArray(value)) {\n      \"development\" !== 'production' && warn('<select multiple v-model=\"' + binding.expression + '\"> ' + ('expects an Array value for its binding, but got ' + Object.prototype.toString.call(value).slice(8, -1)), vm);\n      return;\n    }\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      var option = el.options[i];\n      if (isMultiple) {\n        option.selected = value.indexOf(getValue(option)) > -1;\n      } else {\n        if (getValue(option) === value) {\n          el.selectedIndex = i;\n          break;\n        }\n      }\n    }\n  }\n\n  function hasNoMatchingOption(value, options) {\n    for (var i = 0, l = options.length; i < l; i++) {\n      if (getValue(options[i]) === value) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function getValue(option) {\n    return '_value' in option ? option._value : option.value || option.text;\n  }\n\n  function onCompositionStart(e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd(e) {\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger(el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n\n  // recursively search for possible transition defined inside the component root\n  function locateNode(vnode) {\n    return vnode.child && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.child._vnode) : vnode;\n  }\n\n  var show = {\n    bind: function bind(el, _ref, vnode) {\n      var value = _ref.value;\n\n      vnode = locateNode(vnode);\n      var transition = vnode.data && vnode.data.transition;\n      if (value && transition && transition.appear && !isIE9) {\n        enter(vnode);\n      }\n      var originalDisplay = el.style.display;\n      el.style.display = value ? originalDisplay : 'none';\n      el.__vOriginalDisplay = originalDisplay;\n    },\n    update: function update(el, _ref2, vnode) {\n      var value = _ref2.value;\n      var oldValue = _ref2.oldValue;\n\n      /* istanbul ignore if */\n      if (value === oldValue) return;\n      vnode = locateNode(vnode);\n      var transition = vnode.data && vnode.data.transition;\n      if (transition && !isIE9) {\n        if (value) {\n          enter(vnode);\n          el.style.display = el.__vOriginalDisplay;\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    }\n  };\n\n  var platformDirectives = {\n    model: model,\n    show: show\n  };\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String\n  };\n\n  // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recrusively retrieve the real component to be rendered\n  function getRealChild(vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children));\n    } else {\n      return vnode;\n    }\n  }\n\n  function extractTransitionData(comp) {\n    var data = {};\n    var options = comp.$options;\n    // props\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    }\n    // events.\n    // extract listeners and pass them directly to the transition methods\n    var listeners = options._parentListeners;\n    for (var _key in listeners) {\n      data[camelize(_key)] = listeners[_key].fn;\n    }\n    return data;\n  }\n\n  function placeholder(h, rawChild) {\n    return (/\\d-keep-alive$/.test(rawChild.tag) ? h('keep-alive') : null\n    );\n  }\n\n  function hasParentTransition(vnode) {\n    while (vnode = vnode.parent) {\n      if (vnode.data.transition) {\n        return true;\n      }\n    }\n  }\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n    render: function render(h) {\n      var _this = this;\n\n      var children = this.$slots.default;\n      if (!children) {\n        return;\n      }\n\n      // filter out text nodes (possible whitespaces)\n      children = children.filter(function (c) {\n        return c.tag;\n      });\n      /* istanbul ignore if */\n      if (!children.length) {\n        return;\n      }\n\n      // warn multiple elements\n      if (\"development\" !== 'production' && children.length > 1) {\n        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n      }\n\n      var mode = this.mode;\n\n      // warn invalid mode\n      if (\"development\" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n        warn('invalid <transition> mode: ' + mode, this.$parent);\n      }\n\n      var rawChild = children[0];\n\n      // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild;\n      }\n\n      // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n      if (!child) {\n        return rawChild;\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild);\n      }\n\n      child.key = child.key == null ? '__v' + (child.tag + this._uid) + '__' : child.key;\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild);\n\n      if (oldChild && oldChild.data && oldChild.key !== child.key) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data);\n\n        // handle transition mode\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            _this._leaving = false;\n            _this.$forceUpdate();\n          });\n          return placeholder(h, rawChild);\n        } else if (mode === 'in-out') {\n          (function () {\n            var delayedLeave = void 0;\n            var performLeave = function performLeave() {\n              delayedLeave();\n            };\n            mergeVNodeHook(data, 'afterEnter', performLeave);\n            mergeVNodeHook(data, 'enterCancelled', performLeave);\n            mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n              delayedLeave = leave;\n            });\n          })();\n        }\n      }\n\n      return rawChild;\n    }\n  };\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n\n  delete props.mode;\n\n  var TransitionGroup = {\n    props: props,\n\n    render: function render(h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n        if (c.tag) {\n          if (c.key != null) {\n            children.push(c);\n            map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;\n          } else if (true) {\n            var opts = c.componentOptions;\n            var name = opts ? opts.Ctor.options.name || opts.tag : c.tag;\n            warn('<transition-group> children must be keyed: <' + name + '>');\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n        for (var _i = 0; _i < prevChildren.length; _i++) {\n          var _c = prevChildren[_i];\n          _c.data.transition = transitionData;\n          _c.data.pos = _c.elm.getBoundingClientRect();\n          if (map[_c.key]) {\n            kept.push(_c);\n          } else {\n            removed.push(_c);\n          }\n        }\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children);\n    },\n    beforeUpdate: function beforeUpdate() {\n      // force removing pass\n      this.__patch__(this._vnode, this.kept, false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this._vnode = this.kept;\n    },\n    updated: function updated() {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || this.name + '-move';\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return;\n      }\n\n      children.forEach(function (c) {\n        /* istanbul ignore if */\n        if (c.elm._moveCb) {\n          c.elm._moveCb();\n        }\n        /* istanbul ignore if */\n        if (c.elm._enterCb) {\n          c.elm._enterCb();\n        }\n        var oldPos = c.data.pos;\n        var newPos = c.data.pos = c.elm.getBoundingClientRect();\n        var dx = oldPos.left - newPos.left;\n        var dy = oldPos.top - newPos.top;\n        if (dx || dy) {\n          c.data.moved = true;\n          var s = c.elm.style;\n          s.transform = s.WebkitTransform = 'translate(' + dx + 'px,' + dy + 'px)';\n          s.transitionDuration = '0s';\n        }\n      });\n\n      // force reflow to put everything in position\n      var f = document.body.offsetHeight; // eslint-disable-line\n\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          (function () {\n            var el = c.elm;\n            var s = el.style;\n            addTransitionClass(el, moveClass);\n            s.transform = s.WebkitTransform = s.transitionDuration = '';\n            el._moveDest = c.data.pos;\n            el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n              if (!e || /transform$/.test(e.propertyName)) {\n                el.removeEventListener(transitionEndEvent, cb);\n                el._moveCb = null;\n                removeTransitionClass(el, moveClass);\n              }\n            });\n          })();\n        }\n      });\n    },\n\n\n    methods: {\n      hasMove: function hasMove(el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false;\n        }\n        if (this._hasMove != null) {\n          return this._hasMove;\n        }\n        addTransitionClass(el, moveClass);\n        var info = getTransitionInfo(el);\n        removeTransitionClass(el, moveClass);\n        return this._hasMove = info.hasTransform;\n      }\n    }\n  };\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n\n  // install platform specific utils\n  Vue.config.isUnknownElement = isUnknownElement;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.mustUseProp = mustUseProp;\n\n  // install platform runtime directives & components\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents);\n\n  // install platform patch function\n  Vue.prototype.__patch__ = config._isServer ? noop : patch;\n\n  // wrap mount\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && !config._isServer ? query(el) : undefined;\n    return this._mount(el, hydrating);\n  };\n\n  // devtools global hook\n  /* istanbul ignore next */\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (\"development\" !== 'production' && inBrowser && /Chrome\\/\\d+/.test(window.navigator.userAgent)) {\n        console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n      }\n    }\n  }, 0);\n\n  var decoder = document.createElement('div');\n\n  function decodeHTML(html) {\n    decoder.innerHTML = html;\n    return decoder.textContent;\n  }\n\n  // Regular Expressions for parsing tags and attributes\n  var singleAttrIdentifier = /([^\\s\"'<>\\/=]+)/;\n  var singleAttrAssign = /(?:=)/;\n  var singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source];\n  var attribute = new RegExp('^\\\\s*' + singleAttrIdentifier.source + '(?:\\\\s*(' + singleAttrAssign.source + ')' + '\\\\s*(?:' + singleAttrValues.join('|') + '))?');\n\n  // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n  // but for Vue templates we can enforce a simple charset\n  var ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\n  var qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\n  var startTagOpen = new RegExp('^<' + qnameCapture);\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\n  var doctype = /^<!DOCTYPE [^>]+>/i;\n\n  var IS_REGEX_CAPTURING_BROKEN = false;\n  'x'.replace(/x(.)?/g, function (m, g) {\n    IS_REGEX_CAPTURING_BROKEN = g === '';\n  });\n\n  // Special Elements (can contain anything)\n  var isSpecialTag = makeMap('script,style', true);\n\n  var reCache = {};\n\n  var ampRE = /&amp;/g;\n  var ltRE = /&lt;/g;\n  var gtRE = /&gt;/g;\n  var quoteRE = /&quot;/g;\n\n  function decodeAttr(value, shouldDecodeTags) {\n    if (shouldDecodeTags) {\n      value = value.replace(ltRE, '<').replace(gtRE, '>');\n    }\n    return value.replace(ampRE, '&').replace(quoteRE, '\"');\n  }\n\n  function parseHTML(html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag = options.isUnaryTag || no;\n    var isFromDOM = options.isFromDOM;\n    var shouldDecodeTags = options.shouldDecodeTags;\n    var index = 0;\n    var last = void 0,\n        lastTag = void 0;\n    while (html) {\n      last = html;\n      // Make sure we're not in a script or style element\n      if (!lastTag || !isSpecialTag(lastTag)) {\n        var textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n          // Comment:\n          if (/^<!--/.test(html)) {\n            var commentEnd = html.indexOf('-->');\n\n            if (commentEnd >= 0) {\n              advance(commentEnd + 3);\n              continue;\n            }\n          }\n\n          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n          if (/^<!\\[/.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue;\n            }\n          }\n\n          // Doctype:\n          var doctypeMatch = html.match(doctype);\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue;\n          }\n\n          // End tag:\n          var endTagMatch = html.match(endTag);\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[0], endTagMatch[1], curIndex, index);\n            continue;\n          }\n\n          // Start tag:\n          var startTagMatch = parseStartTag();\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n            continue;\n          }\n        }\n\n        var text = void 0;\n        if (textEnd >= 0) {\n          text = html.substring(0, textEnd);\n          advance(textEnd);\n        } else {\n          text = html;\n          html = '';\n        }\n\n        if (options.chars) {\n          options.chars(text);\n        }\n      } else {\n        (function () {\n          var stackedTag = lastTag.toLowerCase();\n          var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n          var endTagLength = 0;\n          var rest = html.replace(reStackedTag, function (all, text, endTag) {\n            endTagLength = endTag.length;\n            if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {\n              text = text.replace(/<!--([\\s\\S]*?)-->/g, '$1').replace(/<!\\[CDATA\\[([\\s\\S]*?)\\]\\]>/g, '$1');\n            }\n            if (options.chars) {\n              options.chars(text);\n            }\n            return '';\n          });\n          index += html.length - rest.length;\n          html = rest;\n          parseEndTag('</' + stackedTag + '>', stackedTag, index - endTagLength, index);\n        })();\n      }\n\n      if (html === last) {\n        throw new Error('Error parsing template:\\n\\n' + html);\n      }\n    }\n\n    // Clean up any remaining tags\n    parseEndTag();\n\n    function advance(n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag() {\n      var start = html.match(startTagOpen);\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end = void 0,\n            attr = void 0;\n        while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n          advance(attr[0].length);\n          match.attrs.push(attr);\n        }\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match;\n        }\n      }\n    }\n\n    function handleStartTag(match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag('', lastTag);\n        }\n        if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n          parseEndTag('', tagName);\n        }\n      }\n\n      var unary = isUnaryTag(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n          if (args[3] === '') {\n            delete args[3];\n          }\n          if (args[4] === '') {\n            delete args[4];\n          }\n          if (args[5] === '') {\n            delete args[5];\n          }\n        }\n        var value = args[3] || args[4] || args[5] || '';\n        attrs[i] = {\n          name: args[1],\n          value: isFromDOM ? decodeAttr(value, shouldDecodeTags) : value\n        };\n      }\n\n      if (!unary) {\n        stack.push({ tag: tagName, attrs: attrs });\n        lastTag = tagName;\n        unarySlash = '';\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag(tag, tagName, start, end) {\n      var pos = void 0;\n      if (start == null) start = index;\n      if (end == null) end = index;\n\n      // Find the closest opened tag of the same type\n      if (tagName) {\n        var needle = tagName.toLowerCase();\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].tag.toLowerCase() === needle) {\n            break;\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        }\n\n        // Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (tagName.toLowerCase() === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (tagName.toLowerCase() === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n\n  function parseFilters(exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c = void 0,\n        prev = void 0,\n        i = void 0,\n        expression = void 0,\n        filters = void 0;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n      if (inSingle) {\n        // check single quote\n        if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\n      } else if (inDouble) {\n        // check double quote\n        if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\n      } else if (c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;break; // \"\n          case 0x27:\n            inSingle = true;break; // '\n          case 0x28:\n            paren++;break; // (\n          case 0x29:\n            paren--;break; // )\n          case 0x5B:\n            square++;break; // [\n          case 0x5D:\n            square--;break; // ]\n          case 0x7B:\n            curly++;break; // {\n          case 0x7D:\n            curly--;break; // }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter() {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression;\n  }\n\n  function wrapFilter(exp, filter) {\n    var i = filter.indexOf('(');\n    if (i < 0) {\n      // _f: resolveFilter\n      return '_f(\"' + filter + '\")(' + exp + ')';\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return '_f(\"' + name + '\")(' + exp + ',' + args;\n    }\n  }\n\n  var defaultTagRE = /\\{\\{((?:.|\\\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n  });\n\n  function parseText(text, delimiters) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n    if (!tagRE.test(text)) {\n      return;\n    }\n    var tokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match = void 0,\n        index = void 0;\n    while (match = tagRE.exec(text)) {\n      index = match.index;\n      // push text token\n      if (index > lastIndex) {\n        tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n      }\n      // tag token\n      var exp = parseFilters(match[1].trim());\n      tokens.push('_s(' + exp + ')');\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n      tokens.push(JSON.stringify(text.slice(lastIndex)));\n    }\n    return tokens.join('+');\n  }\n\n  function baseWarn(msg) {\n    console.error('[Vue parser]: ' + msg);\n  }\n\n  function pluckModuleFunction(modules, key) {\n    return modules ? modules.map(function (m) {\n      return m[key];\n    }).filter(function (_) {\n      return _;\n    }) : [];\n  }\n\n  function addProp(el, name, value) {\n    (el.props || (el.props = [])).push({ name: name, value: value });\n  }\n\n  function addAttr(el, name, value) {\n    (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n  }\n\n  function addDirective(el, name, value, arg, modifiers) {\n    (el.directives || (el.directives = [])).push({ name: name, value: value, arg: arg, modifiers: modifiers });\n  }\n\n  function addHook(el, name, code) {\n    var hooks = el.hooks || (el.hooks = {});\n    var hook = hooks[name];\n    /* istanbul ignore if */\n    if (hook) {\n      hook.push(code);\n    } else {\n      hooks[name] = [code];\n    }\n  }\n\n  function addHandler(el, name, value, modifiers) {\n    // check capture modifier\n    if (modifiers && modifiers.capture) {\n      delete modifiers.capture;\n      name = '!' + name; // mark the event as captured\n    }\n    var events = void 0;\n    if (modifiers && modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n    var newHandler = { value: value, modifiers: modifiers };\n    var handlers = events[name];\n    /* istanbul ignore if */\n    if (Array.isArray(handlers)) {\n      handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n  }\n\n  function getBindingAttr(el, name, getStatic) {\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n    if (dynamicValue != null) {\n      return dynamicValue;\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n      if (staticValue != null) {\n        return JSON.stringify(staticValue);\n      }\n    }\n  }\n\n  function getAndRemoveAttr(el, name) {\n    var val = void 0;\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return val;\n  }\n\n  var dirRE = /^v-|^@|^:/;\n  var forAliasRE = /(.*)\\s+(?:in|of)\\s+(.*)/;\n  var forIteratorRE = /\\(([^,]*),([^,]*)(?:,([^,]*))?\\)/;\n  var bindRE = /^:|^v-bind:/;\n  var onRE = /^@|^v-on:/;\n  var argRE = /:(.*)$/;\n  var modifierRE = /\\.[^\\.]+/g;\n\n  var decodeHTMLCached = cached(decodeHTML);\n\n  // configurable state\n  var warn$1 = void 0;\n  var platformGetTagNamespace = void 0;\n  var platformMustUseProp = void 0;\n  var platformIsPreTag = void 0;\n  var preTransforms = void 0;\n  var transforms = void 0;\n  var postTransforms = void 0;\n  var delimiters = void 0;\n  var seenSlots = void 0;\n\n  /**\n   * Convert HTML string to AST.\n   */\n  function parse(template, options) {\n    warn$1 = options.warn || baseWarn;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformIsPreTag = options.isPreTag || no;\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n    delimiters = options.delimiters;\n    seenSlots = Object.create(null);\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var root = void 0;\n    var currentParent = void 0;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n    parseHTML(template, {\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      isFromDOM: options.isFromDOM,\n      shouldDecodeTags: options.shouldDecodeTags,\n      start: function start(tag, attrs, unary) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);\n\n        // handle IE svg bug\n        /* istanbul ignore if */\n        if (options.isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = {\n          type: 1,\n          tag: tag,\n          attrsList: attrs,\n          attrsMap: makeAttrsMap(attrs),\n          parent: currentParent,\n          children: []\n        };\n        if (ns) {\n          element.ns = ns;\n        }\n\n        if (\"client\" !== 'server' && isForbiddenTag(element)) {\n          element.forbidden = true;\n          \"development\" !== 'production' && warn$1('Templates should only be responsbile for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + ('<' + tag + '>.'));\n        }\n\n        // apply pre-transforms\n        for (var i = 0; i < preTransforms.length; i++) {\n          preTransforms[i](element, options);\n        }\n\n        if (!inVPre) {\n          processPre(element);\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n        if (inVPre) {\n          processRawAttrs(element);\n        } else {\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n\n          // determine whether this is a plain element after\n          // removing structural attributes\n          element.plain = !element.key && !attrs.length;\n\n          processKey(element);\n          processRef(element);\n          processSlot(element);\n          processComponent(element);\n          for (var _i = 0; _i < transforms.length; _i++) {\n            transforms[_i](element, options);\n          }\n          processAttrs(element);\n        }\n\n        function checkRootConstraints(el) {\n          if (true) {\n            if (el.tag === 'slot' || el.tag === 'template') {\n              warn$1('Cannot use <' + el.tag + '> as component root element because it may ' + 'contain multiple nodes:\\n' + template);\n            }\n            if (el.attrsMap.hasOwnProperty('v-for')) {\n              warn$1('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements:\\n' + template);\n            }\n          }\n        }\n\n        // tree management\n        if (!root) {\n          root = element;\n          checkRootConstraints(root);\n        } else if (\"development\" !== 'production' && !stack.length && !warned) {\n          // allow 2 root elements with v-if and v-else\n          if (root.attrsMap.hasOwnProperty('v-if') && element.attrsMap.hasOwnProperty('v-else')) {\n            checkRootConstraints(element);\n          } else {\n            warned = true;\n            warn$1('Component template should contain exactly one root element:\\n\\n' + template);\n          }\n        }\n        if (currentParent && !element.forbidden) {\n          if (element.else) {\n            processElse(element, currentParent);\n          } else {\n            currentParent.children.push(element);\n            element.parent = currentParent;\n          }\n        }\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        }\n        // apply post-transforms\n        for (var _i2 = 0; _i2 < postTransforms.length; _i2++) {\n          postTransforms[_i2](element, options);\n        }\n      },\n      end: function end() {\n        // remove trailing whitespace\n        var element = stack[stack.length - 1];\n        var lastNode = element.children[element.children.length - 1];\n        if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {\n          element.children.pop();\n        }\n        // pop stack\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n        // check pre state\n        if (element.pre) {\n          inVPre = false;\n        }\n        if (platformIsPreTag(element.tag)) {\n          inPre = false;\n        }\n      },\n      chars: function chars(text) {\n        if (!currentParent) {\n          if (\"development\" !== 'production' && !warned) {\n            warned = true;\n            warn$1('Component template should contain exactly one root element:\\n\\n' + template);\n          }\n          return;\n        }\n        text = inPre || text.trim() ? decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && currentParent.children.length ? ' ' : '';\n        if (text) {\n          var expression = void 0;\n          if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n            currentParent.children.push({\n              type: 2,\n              expression: expression,\n              text: text\n            });\n          } else {\n            currentParent.children.push({\n              type: 3,\n              text: text\n            });\n          }\n        }\n      }\n    });\n    return root;\n  }\n\n  function processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs(el) {\n    var l = el.attrsList.length;\n    if (l) {\n      var attrs = el.attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        attrs[i] = {\n          name: el.attrsList[i].name,\n          value: JSON.stringify(el.attrsList[i].value)\n        };\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processKey(el) {\n    var exp = getBindingAttr(el, 'key');\n    if (exp) {\n      el.key = exp;\n    }\n  }\n\n  function processRef(el) {\n    var ref = getBindingAttr(el, 'ref');\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor(el) {\n    var exp = void 0;\n    if (exp = getAndRemoveAttr(el, 'v-for')) {\n      var inMatch = exp.match(forAliasRE);\n      if (!inMatch) {\n        \"development\" !== 'production' && warn$1('Invalid v-for expression: ' + exp);\n        return;\n      }\n      el.for = inMatch[2].trim();\n      var alias = inMatch[1].trim();\n      var iteratorMatch = alias.match(forIteratorRE);\n      if (iteratorMatch) {\n        el.alias = iteratorMatch[1].trim();\n        el.iterator1 = iteratorMatch[2].trim();\n        if (iteratorMatch[3]) {\n          el.iterator2 = iteratorMatch[3].trim();\n        }\n      } else {\n        el.alias = alias;\n      }\n    }\n  }\n\n  function processIf(el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n    if (exp) {\n      el.if = exp;\n    }\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n  }\n\n  function processElse(el, parent) {\n    var prev = findPrevElement(parent.children);\n    if (prev && prev.if) {\n      prev.elseBlock = el;\n    } else if (true) {\n      warn$1('v-else used on element <' + el.tag + '> without corresponding v-if.');\n    }\n  }\n\n  function processOnce(el) {\n    var once = getAndRemoveAttr(el, 'v-once');\n    if (once != null) {\n      el.once = true;\n    }\n  }\n\n  function processSlot(el) {\n    if (el.tag === 'slot') {\n      if (true) {\n        if (!el.attrsMap[':name'] && !el.attrsMap['v-bind:name'] && checkInFor(el)) {\n          warn$1('Static <slot> found inside v-for: they will not render correctly. ' + 'Render the list in parent scope and use a single <slot> instead.');\n        }\n      }\n      el.slotName = getBindingAttr(el, 'name');\n      if (true) {\n        var name = el.slotName;\n        if (seenSlots[name]) {\n          warn$1('Duplicate ' + (name ? '<slot> with name ' + name : 'default <slot>') + ' ' + 'found in the same template.');\n        }\n        seenSlots[name] = true;\n      }\n    } else {\n      var slotTarget = getBindingAttr(el, 'slot');\n      if (slotTarget) {\n        el.slotTarget = slotTarget;\n      }\n    }\n  }\n\n  function processComponent(el) {\n    var binding = void 0;\n    if (binding = getBindingAttr(el, 'is')) {\n      el.component = binding;\n    }\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs(el) {\n    var list = el.attrsList;\n    var i = void 0,\n        l = void 0,\n        name = void 0,\n        value = void 0,\n        arg = void 0,\n        modifiers = void 0,\n        isProp = void 0;\n    for (i = 0, l = list.length; i < l; i++) {\n      name = list[i].name;\n      value = list[i].value;\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true;\n        // modifiers\n        modifiers = parseModifiers(name);\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n        if (bindRE.test(name)) {\n          // v-bind\n          name = name.replace(bindRE, '');\n          if (modifiers && modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') name = 'innerHTML';\n          }\n          if (isProp || platformMustUseProp(name)) {\n            addProp(el, name, value);\n          } else {\n            addAttr(el, name, value);\n          }\n        } else if (onRE.test(name)) {\n          // v-on\n          name = name.replace(onRE, '');\n          addHandler(el, name, value, modifiers);\n        } else {\n          // normal directives\n          name = name.replace(dirRE, '');\n          // parse arg\n          var argMatch = name.match(argRE);\n          if (argMatch && (arg = argMatch[1])) {\n            name = name.slice(0, -(arg.length + 1));\n          }\n          addDirective(el, name, value, arg, modifiers);\n        }\n      } else {\n        // literal attribute\n        if (true) {\n          var expression = parseText(value, delimiters);\n          if (expression) {\n            warn$1(name + '=\"' + value + '\": ' + 'Interpolation inside attributes has been deprecated. ' + 'Use v-bind or the colon shorthand instead.');\n          }\n        }\n        addAttr(el, name, JSON.stringify(value));\n      }\n    }\n  }\n\n  function checkInFor(el) {\n    var parent = el;\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true;\n      }\n      parent = parent.parent;\n    }\n    return false;\n  }\n\n  function parseModifiers(name) {\n    var match = name.match(modifierRE);\n    if (match) {\n      var _ret = function () {\n        var ret = {};\n        match.forEach(function (m) {\n          ret[m.slice(1)] = true;\n        });\n        return {\n          v: ret\n        };\n      }();\n\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n  }\n\n  function makeAttrsMap(attrs) {\n    var map = {};\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (\"development\" !== 'production' && map[attrs[i].name]) {\n        warn$1('duplicate attribute: ' + attrs[i].name);\n      }\n      map[attrs[i].name] = attrs[i].value;\n    }\n    return map;\n  }\n\n  function findPrevElement(children) {\n    var i = children.length;\n    while (i--) {\n      if (children[i].tag) return children[i];\n    }\n  }\n\n  function isForbiddenTag(el) {\n    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n\n  /* istanbul ignore next */\n  function guardIESVGBug(attrs) {\n    var res = [];\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n    return res;\n  }\n\n  var isStaticKey = void 0;\n  var isPlatformReservedTag = void 0;\n\n  var genStaticKeysCached = cached(genStaticKeys$1);\n\n  /**\n   * Goal of the optimizier: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n  function optimize(root, options) {\n    if (!root) return;\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || function () {\n      return false;\n    };\n    // first pass: mark all non-static nodes.\n    markStatic(root);\n    // second pass: mark static roots.\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));\n  }\n\n  function markStatic(node) {\n    node.static = isStatic(node);\n    if (node.type === 1) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic(child);\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n\n  function markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n      if (node.once || node.static) {\n        node.staticRoot = true;\n        node.staticInFor = isInFor;\n        return;\n      }\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], !!node.for);\n        }\n      }\n    }\n  }\n\n  function isStatic(node) {\n    if (node.type === 2) {\n      // expression\n      return false;\n    }\n    if (node.type === 3) {\n      // text\n      return true;\n    }\n    return !!(node.pre || !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    Object.keys(node).every(isStaticKey));\n  }\n\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\n\n  // keyCode aliases\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: 'if($event.target !== $event.currentTarget)return;'\n  };\n\n  function genHandlers(events, native) {\n    var res = native ? 'nativeOn:{' : 'on:{';\n    for (var name in events) {\n      res += '\"' + name + '\":' + genHandler(events[name]) + ',';\n    }\n    return res.slice(0, -1) + '}';\n  }\n\n  function genHandler(handler) {\n    if (!handler) {\n      return 'function(){}';\n    } else if (Array.isArray(handler)) {\n      return '[' + handler.map(genHandler).join(',') + ']';\n    } else if (!handler.modifiers) {\n      return simplePathRE.test(handler.value) ? handler.value : 'function($event){' + handler.value + '}';\n    } else {\n      var code = 'function($event){';\n      for (var key in handler.modifiers) {\n        code += modifierCode[key] || genKeyFilter(key);\n      }\n      var handlerCode = simplePathRE.test(handler.value) ? handler.value + '($event)' : handler.value;\n      return code + handlerCode + '}';\n    }\n  }\n\n  function genKeyFilter(key) {\n    var code = parseInt(key, 10) || // number keyCode\n    keyCodes[key] || // built-in alias\n    '_k(' + JSON.stringify(key) + ')'; // custom alias\n    if (Array.isArray(code)) {\n      return 'if(' + code.map(function (c) {\n        return '$event.keyCode!==' + c;\n      }).join('&&') + ')return;';\n    } else {\n      return 'if($event.keyCode!==' + code + ')return;';\n    }\n  }\n\n  function bind$1(el, dir) {\n    addHook(el, 'construct', '_b(n1,' + dir.value + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ')');\n  }\n\n  var baseDirectives = {\n    bind: bind$1,\n    cloak: noop\n  };\n\n  // configurable state\n  var warn$2 = void 0;\n  var transforms$1 = void 0;\n  var dataGenFns = void 0;\n  var platformDirectives$1 = void 0;\n  var staticRenderFns = void 0;\n  var currentOptions = void 0;\n\n  function generate(ast, options) {\n    // save previous staticRenderFns so generate calls can be nested\n    var prevStaticRenderFns = staticRenderFns;\n    var currentStaticRenderFns = staticRenderFns = [];\n    currentOptions = options;\n    warn$2 = options.warn || baseWarn;\n    transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n    dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    platformDirectives$1 = options.directives || {};\n    var code = ast ? genElement(ast) : '_h(\"div\")';\n    staticRenderFns = prevStaticRenderFns;\n    return {\n      render: 'with(this){return ' + code + '}',\n      staticRenderFns: currentStaticRenderFns\n    };\n  }\n\n  function genElement(el) {\n    if (el.staticRoot && !el.staticProcessed) {\n      // hoist static sub-trees out\n      el.staticProcessed = true;\n      staticRenderFns.push('with(this){return ' + genElement(el) + '}');\n      return '_m(' + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ')';\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el);\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el);\n    } else if (el.tag === 'template' && !el.slotTarget) {\n      return genChildren(el) || 'void 0';\n    } else if (el.tag === 'slot') {\n      return genSlot(el);\n    } else {\n      // component or element\n      var code = void 0;\n      if (el.component) {\n        code = genComponent(el);\n      } else {\n        var data = genData(el);\n        var children = el.inlineTemplate ? null : genChildren(el);\n        code = '_h(\\'' + el.tag + '\\'' + (data ? ',' + data : '' // data\n        ) + (children ? ',' + children : '' // children\n        ) + ')';\n      }\n      // module transforms\n      for (var i = 0; i < transforms$1.length; i++) {\n        code = transforms$1[i](el, code);\n      }\n      return code;\n    }\n  }\n\n  function genIf(el) {\n    var exp = el.if;\n    el.ifProcessed = true; // avoid recursion\n    return '(' + exp + ')?' + genElement(el) + ':' + genElse(el);\n  }\n\n  function genElse(el) {\n    return el.elseBlock ? genElement(el.elseBlock) : 'void 0';\n  }\n\n  function genFor(el) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? ',' + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? ',' + el.iterator2 : '';\n    el.forProcessed = true; // avoid recursion\n    return '(' + exp + ')&&_l((' + exp + '),' + ('function(' + alias + iterator1 + iterator2 + '){') + ('return ' + genElement(el)) + '})';\n  }\n\n  function genData(el) {\n    if (el.plain) {\n      return;\n    }\n\n    var data = '{';\n\n    // directives first.\n    // directives may mutate the el's other properties before they are generated.\n    var dirs = genDirectives(el);\n    if (dirs) data += dirs + ',';\n\n    // key\n    if (el.key) {\n      data += 'key:' + el.key + ',';\n    }\n    // ref\n    if (el.ref) {\n      data += 'ref:' + el.ref + ',';\n    }\n    if (el.refInFor) {\n      data += 'refInFor:true,';\n    }\n    // record original tag name for components using \"is\" attribute\n    if (el.component) {\n      data += 'tag:\"' + el.tag + '\",';\n    }\n    // slot target\n    if (el.slotTarget) {\n      data += 'slot:' + el.slotTarget + ',';\n    }\n    // module data generation functions\n    for (var i = 0; i < dataGenFns.length; i++) {\n      data += dataGenFns[i](el);\n    }\n    // v-show, used to avoid transition being applied\n    // since v-show takes it over\n    if (el.attrsMap['v-show']) {\n      data += 'show:true,';\n    }\n    // attributes\n    if (el.attrs) {\n      data += 'attrs:{' + genProps(el.attrs) + '},';\n    }\n    // DOM props\n    if (el.props) {\n      data += 'domProps:{' + genProps(el.props) + '},';\n    }\n    // hooks\n    if (el.hooks) {\n      data += 'hook:{' + genHooks(el.hooks) + '},';\n    }\n    // event handlers\n    if (el.events) {\n      data += genHandlers(el.events) + ',';\n    }\n    if (el.nativeEvents) {\n      data += genHandlers(el.nativeEvents, true) + ',';\n    }\n    // inline-template\n    if (el.inlineTemplate) {\n      var ast = el.children[0];\n      if (\"development\" !== 'production' && (el.children.length > 1 || ast.type !== 1)) {\n        warn$2('Inline-template components must have exactly one child element.');\n      }\n      if (ast.type === 1) {\n        var inlineRenderFns = generate(ast, currentOptions);\n        data += 'inlineTemplate:{render:function(){' + inlineRenderFns.render + '},staticRenderFns:[' + inlineRenderFns.staticRenderFns.map(function (code) {\n          return 'function(){' + code + '}';\n        }).join(',') + ']}';\n      }\n    }\n    return data.replace(/,$/, '') + '}';\n  }\n\n  function genDirectives(el) {\n    var dirs = el.directives;\n    if (!dirs) return;\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i = void 0,\n        l = void 0,\n        dir = void 0,\n        needRuntime = void 0;\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, warn$2);\n      }\n      if (needRuntime) {\n        hasRuntime = true;\n        res += '{name:\"' + dir.name + '\"' + (dir.value ? ',value:(' + dir.value + '),expression:' + JSON.stringify(dir.value) : '') + (dir.arg ? ',arg:\"' + dir.arg + '\"' : '') + (dir.modifiers ? ',modifiers:' + JSON.stringify(dir.modifiers) : '') + '},';\n      }\n    }\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']';\n    }\n  }\n\n  function genChildren(el) {\n    if (el.children.length) {\n      return '[' + el.children.map(genNode).join(',') + ']';\n    }\n  }\n\n  function genNode(node) {\n    if (node.type === 1) {\n      return genElement(node);\n    } else {\n      return genText(node);\n    }\n  }\n\n  function genText(text) {\n    return text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n    : JSON.stringify(text.text);\n  }\n\n  function genSlot(el) {\n    var slot = '$slots[' + (el.slotName || '\"default\"') + ']';\n    var children = genChildren(el);\n    return children ? '(' + slot + '||' + children + ')' : slot;\n  }\n\n  function genComponent(el) {\n    var children = genChildren(el);\n    return '_h(' + el.component + ',' + genData(el) + (children ? ',' + children : '') + ')';\n  }\n\n  function genProps(props) {\n    var res = '';\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      res += '\"' + prop.name + '\":' + prop.value + ',';\n    }\n    return res.slice(0, -1);\n  }\n\n  function genHooks(hooks) {\n    var res = '';\n    for (var _key in hooks) {\n      res += '\"' + _key + '\":function(n1,n2){' + hooks[_key].join(';') + '},';\n    }\n    return res.slice(0, -1);\n  }\n\n  /**\n   * Compile a template.\n   */\n  function compile$1(template, options) {\n    var ast = parse(template.trim(), options);\n    optimize(ast, options);\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    };\n  }\n\n  // operators like typeof, instanceof and in are allowed\n  var prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b');\n  // check valid identifier for v-for\n  var identRE = /[A-Za-z_$][\\w$]*/;\n  // strip strings in expressions\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n  // detect problematic expressions in a template\n  function detectErrors(ast) {\n    var errors = [];\n    if (ast) {\n      checkNode(ast, errors);\n    }\n    return errors;\n  }\n\n  function checkNode(node, errors) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n          if (value) {\n            if (name === 'v-for') {\n              checkFor(node, 'v-for=\"' + value + '\"', errors);\n            } else {\n              checkExpression(value, name + '=\"' + value + '\"', errors);\n            }\n          }\n        }\n      }\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], errors);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, errors);\n    }\n  }\n\n  function checkFor(node, text, errors) {\n    checkExpression(node.for || '', text, errors);\n    checkIdentifier(node.alias, 'v-for alias', text, errors);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n  }\n\n  function checkIdentifier(ident, type, text, errors) {\n    if (typeof ident === 'string' && !identRE.test(ident)) {\n      errors.push('- invalid ' + type + ' \"' + ident + '\" in expression: ' + text);\n    }\n  }\n\n  function checkExpression(exp, text, errors) {\n    try {\n      new Function('return ' + exp);\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n      if (keywordMatch) {\n        errors.push('- avoid using JavaScript keyword as property name: ' + ('\"' + keywordMatch[0] + '\" in expression ' + text));\n      } else {\n        errors.push('- invalid expression: ' + text);\n      }\n    }\n  }\n\n  function transformNode(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n    if (\"development\" !== 'production' && staticClass) {\n      var expression = parseText(staticClass, options.delimiters);\n      if (expression) {\n        warn('class=\"' + staticClass + '\": ' + 'Interpolation inside attributes has been deprecated. ' + 'Use v-bind or the colon shorthand instead.');\n      }\n    }\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData$1(el) {\n    var data = '';\n    if (el.staticClass) {\n      data += 'staticClass:' + el.staticClass + ',';\n    }\n    if (el.classBinding) {\n      data += 'class:' + el.classBinding + ',';\n    }\n    return data;\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData$1\n  };\n\n  function transformNode$1(el) {\n    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$2(el) {\n    return el.styleBinding ? 'style:(' + el.styleBinding + '),' : '';\n  }\n\n  var style$1 = {\n    transformNode: transformNode$1,\n    genData: genData$2\n  };\n\n  var modules$1 = [klass$1, style$1];\n\n  var warn$3 = void 0;\n\n  function model$1(el, dir, _warn) {\n    warn$3 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    if (el.tag === 'select') {\n      return genSelect(el, value);\n    } else {\n      switch (el.attrsMap.type) {\n        case 'checkbox':\n          genCheckboxModel(el, value);\n          break;\n        case 'radio':\n          genRadioModel(el, value);\n          break;\n        default:\n          return genDefaultModel(el, value, modifiers);\n      }\n    }\n  }\n\n  function genCheckboxModel(el, value) {\n    if (\"development\" !== 'production' && el.attrsMap.checked != null) {\n      warn$3('<' + el.tag + ' v-model=\"' + value + '\" checked>:\\n' + 'inline checked attributes will be ignored when using v-model. ' + 'Declare initial values in the component\\'s data option instead.');\n    }\n    var valueBinding = getBindingAttr(el, 'value');\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', 'Array.isArray(' + value + ')' + ('?(' + value + ').indexOf(' + valueBinding + ')>-1') + (':(' + value + ')===(' + trueValueBinding + ')'));\n    addHandler(el, 'change', 'var $$a=' + value + ',' + '$$el=$event.target,' + ('$$c=$$el.checked?(' + trueValueBinding + '):(' + falseValueBinding + ');') + 'if(Array.isArray($$a)){' + ('var $$v=' + valueBinding + ',') + '$$i=$$a.indexOf($$v);' + ('if($$c){$$i<0&&(' + value + '=$$a.concat($$v))}') + ('else{$$i>-1&&(' + value + '=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}') + ('}else{' + value + '=$$c}'));\n  }\n\n  function genRadioModel(el, value) {\n    if (\"development\" !== 'production' && el.attrsMap.checked != null) {\n      warn$3('<' + el.tag + ' v-model=\"' + value + '\" checked>:\\n' + 'inline checked attributes will be ignored when using v-model. ' + 'Declare initial values in the component\\'s data option instead.');\n    }\n    var valueBinding = getBindingAttr(el, 'value');\n    addProp(el, 'checked', '(' + value + ')===(' + valueBinding + ')');\n    addHandler(el, 'change', value + '=' + valueBinding);\n  }\n\n  function genDefaultModel(el, value, modifiers) {\n    if (true) {\n      if (el.tag === 'input' && el.attrsMap.value) {\n        warn$3('<' + el.tag + ' v-model=\"' + value + '\" value=\"' + el.attrsMap.value + '\">:\\n' + 'inline value attributes will be ignored when using v-model. ' + 'Declare initial values in the component\\'s data option instead.');\n      }\n      if (el.tag === 'textarea' && el.children.length) {\n        warn$3('<textarea v-model=\"' + value + '\">:\\n' + 'inline content inside <textarea> will be ignored when using v-model. ' + 'Declare initial values in the component\\'s data option instead.');\n      }\n    }\n\n    var type = el.attrsMap.type;\n\n    var _ref = modifiers || {};\n\n    var lazy = _ref.lazy;\n    var number = _ref.number;\n    var trim = _ref.trim;\n\n    var event = lazy || isIE && type === 'range' ? 'change' : 'input';\n    var needCompositionGuard = !lazy && type !== 'range';\n    var isNative = el.tag === 'input' || el.tag === 'textarea';\n\n    var valueExpression = isNative ? '$event.target.value' + (trim ? '.trim()' : '') : '$event';\n    var code = number || type === 'number' ? value + '=_n(' + valueExpression + ')' : value + '=' + valueExpression;\n    if (isNative && needCompositionGuard) {\n      code = 'if($event.target.composing)return;' + code;\n    }\n    addProp(el, 'value', isNative ? '_s(' + value + ')' : '(' + value + ')');\n    addHandler(el, event, code);\n    if (needCompositionGuard) {\n      // need runtime directive code to help with composition events\n      return true;\n    }\n  }\n\n  function genSelect(el, value) {\n    if (true) {\n      el.children.some(checkOptionWarning);\n    }\n    var code = value + '=Array.prototype.filter' + '.call($event.target.options,function(o){return o.selected})' + '.map(function(o){return \"_value\" in o ? o._value : o.value})' + (el.attrsMap.multiple == null ? '[0]' : '');\n    addHandler(el, 'change', code);\n    // need runtime to help with possible dynamically generated options\n    return true;\n  }\n\n  function checkOptionWarning(option) {\n    if (option.type === 1 && option.tag === 'option' && option.attrsMap.selected != null) {\n      var parentModel = option.parent && option.parent.type === 1 && option.parent.attrsMap['v-model'];\n      warn$3('<select v-model=\"' + parentModel + '\">:\\n' + 'inline selected attributes on <option> will be ignored when using v-model. ' + 'Declare initial values in the component\\'s data option instead.');\n      return true;\n    }\n  }\n\n  function text(el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', '_s(' + dir.value + ')');\n    }\n  }\n\n  function html(el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', '_s(' + dir.value + ')');\n    }\n  }\n\n  var directives$1 = {\n    model: model$1,\n    text: text,\n    html: html\n  };\n\n  var cache = Object.create(null);\n\n  var baseOptions = {\n    isIE: isIE,\n    expectHTML: true,\n    modules: modules$1,\n    staticKeys: genStaticKeys(modules$1),\n    directives: directives$1,\n    isReservedTag: isReservedTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    getTagNamespace: getTagNamespace,\n    isPreTag: isPreTag\n  };\n\n  function compile(template, options) {\n    options = options ? extend(extend({}, baseOptions), options) : baseOptions;\n    return compile$1(template, options);\n  }\n\n  function compileToFunctions(template, options, vm) {\n    var _warn = options && options.warn || warn;\n    // detect possible CSP restriction\n    /* istanbul ignore if */\n    if (true) {\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          _warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n        }\n      }\n    }\n    var key = options && options.delimiters ? String(options.delimiters) + template : template;\n    if (cache[key]) {\n      return cache[key];\n    }\n    var res = {};\n    var compiled = compile(template, options);\n    res.render = makeFunction(compiled.render);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);\n    }\n    if (true) {\n      if (res.render === noop || res.staticRenderFns.some(function (fn) {\n        return fn === noop;\n      })) {\n        _warn('failed to compile template:\\n\\n' + template + '\\n\\n' + detectErrors(compiled.ast).join('\\n') + '\\n\\n', vm);\n      }\n    }\n    return cache[key] = res;\n  }\n\n  function makeFunction(code) {\n    try {\n      return new Function(code);\n    } catch (e) {\n      return noop;\n    }\n  }\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML;\n  });\n\n  var mount = Vue.prototype.$mount;\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && query(el);\n    var options = this.$options;\n    // resolve template/el and convert to render function\n    if (!options.render) {\n      var template = options.template;\n      var isFromDOM = false;\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            isFromDOM = true;\n            template = idToTemplate(template);\n          }\n        } else if (template.nodeType) {\n          isFromDOM = true;\n          template = template.innerHTML;\n        } else {\n          if (true) {\n            warn('invalid template option:' + template, this);\n          }\n          return this;\n        }\n      } else if (el) {\n        isFromDOM = true;\n        template = getOuterHTML(el);\n      }\n      if (template) {\n        var _compileToFunctions = compileToFunctions(template, {\n          warn: warn,\n          isFromDOM: isFromDOM,\n          shouldDecodeTags: shouldDecodeTags,\n          delimiters: options.delimiters\n        }, this);\n\n        var render = _compileToFunctions.render;\n        var staticRenderFns = _compileToFunctions.staticRenderFns;\n\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n      }\n    }\n    return mount.call(this, el, hydrating);\n  };\n\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n  function getOuterHTML(el) {\n    if (el.outerHTML) {\n      return el.outerHTML;\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML;\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n\n  return Vue;\n\n}));\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmpzPzA1OTgiLCJ3ZWJwYWNrOi8vLz9kNDFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjAuMC1yYy4yXG4gKiAoYykgMjAxNC0yMDE2IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbC5WdWUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gICAqL1xuICBmdW5jdGlvbiBfdG9TdHJpbmcodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsID8gJycgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMikgOiBTdHJpbmcodmFsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICAgKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbCkge1xuICAgIHZhciBuID0gcGFyc2VGbG9hdCh2YWwsIDEwKTtcbiAgICByZXR1cm4gbiB8fCBuID09PSAwID8gbiA6IHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAgICogaXMgaW4gdGhhdCBtYXAuXG4gICAqL1xuICBmdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldO1xuICAgIH0gOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gbWFwW3ZhbF07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAgICovXG4gIHZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmUoYXJyLCBpdGVtKSB7XG4gICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAgICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIGZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAgICovXG4gIGZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZWQoZm4pIHtcbiAgICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBmdW5jdGlvbiBjYWNoZWRGbihzdHIpIHtcbiAgICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsbWl0ZWQgc3RyaW5nLlxuICAgKi9cbiAgdmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG4gIHZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7XG4gICAgICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnO1xuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAgICovXG4gIHZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICB9KTtcblxuICAvKipcbiAgICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAgICovXG4gIHZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG4gIHZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJykucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAgICovXG4gIGZ1bmN0aW9uIGJpbmQoZm4sIGN0eCkge1xuICAgIGZ1bmN0aW9uIGJvdW5kRm4oYSkge1xuICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGwgPyBsID4gMSA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKSA6IGZuLmNhbGwoY3R4LCBhKSA6IGZuLmNhbGwoY3R4KTtcbiAgICB9XG4gICAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICAgIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgICByZXR1cm4gYm91bmRGbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIGV4dGVuZCh0bywgX2Zyb20pIHtcbiAgICBmb3IgKHZhciBfa2V5IGluIF9mcm9tKSB7XG4gICAgICB0b1tfa2V5XSA9IF9mcm9tW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gdG87XG4gIH1cblxuICAvKipcbiAgICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gICAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAgICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gICAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gICAqL1xuICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkc7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIHRvT2JqZWN0KGFycikge1xuICAgIHZhciByZXMgPSBhcnJbMF0gfHwge307XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbaV0pIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gIC8qKlxuICAgKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICAgKi9cbiAgdmFyIG5vID0gZnVuY3Rpb24gbm8oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gICAqL1xuICBmdW5jdGlvbiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMpIHtcbiAgICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pO1xuICAgIH0sIFtdKS5qb2luKCcsJyk7XG4gIH1cblxuICB2YXIgY29uZmlnID0ge1xuICAgIC8qKlxuICAgICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgICAqL1xuICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAgICovXG4gICAgc2lsZW50OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAgICovXG4gICAgZGV2dG9vbHM6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICAgKi9cbiAgICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICAgKi9cbiAgICBpZ25vcmVkRWxlbWVudHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgICAqL1xuICAgIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgICAqL1xuICAgIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICAgKi9cbiAgICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICAgKi9cbiAgICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGFzc2V0IHR5cGVzIHRoYXQgYSBjb21wb25lbnQgY2FuIG93bi5cbiAgICAgKi9cbiAgICBfYXNzZXRUeXBlczogWydjb21wb25lbnQnLCAnZGlyZWN0aXZlJywgJ2ZpbHRlciddLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBsaWZlY3ljbGUgaG9va3MuXG4gICAgICovXG4gICAgX2xpZmVjeWNsZUhvb2tzOiBbJ2JlZm9yZUNyZWF0ZScsICdjcmVhdGVkJywgJ2JlZm9yZU1vdW50JywgJ21vdW50ZWQnLCAnYmVmb3JlVXBkYXRlJywgJ3VwZGF0ZWQnLCAnYmVmb3JlRGVzdHJveScsICdkZXN0cm95ZWQnLCAnYWN0aXZhdGVkJywgJ2RlYWN0aXZhdGVkJ10sXG5cbiAgICAvKipcbiAgICAgKiBNYXggY2lyY3VsYXIgdXBkYXRlcyBhbGxvd2VkIGluIGEgc2NoZWR1bGVyIGZsdXNoIGN5Y2xlLlxuICAgICAqL1xuICAgIF9tYXhVcGRhdGVDb3VudDogMTAwLFxuXG4gICAgLyoqXG4gICAgICogU2VydmVyIHJlbmRlcmluZz9cbiAgICAgKi9cbiAgICBfaXNTZXJ2ZXI6IFwiY2xpZW50XCIgPT09ICdzZXJ2ZXInXG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICAgKi9cbiAgZnVuY3Rpb24gaXNSZXNlcnZlZChzdHIpIHtcbiAgICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHByb3BlcnR5LlxuICAgKi9cbiAgZnVuY3Rpb24gZGVmKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWwsXG4gICAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICAgKi9cbiAgdmFyIGJhaWxSRSA9IC9bXlxcd1xcLlxcJF0vO1xuICBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICAgIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6IGZ1bmN0aW9uIHYob2JqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICghb2JqKSByZXR1cm47XG4gICAgICAgICAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0oKTtcblxuICAgICAgaWYgKHR5cGVvZiBfcmV0ID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICAgIH1cbiAgfVxuXG4gIC8qIGdsb2JhbCBNdXRhdGlvbk9ic2VydmVyICovXG4gIC8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xuICB2YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuICAvLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG4gIHZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93KSAhPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbiAgLy8gZGV0ZWN0IGRldnRvb2xzXG4gIHZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuICAvLyBVQSBzbmlmZmluZyBmb3Igd29ya2luZyBhcm91bmQgYnJvd3Nlci1zcGVjaWZpYyBxdWlya3NcbiAgdmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIHZhciBpc0lvcyA9IFVBICYmIC8oaXBob25lfGlwYWR8aXBvZHxpb3MpL2kudGVzdChVQSk7XG4gIHZhciBpb3NWZXJzaW9uTWF0Y2ggPSBVQSAmJiBpc0lvcyAmJiBVQS5tYXRjaCgvb3MgKFtcXGRfXSspLyk7XG4gIHZhciBpb3NWZXJzaW9uID0gaW9zVmVyc2lvbk1hdGNoICYmIGlvc1ZlcnNpb25NYXRjaFsxXS5zcGxpdCgnXycpO1xuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBpT1MgOS4zIFVJV2ViVmlld1xuICAvLyBkZXRlY3RpbmcgaXQgYnkgY2hlY2tpbmcgcHJlc2VuY2Ugb2YgSW5kZXhlZERCXG4gIC8vIHJlZiAjMzAyN1xuICB2YXIgaGFzTXV0YXRpb25PYnNlcnZlckJ1ZyA9IGlvc1ZlcnNpb24gJiYgTnVtYmVyKGlvc1ZlcnNpb25bMF0pID49IDkgJiYgTnVtYmVyKGlvc1ZlcnNpb25bMV0pID49IDMgJiYgIXdpbmRvdy5pbmRleGVkREI7XG5cbiAgLyoqXG4gICAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LiBJZGVhbGx5IHRoaXNcbiAgICogc2hvdWxkIGJlIGV4ZWN1dGVkIGFzIGEgbWljcm90YXNrLCBzbyB3ZSBsZXZlcmFnZVxuICAgKiBNdXRhdGlvbk9ic2VydmVyIGlmIGl0J3MgYXZhaWxhYmxlLCBhbmQgZmFsbGJhY2sgdG9cbiAgICogc2V0VGltZW91dCgwKS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICAgKi9cbiAgdmFyIG5leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciB0aW1lckZ1bmMgPSB2b2lkIDA7XG4gICAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyKCkge1xuICAgICAgcGVuZGluZyA9IGZhbHNlO1xuICAgICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29waWVzW2ldKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmICFoYXNNdXRhdGlvbk9ic2VydmVyQnVnKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY291bnRlciA9IDE7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiB0aW1lckZ1bmMoKSB7XG4gICAgICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgICAgIH07XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZWJwYWNrIGF0dGVtcHRzIHRvIGluamVjdCBhIHNoaW0gZm9yIHNldEltbWVkaWF0ZVxuICAgICAgLy8gaWYgaXQgaXMgdXNlZCBhcyBhIGdsb2JhbCwgc28gd2UgaGF2ZSB0byB3b3JrIGFyb3VuZCB0aGF0IHRvXG4gICAgICAvLyBhdm9pZCBidW5kbGluZyB1bm5lY2Vzc2FyeSBjb2RlLlxuICAgICAgdmFyIGNvbnRleHQgPSBpbkJyb3dzZXIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHt9O1xuICAgICAgdGltZXJGdW5jID0gY29udGV4dC5zZXRJbW1lZGlhdGUgfHwgc2V0VGltZW91dDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYiwgY3R4KSB7XG4gICAgICB2YXIgZnVuYyA9IGN0eCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSA6IGNiO1xuICAgICAgY2FsbGJhY2tzLnB1c2goZnVuYyk7XG4gICAgICBpZiAocGVuZGluZykgcmV0dXJuO1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIF9TZXQgPSB2b2lkIDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFNldC50b1N0cmluZygpKSkge1xuICAgIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICAgIF9TZXQgPSBTZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICAgIF9TZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTZXQoKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cblxuICAgICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgICB9O1xuXG4gICAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChrZXkpIHtcbiAgICAgICAgdGhpcy5zZXRba2V5XSA9IDE7XG4gICAgICB9O1xuXG4gICAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTZXQ7XG4gICAgfSgpO1xuICB9XG5cbiAgdmFyIGhhc1Byb3h5ID0gdm9pZCAwO1xuICB2YXIgcHJveHlIYW5kbGVycyA9IHZvaWQgMDtcbiAgdmFyIGluaXRQcm94eSA9IHZvaWQgMDtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICsgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICsgJ3JlcXVpcmUsX193ZWJwYWNrX3JlcXVpcmVfXycgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICAgICAgKTtcblxuICAgICAgaGFzUHJveHkgPSB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgICAgIHByb3h5SGFuZGxlcnMgPSB7XG4gICAgICAgIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICAgICAgdmFyIGlzQWxsb3dlZEdsb2JhbCA9IGFsbG93ZWRHbG9iYWxzKGtleSk7XG4gICAgICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZEdsb2JhbCkge1xuICAgICAgICAgICAgd2FybignUHJvcGVydHkgb3IgbWV0aG9kIFwiJyArIGtleSArICdcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0ICcgKyAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhICcgKyAncHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uJywgdGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICFpc0FsbG93ZWRHbG9iYWw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSh2bSkge1xuICAgICAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIHByb3h5SGFuZGxlcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCk7XG4gIH1cblxuICB2YXIgdWlkJDIgPSAwO1xuXG4gIC8qKlxuICAgKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAgICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAgICovXG5cbiAgdmFyIERlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXAoKSB7XG4gICAgICB0aGlzLmlkID0gdWlkJDIrKztcbiAgICAgIHRoaXMuc3VicyA9IFtdO1xuICAgIH1cblxuICAgIERlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViKHN1Yikge1xuICAgICAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbiAgICB9O1xuXG4gICAgRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIoc3ViKSB7XG4gICAgICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xuICAgIH07XG5cbiAgICBEZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCgpIHtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBEZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICAgIC8vIHN0YWJsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgICAgIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBEZXA7XG4gIH0oKTtcblxuICBEZXAudGFyZ2V0ID0gbnVsbDtcbiAgdmFyIHRhcmdldFN0YWNrID0gW107XG5cbiAgZnVuY3Rpb24gcHVzaFRhcmdldChfdGFyZ2V0KSB7XG4gICAgaWYgKERlcC50YXJnZXQpIHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7XG4gICAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BUYXJnZXQoKSB7XG4gICAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xuICB9XG5cbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBoYXMgPSB7fTtcbiAgdmFyIGNpcmN1bGFyID0ge307XG4gIHZhciB3YWl0aW5nID0gZmFsc2U7XG4gIHZhciBmbHVzaGluZyA9IGZhbHNlO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gICAqL1xuICBmdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlKCkge1xuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgaGFzID0ge307XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaXJjdWxhciA9IHt9O1xuICAgIH1cbiAgICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAgICovXG4gIGZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUoKSB7XG4gICAgZmx1c2hpbmcgPSB0cnVlO1xuXG4gICAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAgIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gICAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAgIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gICAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICAgIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmlkIC0gYi5pZDtcbiAgICB9KTtcblxuICAgIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAgIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgICAgaGFzW2lkXSA9IG51bGw7XG4gICAgICB3YXRjaGVyLnJ1bigpO1xuICAgICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IGNvbmZpZy5fbWF4VXBkYXRlQ291bnQpIHtcbiAgICAgICAgICB3YXJuKCdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArICh3YXRjaGVyLnVzZXIgPyAnaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXCInICsgd2F0Y2hlci5leHByZXNzaW9uICsgJ1wiJyA6ICdpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uJyksIHdhdGNoZXIudm0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGV2dG9vbCBob29rXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgICB9XG5cbiAgICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAgICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gICAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gcXVldWVXYXRjaGVyKHdhdGNoZXIpIHtcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLnNwbGljZShNYXRoLm1heChpLCBpbmRleCkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICAgIH1cbiAgICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdWlkJDEgPSAwO1xuXG4gIC8qKlxuICAgKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAgICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAgICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gICAqL1xuXG4gIHZhciBXYXRjaGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzNdO1xuXG4gICAgICB0aGlzLnZtID0gdm07XG4gICAgICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgICAgIC8vIG9wdGlvbnNcbiAgICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbi50b1N0cmluZygpO1xuICAgICAgdGhpcy5jYiA9IGNiO1xuICAgICAgdGhpcy5pZCA9ICsrdWlkJDE7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gICAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICAgIHRoaXMubmV3RGVwcyA9IFtdO1xuICAgICAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgICAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgICAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gICAgICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ZhaWxlZCB3YXRjaGluZyBwYXRoOiBcIicgKyBleHBPckZuICsgJ1wiICcgKyAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgKyAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhenkgPyB1bmRlZmluZWQgOiB0aGlzLmdldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAgICAgKi9cblxuXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcHVzaFRhcmdldCh0aGlzKTtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodGhpcy52bSwgdGhpcy52bSk7XG4gICAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBwb3BUYXJnZXQoKTtcbiAgICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKi9cblxuXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwKGRlcCkge1xuICAgICAgdmFyIGlkID0gZGVwLmlkO1xuICAgICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAgICAgKi9cblxuXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcygpIHtcbiAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICAgICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgICAgIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gICAgICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgICAgIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gICAgICB0bXAgPSB0aGlzLmRlcHM7XG4gICAgICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gICAgICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gICAgICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gICAgICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAgICAgKi9cblxuXG4gICAgV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh0aGlzLmxhenkpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAgICAgKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICAgICAqL1xuXG5cbiAgICBXYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4oKSB7XG4gICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgICAgaXNPYmplY3QodmFsdWUpIHx8IHRoaXMuZGVlcCkge1xuICAgICAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignRXJyb3IgaW4gd2F0Y2hlciBcIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCInLCB0aGlzLnZtKTtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZSwgdGhpcy52bSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICAgICAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAgICAgKi9cblxuXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSgpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAgICAgKi9cblxuXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kKCkge1xuICAgICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3ViY3JpYmVyIGxpc3QuXG4gICAgICovXG5cblxuICAgIFdhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24oKSB7XG4gICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgICAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQgb3IgaXMgcGVyZm9ybWluZyBhIHYtZm9yXG4gICAgICAgIC8vIHJlLXJlbmRlciAodGhlIHdhdGNoZXIgbGlzdCBpcyB0aGVuIGZpbHRlcmVkIGJ5IHYtZm9yKS5cbiAgICAgICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkICYmICF0aGlzLnZtLl92Rm9yUmVtb3ZpbmcpIHtcbiAgICAgICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFdhdGNoZXI7XG4gIH0oKTtcblxuICB2YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuICBmdW5jdGlvbiB0cmF2ZXJzZSh2YWwsIHNlZW4pIHtcbiAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAga2V5cyA9IHZvaWQgMDtcbiAgICBpZiAoIXNlZW4pIHtcbiAgICAgIHNlZW4gPSBzZWVuT2JqZWN0cztcbiAgICAgIHNlZW4uY2xlYXIoKTtcbiAgICB9XG4gICAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgICB2YXIgaXNPID0gaXNPYmplY3QodmFsKTtcbiAgICBpZiAoKGlzQSB8fCBpc08pICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgICAgaWYgKHZhbC5fX29iX18pIHtcbiAgICAgICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Vlbi5hZGQoZGVwSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNBKSB7XG4gICAgICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdHJhdmVyc2UodmFsW2ldLCBzZWVuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc08pIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbiAgdmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90bylcblxuICAvKipcbiAgICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gICAqL1xuICA7WydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICd1bnNoaWZ0JywgJ3NwbGljZScsICdzb3J0JywgJ3JldmVyc2UnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gICAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yKCkge1xuICAgICAgLy8gYXZvaWQgbGVha2luZyBhcmd1bWVudHM6XG4gICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgICAgdmFyIGluc2VydGVkID0gdm9pZCAwO1xuICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGluc2VydGVkKSBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpO1xuICAgICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfSk7XG5cbiAgdmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAgICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICAgKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gICAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICAgKi9cbiAgdmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gICAgc2hvdWxkQ29udmVydDogdHJ1ZSxcbiAgICBpc1NldHRpbmdQcm9wczogZmFsc2VcbiAgfTtcblxuICAvKipcbiAgICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICAgKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAgICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAgICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAgICovXG4gIHZhciBPYnNlcnZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBudW1iZXIgb2Ygdm1zIHRoYXQgaGFzIHRoaXMgb2JqZWN0IGFzIHJvb3QgJGRhdGFcblxuICAgIGZ1bmN0aW9uIE9ic2VydmVyKHZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgICAgIHRoaXMudm1Db3VudCA9IDA7XG4gICAgICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvID8gcHJvdG9BdWdtZW50IDogY29weUF1Z21lbnQ7XG4gICAgICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAgICAgKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAgICAgKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAgICAgKi9cblxuXG4gICAgT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrKG9iaikge1xuICAgICAgdmFyIHZhbCA9IHRoaXMudmFsdWU7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHZhbCwga2V5LCBvYmpba2V5XSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICAgICAqL1xuXG5cbiAgICBPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5KGl0ZW1zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIE9ic2VydmVyO1xuICB9KCk7XG5cbiAgLy8gaGVscGVyc1xuXG4gIC8qKlxuICAgKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gICAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gICAqL1xuICBmdW5jdGlvbiBwcm90b0F1Z21lbnQodGFyZ2V0LCBzcmMpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICAgIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICB9XG5cbiAgLyoqXG4gICAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICAgKiBoaWRkZW4gcHJvcGVydGllcy5cbiAgICpcbiAgICogaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICovXG4gIGZ1bmN0aW9uIGNvcHlBdWdtZW50KHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gICAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gICAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2ZSh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvYiA9IHZvaWQgMDtcbiAgICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICAgIH0gZWxzZSBpZiAob2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmICFjb25maWcuX2lzU2VydmVyICYmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiYgIXZhbHVlLl9pc1Z1ZSkge1xuICAgICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gb2I7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUob2JqLCBrZXksIHZhbCwgY3VzdG9tU2V0dGVyKSB7XG4gICAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICAgIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gICAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gICAgdmFyIGNoaWxkT2IgPSBvYnNlcnZlKHZhbCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlcigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGUsIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIGUgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyKG5ld1ZhbCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRPYiA9IG9ic2VydmUobmV3VmFsKTtcbiAgICAgICAgZGVwLm5vdGlmeSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICAgKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gICAqIGFscmVhZHkgZXhpc3QuXG4gICAqL1xuICBmdW5jdGlvbiBzZXQob2JqLCBrZXksIHZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIG9iai5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgaWYgKGhhc093bihvYmosIGtleSkpIHtcbiAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb2IgPSBvYmouX19vYl9fO1xuICAgIGlmIChvYmouX2lzVnVlIHx8IG9iICYmIG9iLnZtQ291bnQpIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgKyAnYXQgcnVudGltZSAtIGRlbGNhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb2IpIHtcbiAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWZpbmVSZWFjdGl2ZShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICBmdW5jdGlvbiBkZWwob2JqLCBrZXkpIHtcbiAgICB2YXIgb2IgPSBvYmouX19vYl9fO1xuICAgIGlmIChvYmouX2lzVnVlIHx8IG9iICYmIG9iLnZtQ291bnQpIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaGFzT3duKG9iaiwga2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgb2JqW2tleV07XG4gICAgaWYgKCFvYikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0U3RhdGUodm0pIHtcbiAgICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgICBpbml0UHJvcHModm0pO1xuICAgIGluaXREYXRhKHZtKTtcbiAgICBpbml0Q29tcHV0ZWQodm0pO1xuICAgIGluaXRNZXRob2RzKHZtKTtcbiAgICBpbml0V2F0Y2godm0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFByb3BzKHZtKSB7XG4gICAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gICAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YTtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgICAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAgICAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gICAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHZhbGlkYXRlUHJvcChrZXksIHByb3BzLCBwcm9wc0RhdGEsIHZtKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIW9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgd2FybignQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlICcgKyAnb3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gJyArICdJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wXFwncyAnICsgKCd2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcIicgKyBrZXkgKyAnXCInKSwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge31cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfbG9vcChpKTtcbiAgICAgIH1cbiAgICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdERhdGEodm0pIHtcbiAgICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gICAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicgPyBkYXRhLmNhbGwodm0pIDogZGF0YSB8fCB7fTtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSB7fTtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LicsIHZtKTtcbiAgICB9XG4gICAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gICAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXlzW2ldKSkge1xuICAgICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdUaGUgZGF0YSBwcm9wZXJ0eSBcIicgKyBrZXlzW2ldICsgJ1wiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiAnICsgJ1VzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC4nLCB2bSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm94eSh2bSwga2V5c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9ic2VydmUgZGF0YVxuICAgIG9ic2VydmUoZGF0YSk7XG4gICAgZGF0YS5fX29iX18gJiYgZGF0YS5fX29iX18udm1Db3VudCsrO1xuICB9XG5cbiAgdmFyIGNvbXB1dGVkU2hhcmVkRGVmaW5pdGlvbiA9IHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IG5vb3AsXG4gICAgc2V0OiBub29wXG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdENvbXB1dGVkKHZtKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gdm0uJG9wdGlvbnMuY29tcHV0ZWQ7XG4gICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICBmb3IgKHZhciBfa2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRbX2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbXB1dGVkU2hhcmVkRGVmaW5pdGlvbi5nZXQgPSBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZiwgdm0pO1xuICAgICAgICAgIGNvbXB1dGVkU2hhcmVkRGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXB1dGVkU2hhcmVkRGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldCA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlID8gbWFrZUNvbXB1dGVkR2V0dGVyKHVzZXJEZWYuZ2V0LCB2bSkgOiBiaW5kKHVzZXJEZWYuZ2V0LCB2bSkgOiBub29wO1xuICAgICAgICAgIGNvbXB1dGVkU2hhcmVkRGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCA/IGJpbmQodXNlckRlZi5zZXQsIHZtKSA6IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZtLCBfa2V5LCBjb21wdXRlZFNoYXJlZERlZmluaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VDb21wdXRlZEdldHRlcihnZXR0ZXIsIG93bmVyKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBub29wLCB7XG4gICAgICBsYXp5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbml0TWV0aG9kcyh2bSkge1xuICAgIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgICBpZiAobWV0aG9kcykge1xuICAgICAgZm9yICh2YXIgX2tleTIgaW4gbWV0aG9kcykge1xuICAgICAgICB2bVtfa2V5Ml0gPSBiaW5kKG1ldGhvZHNbX2tleTJdLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFdhdGNoKHZtKSB7XG4gICAgdmFyIHdhdGNoID0gdm0uJG9wdGlvbnMud2F0Y2g7XG4gICAgaWYgKHdhdGNoKSB7XG4gICAgICBmb3IgKHZhciBfa2V5MyBpbiB3YXRjaCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHdhdGNoW19rZXkzXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIF9rZXkzLCBoYW5kbGVyW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwgX2tleTMsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2b2lkIDA7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICAgIH1cbiAgICB2bS4kd2F0Y2goa2V5LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRlTWl4aW4oVnVlKSB7XG4gICAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gICAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gICAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICAgIHZhciBkYXRhRGVmID0ge307XG4gICAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9O1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgICB3YXJuKCdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsIHRoaXMpO1xuICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuXG4gICAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuKCkge1xuICAgICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwcm94eSh2bSwga2V5KSB7XG4gICAgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2bSwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBwcm94eUdldHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gdm0uX2RhdGFba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBwcm94eVNldHRlcih2YWwpIHtcbiAgICAgICAgICB2bS5fZGF0YVtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB2YXIgVk5vZGUgPSAvLyBob2lzdGVkIHN0YXRpYyBub2RlXG4gIC8vIGNvbXBvZW5udCBwbGFjZWhvbGRlciBub2RlXG4gIC8vIHJlbmRlcmVkIGluIHRoaXMgY29tcG9uZW50J3Mgc2NvcGVcbiAgZnVuY3Rpb24gVk5vZGUodGFnLCBkYXRhLCBjaGlsZHJlbiwgdGV4dCwgZWxtLCBucywgY29udGV4dCwgY29tcG9uZW50T3B0aW9ucykge1xuICAgIHRoaXMudGFnID0gdGFnO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5lbG0gPSBlbG07XG4gICAgdGhpcy5ucyA9IG5zO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICAgIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gICAgdGhpcy5jaGlsZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJhdyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gICAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgICAvLyBhcHBseSBjb25zdHJ1Y3QgaG9vay5cbiAgICAvLyB0aGlzIGlzIGFwcGxpZWQgZHVyaW5nIHJlbmRlciwgYmVmb3JlIHBhdGNoIGhhcHBlbnMuXG4gICAgLy8gdW5saWtlIG90aGVyIGhvb2tzLCB0aGlzIGlzIGFwcGxpZWQgb24gYm90aCBjbGllbnQgYW5kIHNlcnZlci5cbiAgICB2YXIgY29uc3RydWN0SG9vayA9IGRhdGEgJiYgZGF0YS5ob29rICYmIGRhdGEuaG9vay5jb25zdHJ1Y3Q7XG4gICAgaWYgKGNvbnN0cnVjdEhvb2spIHtcbiAgICAgIGNvbnN0cnVjdEhvb2sodGhpcyk7XG4gICAgfVxuICB9IC8vIG5lY2Vzc2FyeSBmb3IgZW50ZXIgdHJhbnNpdGlvbiBjaGVja1xuICAvLyBjb250YWlucyByYXcgSFRNTFxuICAvLyBjb21wb25lbnQgaW5zdGFuY2VcbiAgO1xuXG4gIHZhciBlbXB0eVZOb2RlID0gZnVuY3Rpb24gZW1wdHlWTm9kZSgpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICAgIG5vZGUudGV4dCA9ICcnO1xuICAgIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbiwgbnMpIHtcbiAgICBpZiAoaXNQcmltaXRpdmUoY2hpbGRyZW4pKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gIG5lc3RlZFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQ2hpbGRyZW4oYywgbnMpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QudGV4dCkge1xuICAgICAgICAgICAgbGFzdC50ZXh0ICs9IFN0cmluZyhjKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYyBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgICAgICAgaWYgKGMudGV4dCAmJiBsYXN0ICYmIGxhc3QudGV4dCkge1xuICAgICAgICAgICAgbGFzdC50ZXh0ICs9IGMudGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbmFtZXNwYWNlXG4gICAgICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgICAgYXBwbHlOUyhjLCBucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHZhbCkge1xuICAgIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlOUyh2bm9kZSwgbnMpIHtcbiAgICBpZiAodm5vZGUudGFnICYmICF2bm9kZS5ucykge1xuICAgICAgdm5vZGUubnMgPSBucztcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGFwcGx5TlModm5vZGUuY2hpbGRyZW5baV0sIG5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYyAmJiBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgfSlbMF07XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVZOb2RlSG9vayhkZWYsIGtleSwgaG9vaykge1xuICAgIHZhciBvbGRIb29rID0gZGVmW2tleV07XG4gICAgaWYgKG9sZEhvb2spIHtcbiAgICAgIGRlZltrZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbGRIb29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZltrZXldID0gaG9vaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQsIHJlbW92ZSkge1xuICAgIHZhciBuYW1lID0gdm9pZCAwLFxuICAgICAgICBjdXIgPSB2b2lkIDAsXG4gICAgICAgIG9sZCA9IHZvaWQgMCxcbiAgICAgICAgZm4gPSB2b2lkIDAsXG4gICAgICAgIGV2ZW50ID0gdm9pZCAwLFxuICAgICAgICBjYXB0dXJlID0gdm9pZCAwO1xuICAgIGZvciAobmFtZSBpbiBvbikge1xuICAgICAgY3VyID0gb25bbmFtZV07XG4gICAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICAgIGlmICghY3VyKSB7XG4gICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0hhbmRsZXIgZm9yIGV2ZW50IFwiJyArIG5hbWUgKyAnXCIgaXMgdW5kZWZpbmVkLicpO1xuICAgICAgfSBlbHNlIGlmICghb2xkKSB7XG4gICAgICAgIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICAgICAgICBldmVudCA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VyKSkge1xuICAgICAgICAgIGFkZChldmVudCwgY3VyLmludm9rZXIgPSBhcnJJbnZva2VyKGN1ciksIGNhcHR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZuID0gY3VyO1xuICAgICAgICAgIGN1ciA9IG9uW25hbWVdID0ge307XG4gICAgICAgICAgY3VyLmZuID0gZm47XG4gICAgICAgICAgYWRkKGV2ZW50LCBjdXIuaW52b2tlciA9IGZuSW52b2tlcihjdXIpLCBjYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9sZCkpIHtcbiAgICAgICAgb2xkLmxlbmd0aCA9IGN1ci5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2xkW2ldID0gY3VyW2ldO1xuICAgICAgICB9b25bbmFtZV0gPSBvbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGQuZm4gPSBjdXI7XG4gICAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICAgIGlmICghb25bbmFtZV0pIHtcbiAgICAgICAgZXZlbnQgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gICAgICAgIHJlbW92ZShldmVudCwgb2xkT25bbmFtZV0uaW52b2tlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXJySW52b2tlcihhcnIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgc2luZ2xlID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNpbmdsZSA/IGFycltpXShldikgOiBhcnJbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZm5JbnZva2VyKG8pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgc2luZ2xlID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICAgIHNpbmdsZSA/IG8uZm4oZXYpIDogby5mbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGluaXRMaWZlY3ljbGUodm0pIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gICAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gICAgfVxuXG4gICAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gICAgdm0uJGNoaWxkcmVuID0gW107XG4gICAgdm0uJHJlZnMgPSB7fTtcblxuICAgIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpZmVjeWNsZU1peGluKFZ1ZSkge1xuICAgIFZ1ZS5wcm90b3R5cGUuX21vdW50ID0gZnVuY3Rpb24gKGVsLCBoeWRyYXRpbmcpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICB2bS4kZWwgPSBlbDtcbiAgICAgIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGVtcHR5Vk5vZGU7XG4gICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICh2bS4kb3B0aW9ucy50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybignWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArICdvcHRpb24gaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICsgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJywgdm0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXJuKCdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJywgdm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuICAgICAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICAgIH0sIG5vb3ApO1xuICAgICAgaHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAvLyByb290IGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAgICAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtO1xuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgICB9XG4gICAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgICAgaWYgKHByZXZFbCkge1xuICAgICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodm0uJGVsKSB7XG4gICAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgICB9XG4gICAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICAgIH1cbiAgICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLl91cGRhdGVGcm9tUGFyZW50ID0gZnVuY3Rpb24gKHByb3BzRGF0YSwgbGlzdGVuZXJzLCBwYXJlbnRWbm9kZSwgcmVuZGVyQ2hpbGRyZW4pIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICB2YXIgaGFzQ2hpbGRyZW4gPSAhISh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgcmVuZGVyQ2hpbGRyZW4pO1xuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gICAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcbiAgICAgIC8vIHVwZGF0ZSBwcm9wc1xuICAgICAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgICAgIHZtW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgICAgICB2bS5fdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gICAgICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuKTtcbiAgICAgICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgICB9XG4gICAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgICB9XG4gICAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgICAgfVxuICAgICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgICB2bS4kb2ZmKCk7XG4gICAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICAgIGlmICh2bS4kZWwpIHtcbiAgICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsSG9vayh2bSwgaG9vaykge1xuICAgIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxuXG4gIHZhciBob29rcyA9IHsgaW5pdDogaW5pdCwgcHJlcGF0Y2g6IHByZXBhdGNoLCBpbnNlcnQ6IGluc2VydCwgZGVzdHJveTogZGVzdHJveSB9O1xuICB2YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoaG9va3MpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKSB7XG4gICAgaWYgKCFDdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgICBDdG9yID0gVnVlLmV4dGVuZChDdG9yKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiAnICsgQ3RvciwgY29udGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYXN5bmMgY29tcG9uZW50XG4gICAgaWYgKCFDdG9yLmNpZCkge1xuICAgICAgaWYgKEN0b3IucmVzb2x2ZWQpIHtcbiAgICAgICAgQ3RvciA9IEN0b3IucmVzb2x2ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KEN0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBpdCdzIG9rIHRvIHF1ZXVlIHRoaXMgb24gZXZlcnkgcmVuZGVyIGJlY2F1c2VcbiAgICAgICAgICAvLyAkZm9yY2VVcGRhdGUgaXMgYnVmZmVyZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAgICAgICAgICBjb250ZXh0LiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFDdG9yKSB7XG4gICAgICAgICAgLy8gcmV0dXJuIG5vdGhpbmcgaWYgdGhpcyBpcyBpbmRlZWQgYW4gYXN5bmMgY29tcG9uZW50XG4gICAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgcGFyZW50IHVwZGF0ZS5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAgIC8vIGV4dHJhY3QgcHJvcHNcbiAgICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzKGRhdGEsIEN0b3IpO1xuXG4gICAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICBpZiAoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICAgICAgICBpZiAocHJvcE9wdGlvbnMpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wT3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2OiBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgY29udGV4dC4kY3JlYXRlRWxlbWVudCwge1xuICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHBhcmVudDogY29udGV4dCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbiksXG4gICAgICAgICAgICBzbG90czogZnVuY3Rpb24gc2xvdHMoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgX3JldCA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICB9XG5cbiAgICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAgIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gICAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gICAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICAgIGlmIChDdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnNcbiAgICAgIGRhdGEgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gICAgbWVyZ2VIb29rcyhkYXRhKTtcblxuICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gICAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gICAgdmFyIHZub2RlID0gbmV3IFZOb2RlKCd2dWUtY29tcG9uZW50LScgKyBDdG9yLmNpZCArIChuYW1lID8gJy0nICsgbmFtZSA6ICcnKSwgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LCB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50IC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICApIHtcbiAgICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW5cbiAgICB9O1xuICAgIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0KHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICBpZiAoIXZub2RlLmNoaWxkIHx8IHZub2RlLmNoaWxkLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGQgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKHZub2RlLCBhY3RpdmVJbnN0YW5jZSk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhdGNoKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZCA9IG9sZFZub2RlLmNoaWxkO1xuICAgIGNoaWxkLl91cGRhdGVGcm9tUGFyZW50KG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLmNoaWxkLl9pc01vdW50ZWQpIHtcbiAgICAgIHZub2RlLmNoaWxkLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2sodm5vZGUuY2hpbGQsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgdm5vZGUuY2hpbGQuX2luYWN0aXZlID0gZmFsc2U7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jaGlsZCwgJ2FjdGl2YXRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3kodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLmNoaWxkLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICB2bm9kZS5jaGlsZC4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuY2hpbGQuX2luYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgY2FsbEhvb2sodm5vZGUuY2hpbGQsICdkZWFjdGl2YXRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudChmYWN0b3J5LCBjYikge1xuICAgIGlmIChmYWN0b3J5LnJlcXVlc3RlZCkge1xuICAgICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9yZXQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmYWN0b3J5LnJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdO1xuICAgICAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgICAgIGZhY3RvcnkoXG4gICAgICAgIC8vIHJlc29sdmVcbiAgICAgICAgZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICAgICAgICByZXMgPSBWdWUuZXh0ZW5kKHJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IHJlcztcbiAgICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgY2JzW2ldKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyByZWplY3RcbiAgICAgICAgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogJyArIGZhY3RvcnkgKyAocmVhc29uID8gJ1xcblJlYXNvbjogJyArIHJlYXNvbiA6ICcnKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzeW5jID0gZmFsc2U7XG4gICAgICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2OiBmYWN0b3J5LnJlc29sdmVkXG4gICAgICAgIH07XG4gICAgICB9KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgX3JldDIgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0Mi52O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RQcm9wcyhkYXRhLCBDdG9yKSB7XG4gICAgLy8gd2UgYXJlIG9ubHkgZXh0cmF0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICAgIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgICBpZiAoIXByb3BPcHRpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICAgIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gICAgdmFyIGRvbVByb3BzID0gZGF0YS5kb21Qcm9wcztcblxuICAgIGlmIChhdHRycyB8fCBwcm9wcyB8fCBkb21Qcm9wcykge1xuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fCBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXkpIHx8IGNoZWNrUHJvcChyZXMsIGRvbVByb3BzLCBrZXksIGFsdEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Byb3AocmVzLCBoYXNoLCBrZXksIGFsdEtleSwgcHJlc2VydmUpIHtcbiAgICBpZiAoaGFzaCkge1xuICAgICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUhvb2tzKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEuaG9vaykge1xuICAgICAgZGF0YS5ob29rID0ge307XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICAgIHZhciBvdXJzID0gaG9va3Nba2V5XTtcbiAgICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUhvb2skMShhLCBiKSB7XG4gICAgLy8gc2luY2UgYWxsIGhvb2tzIGhhdmUgYXQgbW9zdCB0d28gYXJncywgdXNlIGZpeGVkIGFyZ3NcbiAgICAvLyB0byBhdm9pZCBoYXZpbmcgdG8gdXNlIGZuLmFwcGx5KCkuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfLCBfXykge1xuICAgICAgYShfLCBfXyk7XG4gICAgICBiKF8sIF9fKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2VcbiAgLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBkYXRhLCBjaGlsZHJlbikge1xuICAgIGlmIChkYXRhICYmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JykpIHtcbiAgICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0byB1c2UgcmVhbCBpbnN0YW5jZSBpbnN0ZWFkIG9mIHByb3h5IGFzIGNvbnRleHRcbiAgICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQodGhpcy5fc2VsZiwgdGFnLCBkYXRhLCBjaGlsZHJlbik7XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuKSB7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5fX29iX18pIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0F2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6ICcgKyBKU09OLnN0cmluZ2lmeShkYXRhKSArICdcXG4nICsgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRhZykge1xuICAgICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgICAgcmV0dXJuIGVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgQ3RvciA9IHZvaWQgMDtcbiAgICAgIHZhciBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICAgIHJldHVybiBuZXcgVk5vZGUodGFnLCBkYXRhLCBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbiwgbnMpLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbnMsIGNvbnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkge1xuICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgICByZXR1cm4gbmV3IFZOb2RlKHRhZywgZGF0YSwgbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4sIG5zKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5zLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFJlbmRlcih2bSkge1xuICAgIHZtLiR2bm9kZSA9IG51bGw7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gICAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgICB2bS5fc3RhdGljVHJlZXMgPSBudWxsO1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4pO1xuICAgIC8vIGJpbmQgdGhlIHB1YmxpYyBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAgIHZtLiRjcmVhdGVFbGVtZW50ID0gYmluZChjcmVhdGVFbGVtZW50LCB2bSk7XG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlck1peGluKFZ1ZSkge1xuICAgIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICBuZXh0VGljayhmbiwgdGhpcyk7XG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICB2YXIgX3ZtJCRvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgcmVuZGVyID0gX3ZtJCRvcHRpb25zLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSBfdm0kJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgdmFyIF9wYXJlbnRWbm9kZSA9IF92bSQkb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG5cblxuICAgICAgaWYgKHN0YXRpY1JlbmRlckZucyAmJiAhdm0uX3N0YXRpY1RyZWVzKSB7XG4gICAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgICAgfVxuICAgICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgICAvLyByZW5kZXIgc2VsZlxuICAgICAgdmFyIHZub2RlID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignRXJyb3Igd2hlbiByZW5kZXJpbmcgJyArIGZvcm1hdENvbXBvbmVudE5hbWUodm0pICsgJzonKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgICAgICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlLCB2bSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICAgIHdhcm4oJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICsgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsIHZtKTtcbiAgICAgICAgfVxuICAgICAgICB2bm9kZSA9IGVtcHR5Vk5vZGUoKTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCBwYXJlbnRcbiAgICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9O1xuXG4gICAgLy8gc2hvcnRoYW5kcyB1c2VkIGluIHJlbmRlciBmdW5jdGlvbnNcbiAgICBWdWUucHJvdG90eXBlLl9oID0gY3JlYXRlRWxlbWVudDtcbiAgICAvLyB0b1N0cmluZyBmb3IgbXVzdGFjaGVzXG4gICAgVnVlLnByb3RvdHlwZS5fcyA9IF90b1N0cmluZztcbiAgICAvLyBudW1iZXIgY29udmVyc2lvblxuICAgIFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcblxuICAgIC8vIHJlbmRlciBzdGF0aWMgdHJlZSBieSBpbmRleFxuICAgIFZ1ZS5wcm90b3R5cGUuX20gPSBmdW5jdGlvbiByZW5kZXJTdGF0aWMoaW5kZXgsIGlzSW5Gb3IpIHtcbiAgICAgIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xuICAgICAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gICAgICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBpbmRlbnRpdHkuXG4gICAgICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH1cbiAgICAgIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgICAgIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0cmVlW2ldLmlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICB0cmVlW2ldLmtleSA9ICdfX3N0YXRpY19fJyArIGluZGV4ICsgJ18nICsgaTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJlZS5pc1N0YXRpYyA9IHRydWU7XG4gICAgICAgIHRyZWUua2V5ID0gJ19fc3RhdGljX18nICsgaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9O1xuXG4gICAgLy8gZmlsdGVyIHJlc29sdXRpb24gaGVscGVyXG4gICAgdmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkoXykge1xuICAgICAgcmV0dXJuIF87XG4gICAgfTtcbiAgICBWdWUucHJvdG90eXBlLl9mID0gZnVuY3Rpb24gcmVzb2x2ZUZpbHRlcihpZCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eTtcbiAgICB9O1xuXG4gICAgLy8gcmVuZGVyIHYtZm9yXG4gICAgVnVlLnByb3RvdHlwZS5fbCA9IGZ1bmN0aW9uIHJlbmRlckxpc3QodmFsLCByZW5kZXIpIHtcbiAgICAgIHZhciByZXQgPSB2b2lkIDAsXG4gICAgICAgICAgaSA9IHZvaWQgMCxcbiAgICAgICAgICBsID0gdm9pZCAwLFxuICAgICAgICAgIGtleXMgPSB2b2lkIDAsXG4gICAgICAgICAga2V5ID0gdm9pZCAwO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8vIGFwcGx5IHYtYmluZCBvYmplY3RcbiAgICBWdWUucHJvdG90eXBlLl9iID0gZnVuY3Rpb24gYmluZFByb3BzKHZub2RlLCB2YWx1ZSwgYXNQcm9wKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgICBmb3IgKHZhciBfa2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoX2tleSA9PT0gJ2NsYXNzJyB8fCBfa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAgIGRhdGFbX2tleV0gPSB2YWx1ZVtfa2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcChfa2V5KSA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSkgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICAgICAgICBoYXNoW19rZXldID0gdmFsdWVbX2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGV4cG9zZSB2LW9uIGtleUNvZGVzXG4gICAgVnVlLnByb3RvdHlwZS5fayA9IGZ1bmN0aW9uIGdldEtleUNvZGVzKGtleSkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5rZXlDb2Rlc1trZXldO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4pIHtcbiAgICB2YXIgc2xvdHMgPSB7fTtcbiAgICBpZiAoIXJlbmRlckNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gc2xvdHM7XG4gICAgfVxuICAgIHZhciBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKHJlbmRlckNoaWxkcmVuKSB8fCBbXTtcbiAgICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgICB2YXIgbmFtZSA9IHZvaWQgMCxcbiAgICAgICAgY2hpbGQgPSB2b2lkIDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQuZGF0YSAmJiAobmFtZSA9IGNoaWxkLmRhdGEuc2xvdCkpIHtcbiAgICAgICAgZGVsZXRlIGNoaWxkLmRhdGEuc2xvdDtcbiAgICAgICAgdmFyIHNsb3QgPSBzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSk7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZ25vcmUgc2luZ2xlIHdoaXRlc3BhY2VcbiAgICBpZiAoZGVmYXVsdFNsb3QubGVuZ3RoICYmICEoZGVmYXVsdFNsb3QubGVuZ3RoID09PSAxICYmIGRlZmF1bHRTbG90WzBdLnRleHQgPT09ICcgJykpIHtcbiAgICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3RzO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEV2ZW50cyh2bSkge1xuICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICAgIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZhciBvbiA9IGJpbmQodm0uJG9uLCB2bSk7XG4gICAgdmFyIG9mZiA9IGJpbmQodm0uJG9mZiwgdm0pO1xuICAgIHZtLl91cGRhdGVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpIHtcbiAgICAgIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgb24sIG9mZik7XG4gICAgfTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICB2bS5fdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXZlbnRzTWl4aW4oVnVlKSB7XG4gICAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzOyh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgcmV0dXJuIHZtO1xuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgb24uZm4gPSBmbjtcbiAgICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgICAgcmV0dXJuIHZtO1xuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgLy8gYWxsXG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHJldHVybiB2bTtcbiAgICAgIH1cbiAgICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgICBpZiAoIWNicykge1xuICAgICAgICByZXR1cm4gdm07XG4gICAgICB9XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICAgIHJldHVybiB2bTtcbiAgICAgIH1cbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYiA9IHZvaWQgMDtcbiAgICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY2IgPSBjYnNbaV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZtO1xuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgICAgaWYgKGNicykge1xuICAgICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2bTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHVpZCA9IDA7XG5cbiAgZnVuY3Rpb24gaW5pdE1peGluKFZ1ZSkge1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIC8vIGEgdWlkXG4gICAgICB2bS5fdWlkID0gdWlkKys7XG4gICAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtKSwgb3B0aW9ucyB8fCB7fSwgdm0pO1xuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpbml0UHJveHkodm0pO1xuICAgICAgfSBlbHNlIHt9XG4gICAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgICB2bS5fc2VsZiA9IHZtO1xuICAgICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgICBpbml0RXZlbnRzKHZtKTtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgICBpbml0U3RhdGUodm0pO1xuICAgICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG4gICAgICBpbml0UmVuZGVyKHZtKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKSB7XG4gICAgICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtKSk7XG4gICAgICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICAgICAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICAgIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gICAgICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgICAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgICAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgICAgIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICAgIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgICAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgICAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0pIHtcbiAgICAgIHZhciBDdG9yID0gdm0uY29uc3RydWN0b3I7XG4gICAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICAgIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgICAgIHZhciBzdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyLm9wdGlvbnM7XG4gICAgICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICAgICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWRcbiAgICAgICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBWdWUob3B0aW9ucykge1xuICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gIH1cblxuICBpbml0TWl4aW4oVnVlKTtcbiAgc3RhdGVNaXhpbihWdWUpO1xuICBldmVudHNNaXhpbihWdWUpO1xuICBsaWZlY3ljbGVNaXhpbihWdWUpO1xuICByZW5kZXJNaXhpbihWdWUpO1xuXG4gIHZhciB3YXJuID0gdm9pZCAwO1xuICB2YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IHZvaWQgMDtcblxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgIHdhcm4gPSBmdW5jdGlvbiB3YXJuKG1zZywgdm0pIHtcbiAgICAgICAgaWYgKGhhc0NvbnNvbGUgJiYgIWNvbmZpZy5zaWxlbnQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVnVlIHdhcm5dOiAnICsgbXNnICsgJyAnICsgKHZtID8gZm9ybWF0TG9jYXRpb24oZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpIDogJycpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUodm0pIHtcbiAgICAgICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgICAgIHJldHVybiAncm9vdCBpbnN0YW5jZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB2bS5faXNWdWUgPyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWcgOiB2bS5uYW1lO1xuICAgICAgICByZXR1cm4gbmFtZSA/ICdjb21wb25lbnQgPCcgKyBuYW1lICsgJz4nIDogJ2Fub255bW91cyBjb21wb25lbnQnO1xuICAgICAgfTtcblxuICAgICAgdmFyIGZvcm1hdExvY2F0aW9uID0gZnVuY3Rpb24gZm9ybWF0TG9jYXRpb24oc3RyKSB7XG4gICAgICAgIGlmIChzdHIgPT09ICdhbm9ueW1vdXMgY29tcG9uZW50Jykge1xuICAgICAgICAgIHN0ciArPSAnIC0gdXNlIHRoZSBcIm5hbWVcIiBvcHRpb24gZm9yIGJldHRlciBkZWJ1Z2dpbmcgbWVzc2FnZXMuKSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcoZm91bmQgaW4gJyArIHN0ciArICcpJztcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gICAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gICAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICAgKi9cbiAgdmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAgICovXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgICAgaWYgKCF2bSkge1xuICAgICAgICB3YXJuKCdvcHRpb24gXCInICsga2V5ICsgJ1wiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlICcgKyAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZCk7XG4gICAgfTtcblxuICAgIHN0cmF0cy5uYW1lID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtKSB7XG4gICAgICBpZiAodm0pIHtcbiAgICAgICAgd2Fybignb3B0aW9ucyBcIm5hbWVcIiBjYW4gb25seSBiZSB1c2VkIGFzIGEgY29tcG9uZW50IGRlZmluaXRpb24gb3B0aW9uLCAnICsgJ25vdCBkdXJpbmcgaW5zdGFuY2UgY3JlYXRpb24uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZURhdGEodG8sIGZyb20pIHtcbiAgICB2YXIga2V5ID0gdm9pZCAwLFxuICAgICAgICB0b1ZhbCA9IHZvaWQgMCxcbiAgICAgICAgZnJvbVZhbCA9IHZvaWQgMDtcbiAgICBmb3IgKGtleSBpbiBmcm9tKSB7XG4gICAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh0b1ZhbCkgJiYgaXNPYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xuICB9XG5cbiAgLyoqXG4gICAqIERhdGFcbiAgICovXG4gIHN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArICdkZWZpbml0aW9ucy4nLCB2bSk7XG4gICAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICB9XG4gICAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgICB9XG4gICAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoY2hpbGRWYWwuY2FsbCh0aGlzKSwgcGFyZW50VmFsLmNhbGwodGhpcykpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuKCkge1xuICAgICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh2bSkgOiBjaGlsZFZhbDtcbiAgICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHZtKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSG9va3MgYW5kIHBhcmFtIGF0dHJpYnV0ZXMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZUhvb2socGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBjaGlsZFZhbCA/IHBhcmVudFZhbCA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbCkgPyBjaGlsZFZhbCA6IFtjaGlsZFZhbF0gOiBwYXJlbnRWYWw7XG4gIH1cblxuICBjb25maWcuX2xpZmVjeWNsZUhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBc3NldHNcbiAgICpcbiAgICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICAgKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gICAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VBc3NldHMocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgICByZXR1cm4gY2hpbGRWYWwgPyBleHRlbmQocmVzLCBjaGlsZFZhbCkgOiByZXM7XG4gIH1cblxuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xuICB9KTtcblxuICAvKipcbiAgICogV2F0Y2hlcnMuXG4gICAqXG4gICAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAgICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gICAqL1xuICBzdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gICAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbDtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgICB9XG4gICAgICByZXRba2V5XSA9IHBhcmVudCA/IHBhcmVudC5jb25jYXQoY2hpbGQpIDogW2NoaWxkXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICAvKipcbiAgICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAgICovXG4gIHN0cmF0cy5wcm9wcyA9IHN0cmF0cy5tZXRob2RzID0gc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICBpZiAoIWNoaWxkVmFsKSByZXR1cm4gcGFyZW50VmFsO1xuICAgIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWw7XG4gICAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICAvKipcbiAgICogRGVmYXVsdCBzdHJhdGVneS5cbiAgICovXG4gIHZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiBkZWZhdWx0U3RyYXQocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkID8gcGFyZW50VmFsIDogY2hpbGRWYWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2Ugc3VyZSBjb21wb25lbnQgb3B0aW9ucyBnZXQgY29udmVydGVkIHRvIGFjdHVhbFxuICAgKiBjb25zdHJ1Y3RvcnMuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnRzKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgICB2YXIgY29tcG9uZW50cyA9IG9wdGlvbnMuY29tcG9uZW50cztcbiAgICAgIHZhciBkZWYgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gY29tcG9uZW50cykge1xuICAgICAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XG4gICAgICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICsgJ2lkOiAnICsga2V5KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWYgPSBjb21wb25lbnRzW2tleV07XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGRlZikpIHtcbiAgICAgICAgICBjb21wb25lbnRzW2tleV0gPSBWdWUuZXh0ZW5kKGRlZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gICAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVQcm9wcyhvcHRpb25zKSB7XG4gICAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgICBpZiAoIXByb3BzKSByZXR1cm47XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICB2YWwgPSB2b2lkIDAsXG4gICAgICAgIG5hbWUgPSB2b2lkIDA7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICAgIH0gZWxzZSBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKSA/IHZhbCA6IHsgdHlwZTogdmFsIH07XG4gICAgICB9XG4gICAgfVxuICAgIG9wdGlvbnMucHJvcHMgPSByZXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMob3B0aW9ucykge1xuICAgIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICAgIGlmIChkaXJzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAgICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLCB2bSkge1xuICAgIG5vcm1hbGl6ZUNvbXBvbmVudHMoY2hpbGQpO1xuICAgIG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcbiAgICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICAgIGlmIChleHRlbmRzRnJvbSkge1xuICAgICAgcGFyZW50ID0gdHlwZW9mIGV4dGVuZHNGcm9tID09PSAnZnVuY3Rpb24nID8gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20ub3B0aW9ucywgdm0pIDogbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBtaXhpbiA9IGNoaWxkLm1peGluc1tpXTtcbiAgICAgICAgaWYgKG1peGluLnByb3RvdHlwZSBpbnN0YW5jZW9mIFZ1ZSkge1xuICAgICAgICAgIG1peGluID0gbWl4aW4ub3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBtaXhpbiwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZUZpZWxkKGtleSkge1xuICAgICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIGFzc2V0LlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAgICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsIHR5cGUsIGlkLCB3YXJuTWlzc2luZykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAgIHZhciByZXMgPSBhc3NldHNbaWRdIHx8XG4gICAgLy8gY2FtZWxDYXNlIElEXG4gICAgYXNzZXRzW2NhbWVsaXplKGlkKV0gfHxcbiAgICAvLyBQYXNjYWwgQ2FzZSBJRFxuICAgIGFzc2V0c1tjYXBpdGFsaXplKGNhbWVsaXplKGlkKSldO1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICB3YXJuKCdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXByb3BzRGF0YSkgcmV0dXJuO1xuICAgIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gICAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gICAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgICBpZiAoZ2V0VHlwZShwcm9wLnR5cGUpID09PSAnQm9vbGVhbicpIHtcbiAgICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICAgIG9ic2VydmUodmFsdWUpO1xuICAgICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gICAgfVxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBuYW1lKSB7XG4gICAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gICAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICAgIGlmIChpc09iamVjdChkZWYpKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsgbmFtZSArICdcIjogJyArICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICsgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLCB2bSk7XG4gICAgfVxuICAgIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gICAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgcHJvcC50eXBlICE9PSBGdW5jdGlvbiA/IGRlZi5jYWxsKHZtKSA6IGRlZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gICAqL1xuICBmdW5jdGlvbiBhc3NlcnRQcm9wKHByb3AsIG5hbWUsIHZhbHVlLCB2bSwgYWJzZW50KSB7XG4gICAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgICB3YXJuKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLCB2bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICAgIHZhciB2YWxpZCA9ICF0eXBlO1xuICAgIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlID0gW3R5cGVdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdmFsaWQpIHtcbiAgICAgIHdhcm4oJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICsgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsIHZtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJywgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgdGhlIHR5cGUgb2YgYSB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSkge1xuICAgIHZhciB2YWxpZCA9IHZvaWQgMDtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSAnU3RyaW5nJykge1xuICAgICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnc3RyaW5nJyk7XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdudW1iZXInKTtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0Jvb2xlYW4nKSB7XG4gICAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdib29sZWFuJyk7XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdGdW5jdGlvbicpIHtcbiAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJyk7XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbGlkOiB2YWxpZCxcbiAgICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gICAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICAgKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRUeXBlKGZuKSB7XG4gICAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gIH1cblxuXG5cbiAgdmFyIHV0aWwgPSBPYmplY3QuZnJlZXplKHtcbiAgXHRkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUsXG4gIFx0X3RvU3RyaW5nOiBfdG9TdHJpbmcsXG4gIFx0dG9OdW1iZXI6IHRvTnVtYmVyLFxuICBcdG1ha2VNYXA6IG1ha2VNYXAsXG4gIFx0aXNCdWlsdEluVGFnOiBpc0J1aWx0SW5UYWcsXG4gIFx0cmVtb3ZlOiByZW1vdmUsXG4gIFx0aGFzT3duOiBoYXNPd24sXG4gIFx0aXNQcmltaXRpdmU6IGlzUHJpbWl0aXZlLFxuICBcdGNhY2hlZDogY2FjaGVkLFxuICBcdGNhbWVsaXplOiBjYW1lbGl6ZSxcbiAgXHRjYXBpdGFsaXplOiBjYXBpdGFsaXplLFxuICBcdGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuICBcdGJpbmQ6IGJpbmQsXG4gIFx0dG9BcnJheTogdG9BcnJheSxcbiAgXHRleHRlbmQ6IGV4dGVuZCxcbiAgXHRpc09iamVjdDogaXNPYmplY3QsXG4gIFx0aXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgXHR0b09iamVjdDogdG9PYmplY3QsXG4gIFx0bm9vcDogbm9vcCxcbiAgXHRubzogbm8sXG4gIFx0Z2VuU3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyxcbiAgXHRpc1Jlc2VydmVkOiBpc1Jlc2VydmVkLFxuICBcdGRlZjogZGVmLFxuICBcdHBhcnNlUGF0aDogcGFyc2VQYXRoLFxuICBcdGhhc1Byb3RvOiBoYXNQcm90byxcbiAgXHRpbkJyb3dzZXI6IGluQnJvd3NlcixcbiAgXHRkZXZ0b29sczogZGV2dG9vbHMsXG4gIFx0VUE6IFVBLFxuICBcdG5leHRUaWNrOiBuZXh0VGljayxcbiAgXHRnZXQgX1NldCAoKSB7IHJldHVybiBfU2V0OyB9LFxuICBcdG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICBcdHJlc29sdmVBc3NldDogcmVzb2x2ZUFzc2V0LFxuICBcdGdldCB3YXJuICgpIHsgcmV0dXJuIHdhcm47IH0sXG4gIFx0Z2V0IGZvcm1hdENvbXBvbmVudE5hbWUgKCkgeyByZXR1cm4gZm9ybWF0Q29tcG9uZW50TmFtZTsgfSxcbiAgXHR2YWxpZGF0ZVByb3A6IHZhbGlkYXRlUHJvcFxuICB9KTtcblxuICBmdW5jdGlvbiBpbml0VXNlKFZ1ZSkge1xuICAgIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbml0TWl4aW4kMShWdWUpIHtcbiAgICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIFZ1ZS5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFZ1ZS5vcHRpb25zLCBtaXhpbik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRFeHRlbmQoVnVlKSB7XG4gICAgLyoqXG4gICAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgICAqL1xuICAgIFZ1ZS5jaWQgPSAwO1xuICAgIHZhciBjaWQgPSAxO1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICAgKi9cbiAgICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICAgIHZhciBpc0ZpcnN0RXh0ZW5kID0gU3VwZXIuY2lkID09PSAwO1xuICAgICAgaWYgKGlzRmlyc3RFeHRlbmQgJiYgZXh0ZW5kT3B0aW9ucy5fQ3Rvcikge1xuICAgICAgICByZXR1cm4gZXh0ZW5kT3B0aW9ucy5fQ3RvcjtcbiAgICAgIH1cbiAgICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICAgIHdhcm4oJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICsgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY2F0ZXJzIGFuZCB0aGUgaHlwaGVuLicpO1xuICAgICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFN1cGVyLm9wdGlvbnMsIGV4dGVuZE9wdGlvbnMpO1xuICAgICAgU3ViWydzdXBlciddID0gU3VwZXI7XG4gICAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvblxuICAgICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgICAgfSk7XG4gICAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgICAgfVxuICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgICBpZiAoaXNGaXJzdEV4dGVuZCkge1xuICAgICAgICBleHRlbmRPcHRpb25zLl9DdG9yID0gU3ViO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN1YjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICAgKi9cbiAgICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKGlkLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xuICAgICAgICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgKyAnaWQ6ICcgKyBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgICBkZWZpbml0aW9uID0gVnVlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICB2YXIgS2VlcEFsaXZlID0ge1xuICAgIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgICBpZiAodm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gb3B0cy5DdG9yLmNpZCArICc6OicgKyBvcHRzLnRhZyA6IHZub2RlLmtleTtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVba2V5XSkge1xuICAgICAgICAgIHZub2RlLmNoaWxkID0gdGhpcy5jYWNoZVtrZXldLmNoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9LFxuICAgIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkKCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgdmFyIHZub2RlID0gdGhpcy5jYWNoZVtrZXldO1xuICAgICAgICBjYWxsSG9vayh2bm9kZS5jaGlsZCwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgICAgIHZub2RlLmNoaWxkLiRkZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXRHbG9iYWxBUEkoVnVlKSB7XG4gICAgLy8gY29uZmlnXG4gICAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICAgIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLicpO1xuICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG4gICAgVnVlLnV0aWwgPSB1dGlsO1xuICAgIFZ1ZS5zZXQgPSBzZXQ7XG4gICAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICAgIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH0pO1xuXG4gICAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICAgIGluaXRVc2UoVnVlKTtcbiAgICBpbml0TWl4aW4kMShWdWUpO1xuICAgIGluaXRFeHRlbmQoVnVlKTtcbiAgICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbiAgfVxuXG4gIGluaXRHbG9iYWxBUEkoVnVlKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBjb25maWcuX2lzU2VydmVyO1xuICAgIH1cbiAgfSk7XG5cbiAgVnVlLnZlcnNpb24gPSAnMi4wLjAtcmMuMic7XG5cbiAgLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xuICB2YXIgbXVzdFVzZVByb3AgPSBtYWtlTWFwKCd2YWx1ZSxzZWxlY3RlZCxjaGVja2VkLG11dGVkJyk7XG5cbiAgdmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxuICB2YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgKyAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICsgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJyk7XG5cbiAgdmFyIGlzQXR0ciA9IG1ha2VNYXAoJ2FjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsdCxhc3luYyxhdXRvY29tcGxldGUsJyArICdhdXRvZm9jdXMsYXV0b3BsYXksYXV0b3NhdmUsYmdjb2xvcixib3JkZXIsYnVmZmVyZWQsY2hhbGxlbmdlLGNoYXJzZXQsJyArICdjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxodHRwLWVxdWl2LCcgKyAnbmFtZSxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsY29vcmRzLGRhdGEsZGF0ZXRpbWUsZGVmYXVsdCwnICsgJ2RlZmVyLGRpcixkaXJuYW1lLGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLG1ldGhvZCxmb3IsJyArICdmb3JtLGZvcm1hY3Rpb24saGVhZGVycyw8dGg+LGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsJyArICdpY29uLGlkLGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxpc3QsbG9vcCxsb3csJyArICdtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1lZGlhLG1ldGhvZCxHRVQsUE9TVCxtaW4sbXVsdGlwbGUsZW1haWwsZmlsZSwnICsgJ211dGVkLG5hbWUsbm92YWxpZGF0ZSxvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlciwnICsgJ3ByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsJyArICdzY29wZSxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc2hhcGUsc2l6ZSx0eXBlLHRleHQscGFzc3dvcmQsc2l6ZXMsc3BhbiwnICsgJ3NwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsJyArICd0YXJnZXQsdGl0bGUsdHlwZSx1c2VtYXAsdmFsdWUsd2lkdGgsd3JhcCcpO1xuXG4gIHZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG4gIHZhciBpc1hsaW5rID0gZnVuY3Rpb24gaXNYbGluayhuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJztcbiAgfTtcblxuICB2YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gZ2V0WGxpbmtQcm9wKG5hbWUpIHtcbiAgICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJyc7XG4gIH07XG5cbiAgdmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiBpc0ZhbHN5QXR0clZhbHVlKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpIHtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jaGlsZCkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNoaWxkLl92bm9kZTtcbiAgICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuQ2xhc3NGcm9tRGF0YShkYXRhKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhKGNoaWxkLCBwYXJlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICAgIGNsYXNzOiBjaGlsZC5jbGFzcyA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXSA6IHBhcmVudC5jbGFzc1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhKGRhdGEpIHtcbiAgICB2YXIgZHluYW1pY0NsYXNzID0gZGF0YS5jbGFzcztcbiAgICB2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xuICAgIGlmIChzdGF0aWNDbGFzcyB8fCBkeW5hbWljQ2xhc3MpIHtcbiAgICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyBiID8gYSArICcgJyArIGIgOiBhIDogYiB8fCAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzKHZhbHVlKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFyIHN0cmluZ2lmaWVkID0gdm9pZCAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHZhbHVlW2ldKSB7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSB7XG4gICAgICAgICAgICByZXMgKz0gc3RyaW5naWZpZWQgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZVtrZXldKSByZXMgKz0ga2V5ICsgJyAnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIHZhciBuYW1lc3BhY2VNYXAgPSB7XG4gICAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xuICB9O1xuXG4gIHZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKCdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICsgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICsgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICsgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICsgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgKyAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICsgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgKyAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgKyAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZScpO1xuXG4gIHZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcCgnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicicsIHRydWUpO1xuXG4gIC8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuICAvLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcCgnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZScsIHRydWUpO1xuXG4gIC8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbiAgLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG4gIHZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcCgnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgKyAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgKyAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArICd0aXRsZSx0cix0cmFjaycsIHRydWUpO1xuXG4gIC8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuICAvLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxuICB2YXIgaXNTVkcgPSBtYWtlTWFwKCdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LCcgKyAnZm9udC1mYWNlLGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICsgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLCB0cnVlKTtcblxuICB2YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiBpc1ByZVRhZyh0YWcpIHtcbiAgICByZXR1cm4gdGFnID09PSAncHJlJztcbiAgfTtcblxuICB2YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRUYWcodGFnKSB7XG4gICAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlKHRhZykge1xuICAgIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgICByZXR1cm4gJ3N2Zyc7XG4gICAgfVxuICAgIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAgIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICAgIHJldHVybiAnbWF0aCc7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50KHRhZykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ107XG4gICAgfVxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHwgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFVBJDEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGlzSUUgPSBVQSQxICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEkMSk7XG4gIHZhciBpc0lFOSA9IFVBJDEgJiYgVUEkMS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbiAgdmFyIGlzQW5kcm9pZCA9IFVBJDEgJiYgVUEkMS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xuXG4gIC8vIEFjY29yZGluZyB0b1xuICAvLyBodHRwczovL3czYy5naXRodWIuaW8vRE9NLVBhcnNpbmcvI2Rmbi1zZXJpYWxpemluZy1hbi1hdHRyaWJ1dGUtdmFsdWVcbiAgLy8gd2hlbiBzZXJpYWxpemluZyBpbm5lckhUTUwsIDwsID4sIFwiLCAmIHNob3VsZCBiZSBlbmNvZGVkIGFzIGVudGl0aWVzLlxuICAvLyBIb3dldmVyLCBvbmx5IHNvbWUgYnJvd3NlcnMsIGUuZy4gUGhhbnRvbUpTLCBlbmNvZGVzIDwgYW5kID4uXG4gIC8vIHRoaXMgY2F1c2VzIHByb2JsZW1zIHdpdGggdGhlIGluLWJyb3dzZXIgcGFyc2VyLlxuICB2YXIgc2hvdWxkRGVjb2RlVGFncyA9IGluQnJvd3NlciA/IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmlubmVySFRNTCA9ICc8ZGl2IGE9XCI+XCI+JztcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmZ3Q7JykgPiAwO1xuICB9KCkgOiBmYWxzZTtcblxuICAvKipcbiAgICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBxdWVyeShlbCkge1xuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBlbDtcbiAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21tZW50KHRleHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZChub2RlLCBjaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQobm9kZSwgY2hpbGQpIHtcbiAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcmVudE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0U2libGluZyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiB0YWdOYW1lKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50YWdOYW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQobm9kZSwgdGV4dCkge1xuICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2hpbGROb2Rlcyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuY2hpbGROb2RlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShub2RlLCBrZXksIHZhbCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbiAgfVxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gICAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gICAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICAgIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gICAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXMsXG4gICAgc2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbiAgfSk7XG5cbiAgdmFyIGVtcHR5RGF0YSA9IHt9O1xuICB2YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCBlbXB0eURhdGEsIFtdKTtcbiAgdmFyIGhvb2tzJDEgPSBbJ2NyZWF0ZScsICd1cGRhdGUnLCAncG9zdHBhdGNoJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbiAgZnVuY3Rpb24gaXNVbmRlZihzKSB7XG4gICAgcmV0dXJuIHMgPT0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVmKHMpIHtcbiAgICByZXR1cm4gcyAhPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gc2FtZVZub2RlKHZub2RlMSwgdm5vZGUyKSB7XG4gICAgcmV0dXJuIHZub2RlMS5rZXkgPT09IHZub2RlMi5rZXkgJiYgdm5vZGUxLnRhZyA9PT0gdm5vZGUyLnRhZyAmJiB2bm9kZTEuaXNDb21tZW50ID09PSB2bm9kZTIuaXNDb21tZW50ICYmICF2bm9kZTEuZGF0YSA9PT0gIXZub2RlMi5kYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHgoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAga2V5ID0gdm9pZCAwO1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIG1hcFtrZXldID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24oYmFja2VuZCkge1xuICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICBqID0gdm9pZCAwO1xuICAgIHZhciBjYnMgPSB7fTtcblxuICAgIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICAgIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaG9va3MkMS5sZW5ndGg7ICsraSkge1xuICAgICAgY2JzW2hvb2tzJDFbaV1dID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgICBpZiAobW9kdWxlc1tqXVtob29rcyQxW2ldXSAhPT0gdW5kZWZpbmVkKSBjYnNbaG9va3MkMVtpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzJDFbaV1dKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbXB0eU5vZGVBdChlbG0pIHtcbiAgICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUm1DYihjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgICBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIGlmICgtLXJlbW92ZS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgICByZW1vdmVFbGVtZW50KGNoaWxkRWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVtb3ZlLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICAgIHJldHVybiByZW1vdmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXN0ZWQpIHtcbiAgICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICAgIGVsbSA9IHZvaWQgMDtcbiAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSBpKHZub2RlKTtcbiAgICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkKSkge1xuICAgICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZub2RlLmVsbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCF2bm9kZS5ucyAmJiAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMgJiYgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5pbmRleE9mKHRhZykgPiAtMSkgJiYgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKSkge1xuICAgICAgICAgICAgd2FybignVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICsgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsbSA9IHZub2RlLmVsbSA9IHZub2RlLm5zID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZykgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQoZWxtLCBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQoZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2bm9kZS5pc0NvbW1lbnQpIHtcbiAgICAgICAgZWxtID0gdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxtID0gdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bm9kZS5lbG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQYXRjaGFibGUodm5vZGUpIHtcbiAgICAgIHdoaWxlICh2bm9kZS5jaGlsZCkge1xuICAgICAgICB2bm9kZSA9IHZub2RlLmNoaWxkLl92bm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytfaSkge1xuICAgICAgICBjYnMuY3JlYXRlW19pXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgIH1cbiAgICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgICAgaWYgKGkuY3JlYXRlKSBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgICAgaWYgKGkuaW5zZXJ0KSBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICBpZiAodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSB7XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLmNoaWxkLiRlbDtcbiAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAgIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gICAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICAgIGZ1bmN0aW9uIHNldFNjb3BlKHZub2RlKSB7XG4gICAgICB2YXIgaSA9IHZvaWQgMDtcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiYgaSAhPT0gdm5vZGUuY29udGV4dCAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVm5vZGVzKHBhcmVudEVsbSwgYmVmb3JlLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUpLCBiZWZvcmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rKHZub2RlKSB7XG4gICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICBqID0gdm9pZCAwO1xuICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgaSh2bm9kZSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5kZXN0cm95W2ldKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZCkgJiYgIWRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKGkuX3Zub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUZXh0IG5vZGVcbiAgICAgICAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50RWxtLCBjaC5lbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sodm5vZGUsIHJtKSB7XG4gICAgICBpZiAocm0gfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKCFybSkge1xuICAgICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgICAgfVxuICAgICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBybSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVFbGVtZW50KHZub2RlLmVsbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4ocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICAgIHZhciBvbGRLZXlUb0lkeCA9IHZvaWQgMCxcbiAgICAgICAgICBpZHhJbk9sZCA9IHZvaWQgMCxcbiAgICAgICAgICBlbG1Ub01vdmUgPSB2b2lkIDAsXG4gICAgICAgICAgYmVmb3JlID0gdm9pZCAwO1xuXG4gICAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgIC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7XG4gICAgICAgICAgICAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAhZWxtVG9Nb3ZlKSB7XG4gICAgICAgICAgICAgIHdhcm4oJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICsgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbG1Ub01vdmUudGFnICE9PSBuZXdTdGFydFZub2RlLnRhZykge1xuICAgICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSksIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG5ld1N0YXJ0Vm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICBiZWZvcmUgPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIGJlZm9yZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2bm9kZS5pc1N0YXRpYyAmJiBvbGRWbm9kZS5pc1N0YXRpYyAmJiB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSkge1xuICAgICAgICB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICAgIGhvb2sgPSB2b2lkIDA7XG4gICAgICB2YXIgaGFzRGF0YSA9IGlzRGVmKGkgPSB2bm9kZS5kYXRhKTtcbiAgICAgIGlmIChoYXNEYXRhICYmIGlzRGVmKGhvb2sgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBob29rLnByZXBhdGNoKSkge1xuICAgICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICB9XG4gICAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChoYXNEYXRhICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgfWlmIChpc0RlZihob29rKSAmJiBpc0RlZihpID0gaG9vay51cGRhdGUpKSBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0RhdGEpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5wb3N0cGF0Y2gubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMucG9zdHBhdGNoW2ldKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICAgIH1pZiAoaXNEZWYoaG9vaykgJiYgaXNEZWYoaSA9IGhvb2sucG9zdHBhdGNoKSkgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgICBpZiAoaW5pdGlhbCAmJiB2bm9kZS5wYXJlbnQpIHtcbiAgICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcXVldWUubGVuZ3RoOyArK19pMikge1xuICAgICAgICAgIHF1ZXVlW19pMl0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtfaTJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiYWlsZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBoeWRyYXRlKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG5cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZCkpIHtcbiAgICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBub2RlT3BzLmNoaWxkTm9kZXMoZWxtKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoICE9PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgY2hpbGRyZW4ubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgICBpZiAoIWh5ZHJhdGUoY2hpbGROb2Rlc1tfaTNdLCBjaGlsZHJlbltfaTNdLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCkge1xuICAgICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiAhYmFpbGVkKSB7XG4gICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoKG5vZGUsIHZub2RlKSB7XG4gICAgICBpZiAodm5vZGUudGFnKSB7XG4gICAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IHZub2RlLnRhZyA9PT0gbm9kZU9wcy50YWdOYW1lKG5vZGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX3RvU3RyaW5nKHZub2RlLnRleHQpID09PSBub2RlLmRhdGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XG4gICAgICB2YXIgZWxtID0gdm9pZCAwLFxuICAgICAgICAgIHBhcmVudCA9IHZvaWQgMDtcbiAgICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgICBpZiAoIW9sZFZub2RlKSB7XG4gICAgICAgIC8vIGVtcHR5IG1vdW50LCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZSgnc2VydmVyLXJlbmRlcmVkJykpIHtcbiAgICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKCdzZXJ2ZXItcmVuZGVyZWQnKTtcbiAgICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoeWRyYXRpbmcpIHtcbiAgICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICsgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICsgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICsgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICAgIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbG0pO1xuXG4gICAgICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudC5cbiAgICAgICAgICBpZiAodm5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICB2bm9kZS5wYXJlbnQuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytfaTQpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW19pNF0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCB2bm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcoZWxtKSk7XG4gICAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50LCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgICByZXR1cm4gdm5vZGUuZWxtO1xuICAgIH07XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlcyA9IHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGJpbmREaXJlY3RpdmVzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgYXBwbHlEaXJlY3RpdmVzKG9sZFZub2RlLCB2bm9kZSwgJ2JpbmQnKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgIGFwcGx5RGlyZWN0aXZlcyhvbGRWbm9kZSwgdm5vZGUsICd1cGRhdGUnKTtcbiAgICB9LFxuICAgIHBvc3RwYXRjaDogZnVuY3Rpb24gcG9zdHVwZGF0ZURpcmVjdGl2ZXMob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICBhcHBseURpcmVjdGl2ZXMob2xkVm5vZGUsIHZub2RlLCAnY29tcG9uZW50VXBkYXRlZCcpO1xuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyh2bm9kZSkge1xuICAgICAgYXBwbHlEaXJlY3RpdmVzKHZub2RlLCB2bm9kZSwgJ3VuYmluZCcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIGFwcGx5RGlyZWN0aXZlcyhvbGRWbm9kZSwgdm5vZGUsIGhvb2spIHtcbiAgICB2YXIgZGlycyA9IHZub2RlLmRhdGEuZGlyZWN0aXZlcztcbiAgICBpZiAoZGlycykge1xuICAgICAgdmFyIG9sZERpcnMgPSBvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXM7XG4gICAgICB2YXIgaXNVcGRhdGUgPSBob29rID09PSAndXBkYXRlJztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGlyID0gZGlyc1tpXTtcbiAgICAgICAgdmFyIGRlZiA9IHJlc29sdmVBc3NldCh2bm9kZS5jb250ZXh0LiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgICAgICAgdmFyIGZuID0gZGVmICYmIGRlZltob29rXTtcbiAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgaWYgKGlzVXBkYXRlICYmIG9sZERpcnMpIHtcbiAgICAgICAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpcnNbaV0udmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciByZWYgPSB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoXywgdm5vZGUpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kodm5vZGUpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJSZWYodm5vZGUsIGlzUmVtb3ZhbCkge1xuICAgIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgICBpZiAoIWtleSkgcmV0dXJuO1xuXG4gICAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgcmVmID0gdm5vZGUuY2hpbGQgfHwgdm5vZGUuZWxtO1xuICAgIHZhciByZWZzID0gdm0uJHJlZnM7XG4gICAgaWYgKGlzUmVtb3ZhbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2VNb2R1bGVzID0gW3JlZiwgZGlyZWN0aXZlc107XG5cbiAgZnVuY3Rpb24gdXBkYXRlQXR0cnMob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKCFvbGRWbm9kZS5kYXRhLmF0dHJzICYmICF2bm9kZS5kYXRhLmF0dHJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXkgPSB2b2lkIDAsXG4gICAgICAgIGN1ciA9IHZvaWQgMCxcbiAgICAgICAgb2xkID0gdm9pZCAwO1xuICAgIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gICAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAgIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICAgIGlmIChhdHRycy5fX29iX18pIHtcbiAgICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICAgIH1cblxuICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgICAgaWYgKGF0dHJzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0QXR0cihlbCwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGF0dHJzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gICAgdXBkYXRlOiB1cGRhdGVBdHRyc1xuICB9O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICAgIGlmICghZGF0YS5zdGF0aWNDbGFzcyAmJiAhZGF0YS5jbGFzcyAmJiAoIW9sZERhdGEgfHwgIW9sZERhdGEuc3RhdGljQ2xhc3MgJiYgIW9sZERhdGEuY2xhc3MpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICAgIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gICAgaWYgKHRyYW5zaXRpb25DbGFzcykge1xuICAgICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBjbGFzc1xuICAgIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgICB9XG4gIH1cblxuICB2YXIga2xhc3MgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG4gIH07XG5cbiAgZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmICghb2xkVm5vZGUuZGF0YS5vbiAmJiAhdm5vZGUuZGF0YS5vbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICAgIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gICAgdmFyIGFkZCA9IHZub2RlLmVsbS5fdl9hZGQgfHwgKHZub2RlLmVsbS5fdl9hZGQgPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgICAgIHZub2RlLmVsbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbiAgICB9KTtcbiAgICB2YXIgcmVtb3ZlID0gdm5vZGUuZWxtLl92X3JlbW92ZSB8fCAodm5vZGUuZWxtLl92X3JlbW92ZSA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgdm5vZGUuZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCwgcmVtb3ZlKTtcbiAgfVxuXG4gIHZhciBldmVudHMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gICAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbiAgfTtcblxuICBmdW5jdGlvbiB1cGRhdGVET01Qcm9wcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoIW9sZFZub2RlLmRhdGEuZG9tUHJvcHMgJiYgIXZub2RlLmRhdGEuZG9tUHJvcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGtleSA9IHZvaWQgMCxcbiAgICAgICAgY3VyID0gdm9pZCAwO1xuICAgIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gICAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAgIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICAgIGlmIChwcm9wcy5fX29iX18pIHtcbiAgICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICAgIH1cblxuICAgIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGVsbVtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICAgIGlmICgoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpICYmIHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgICB2YXIgc3RyQ3VyID0gY3VyID09IG51bGwgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgICBpZiAoZWxtLnZhbHVlICE9PSBzdHJDdXIpIHtcbiAgICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkb21Qcm9wcyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICAgIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbiAgfTtcblxuICB2YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxuICB2YXIgdGVzdEVsID0gdm9pZCAwO1xuICB2YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdGVzdEVsID0gdGVzdEVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgcHJvcCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cbiAgICB2YXIgdXBwZXIgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgICByZXR1cm4gcHJlZml4ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiB1cGRhdGVTdHlsZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoKCFvbGRWbm9kZS5kYXRhIHx8ICFvbGRWbm9kZS5kYXRhLnN0eWxlKSAmJiAhdm5vZGUuZGF0YS5zdHlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY3VyID0gdm9pZCAwLFxuICAgICAgICBuYW1lID0gdm9pZCAwO1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICB2YXIgb2xkU3R5bGUgPSBvbGRWbm9kZS5kYXRhLnN0eWxlIHx8IHt9O1xuICAgIHZhciBzdHlsZSA9IHZub2RlLmRhdGEuc3R5bGUgfHwge307XG5cbiAgICAvLyBoYW5kbGUgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmVlZENsb25lID0gc3R5bGUuX19vYl9fO1xuXG4gICAgLy8gaGFuZGxlIGFycmF5IHN5bnRheFxuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkge1xuICAgICAgc3R5bGUgPSB2bm9kZS5kYXRhLnN0eWxlID0gdG9PYmplY3Qoc3R5bGUpO1xuICAgIH1cblxuICAgIC8vIGNsb25lIHRoZSBzdHlsZSBmb3IgZnV0dXJlIHVwZGF0ZXMsXG4gICAgLy8gaW4gY2FzZSB0aGUgdXNlciBtdXRhdGVzIHRoZSBzdHlsZSBvYmplY3QgaW4tcGxhY2UuXG4gICAgaWYgKG5lZWRDbG9uZSkge1xuICAgICAgc3R5bGUgPSB2bm9kZS5kYXRhLnN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XG4gICAgfVxuXG4gICAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgICBpZiAoIXN0eWxlW25hbWVdKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZShuYW1lKV0gPSAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICBjdXIgPSBzdHlsZVtuYW1lXTtcbiAgICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZShuYW1lKV0gPSBjdXIgfHwgJyc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0eWxlID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gICAgdXBkYXRlOiB1cGRhdGVTdHlsZVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAgICogU1ZHIGVsZW1lbnRzIGluIElFXG4gICAqL1xuICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXIgPSAnICcgKyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgKyAnICc7XG4gICAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICAgKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN1ciA9ICcgJyArIGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSArICcgJztcbiAgICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIudHJpbSgpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG4gIHZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuICB2YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbiAgLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xuICB2YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG4gIHZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG4gIHZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG4gIHZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuICBpZiAoaGFzVHJhbnNpdGlvbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiYgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICAgIH1cbiAgfVxuXG4gIHZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBzZXRUaW1lb3V0O1xuICBmdW5jdGlvbiBuZXh0RnJhbWUoZm4pIHtcbiAgICByYWYoZnVuY3Rpb24gKCkge1xuICAgICAgcmFmKGZuKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XG4gICAgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pKS5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gICAgfVxuICAgIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzKGVsLCBleHBlY3RlZFR5cGUsIGNiKSB7XG4gICAgdmFyIF9nZXRUcmFuc2l0aW9uSW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuXG4gICAgdmFyIHR5cGUgPSBfZ2V0VHJhbnNpdGlvbkluZm8udHlwZTtcbiAgICB2YXIgdGltZW91dCA9IF9nZXRUcmFuc2l0aW9uSW5mby50aW1lb3V0O1xuICAgIHZhciBwcm9wQ291bnQgPSBfZ2V0VHJhbnNpdGlvbkluZm8ucHJvcENvdW50O1xuXG4gICAgaWYgKCF0eXBlKSByZXR1cm4gY2IoKTtcbiAgICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gICAgdmFyIGVuZGVkID0gMDtcbiAgICB2YXIgZW5kID0gZnVuY3Rpb24gZW5kKCkge1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgICAgY2IoKTtcbiAgICB9O1xuICAgIHZhciBvbkVuZCA9IGZ1bmN0aW9uIG9uRW5kKCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dCArIDEpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgfVxuXG4gIHZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbiAgZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xuICAgIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgdmFyIHRyYW5zaXRpb25lRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25lRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gICAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gICAgdmFyIHRpbWVvdXQgPSAwO1xuICAgIHZhciBwcm9wQ291bnQgPSAwO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgICAgdHlwZSA9IHRpbWVvdXQgPiAwID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0ID8gVFJBTlNJVElPTiA6IEFOSU1BVElPTiA6IG51bGw7XG4gICAgICBwcm9wQ291bnQgPSB0eXBlID8gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIHZhciBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xuICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKTtcbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b01zKHMpIHtcbiAgICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDA7XG4gIH1cblxuICBmdW5jdGlvbiBlbnRlcih2bm9kZSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAgIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gICAgaWYgKGVsLl9sZWF2ZUNiKSB7XG4gICAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgZWwuX2xlYXZlQ2IoKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVsLl9lbnRlckNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICAgIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICAgIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICAgIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gICAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICAgIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gICAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gICAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gICAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICAgIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gICAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuXG4gICAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAgIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAgIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG5cbiAgICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gICAgdmFyIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQgPyB0cmFuc2l0aW9uTm9kZS5wYXJlbnQuY29udGV4dCA6IGFjdGl2ZUluc3RhbmNlO1xuXG4gICAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gICAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgPyBhcHBlYXJDbGFzcyA6IGVudGVyQ2xhc3M7XG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyID8gYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyIDogYmVmb3JlRW50ZXI7XG4gICAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyID8gdHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyIDogZW50ZXI7XG4gICAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXIgPyBhZnRlckFwcGVhciB8fCBhZnRlckVudGVyIDogYWZ0ZXJFbnRlcjtcbiAgICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXIgPyBhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQgOiBlbnRlckNhbmNlbGxlZDtcblxuICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBlbnRlckhvb2sgJiZcbiAgICAvLyBlbnRlckhvb2sgbWF5IGJlIGEgYm91bmQgbWV0aG9kIHdoaWNoIGV4cG9zZXNcbiAgICAvLyB0aGUgbGVuZ3RoIG9mIG9yaWdpbmFsIGZuIGFzIF9sZW5ndGhcbiAgICAoZW50ZXJIb29rLl9sZW5ndGggfHwgZW50ZXJIb29rLmxlbmd0aCkgPiAxO1xuXG4gICAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgICB9XG4gICAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gICAgfSk7XG5cbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgICBpZiAocGVuZGluZ05vZGUgJiYgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiYgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKSB7XG4gICAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICAgIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfVxuXG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYXZlKHZub2RlLCBybSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAgIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gICAgaWYgKGVsLl9lbnRlckNiKSB7XG4gICAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgZWwuX2VudGVyQ2IoKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gcm0oKTtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZWwuX2xlYXZlQ2IgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gICAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gICAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gICAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICAgIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICAgIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gICAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG5cblxuICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBsZWF2ZSAmJlxuICAgIC8vIGxlYXZlIGhvb2sgbWF5IGJlIGEgYm91bmQgbWV0aG9kIHdoaWNoIGV4cG9zZXNcbiAgICAvLyB0aGUgbGVuZ3RoIG9mIG9yaWdpbmFsIGZuIGFzIF9sZW5ndGhcbiAgICAobGVhdmUuX2xlbmd0aCB8fCBsZWF2ZS5sZW5ndGgpID4gMTtcblxuICAgIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICAgIH1cbiAgICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgICB9KTtcblxuICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSgpIHtcbiAgICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpW3Zub2RlLmtleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbihkZWYpIHtcbiAgICBpZiAoIWRlZikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZi5uYW1lIHx8ICd2JykpO1xuICAgICAgfVxuICAgICAgZXh0ZW5kKHJlcywgZGVmKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVyQ2xhc3M6IG5hbWUgKyAnLWVudGVyJyxcbiAgICAgIGxlYXZlQ2xhc3M6IG5hbWUgKyAnLWxlYXZlJyxcbiAgICAgIGFwcGVhckNsYXNzOiBuYW1lICsgJy1lbnRlcicsXG4gICAgICBlbnRlckFjdGl2ZUNsYXNzOiBuYW1lICsgJy1lbnRlci1hY3RpdmUnLFxuICAgICAgbGVhdmVBY3RpdmVDbGFzczogbmFtZSArICctbGVhdmUtYWN0aXZlJyxcbiAgICAgIGFwcGVhckFjdGl2ZUNsYXNzOiBuYW1lICsgJy1lbnRlci1hY3RpdmUnXG4gICAgfTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gb25jZShmbikge1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoXywgdm5vZGUpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAgIGVudGVyKHZub2RlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKHZub2RlLCBybSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSA6IHt9O1xuXG4gIHZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbYXR0cnMsIGtsYXNzLCBldmVudHMsIGRvbVByb3BzLCBzdHlsZSwgdHJhbnNpdGlvbl07XG5cbiAgLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4gIC8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gIHZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbiAgdmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbiAgdmFyIG1vZGVsYWJsZVRhZ1JFID0gL15pbnB1dHxzZWxlY3R8dGV4dGFyZWF8dnVlLWNvbXBvbmVudC1bMC05XSsoLVswLTlhLXpBLVpfXFwtXSopPyQvO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkpIHtcbiAgICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBtb2RlbCA9IHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghbW9kZWxhYmxlVGFnUkUudGVzdCh2bm9kZS50YWcpKSB7XG4gICAgICAgICAgd2Fybigndi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIGVsZW1lbnQgdHlwZTogPCcgKyB2bm9kZS50YWcgKyAnPi4gJyArICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICsgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaXNBbmRyb2lkKSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaWdcbiAgICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZSA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGVsLm9wdGlvbnMpO1xuICAgICAgICB9KSA6IGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgZWwub3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKSB7XG4gICAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICAgIGlmICghaXNNdWx0aXBsZSkge1xuICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCc8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XCInICsgYmluZGluZy5leHByZXNzaW9uICsgJ1wiPiAnICsgKCdleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLCB2bSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaW5kZXhPZihnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGdldFZhbHVlKG9wdGlvbikgPT09IHZhbHVlKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGdldFZhbHVlKG9wdGlvbnNbaV0pID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWUob3B0aW9uKSB7XG4gICAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvbiA/IG9wdGlvbi5fdmFsdWUgOiBvcHRpb24udmFsdWUgfHwgb3B0aW9uLnRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcbiAgICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWdnZXIoZWwsIHR5cGUpIHtcbiAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbiAgfVxuXG4gIC8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbiAgZnVuY3Rpb24gbG9jYXRlTm9kZSh2bm9kZSkge1xuICAgIHJldHVybiB2bm9kZS5jaGlsZCAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbikgPyBsb2NhdGVOb2RlKHZub2RlLmNoaWxkLl92bm9kZSkgOiB2bm9kZTtcbiAgfVxuXG4gIHZhciBzaG93ID0ge1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoZWwsIF9yZWYsIHZub2RlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuXG4gICAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uICYmIHRyYW5zaXRpb24uYXBwZWFyICYmICFpc0lFOSkge1xuICAgICAgICBlbnRlcih2bm9kZSk7XG4gICAgICB9XG4gICAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuc3R5bGUuZGlzcGxheTtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICAgIGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGVsLCBfcmVmMiwgdm5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuICAgICAgdmFyIG9sZFZhbHVlID0gX3JlZjIub2xkVmFsdWU7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgcmV0dXJuO1xuICAgICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgICBpZiAodHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgZW50ZXIodm5vZGUpO1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgICBtb2RlbDogbW9kZWwsXG4gICAgc2hvdzogc2hvd1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gICAgbmFtZTogU3RyaW5nLFxuICAgIGFwcGVhcjogQm9vbGVhbixcbiAgICBjc3M6IEJvb2xlYW4sXG4gICAgbW9kZTogU3RyaW5nLFxuICAgIHR5cGU6IFN0cmluZyxcbiAgICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVDbGFzczogU3RyaW5nLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nXG4gIH07XG5cbiAgLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4gIC8vIHdlIHdhbnQgdG8gcmVjcnVzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG4gIGZ1bmN0aW9uIGdldFJlYWxDaGlsZCh2bm9kZSkge1xuICAgIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEoY29tcCkge1xuICAgIHZhciBkYXRhID0ge307XG4gICAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAgIC8vIHByb3BzXG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gICAgfVxuICAgIC8vIGV2ZW50cy5cbiAgICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIGZvciAodmFyIF9rZXkgaW4gbGlzdGVuZXJzKSB7XG4gICAgICBkYXRhW2NhbWVsaXplKF9rZXkpXSA9IGxpc3RlbmVyc1tfa2V5XS5mbjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZCkge1xuICAgIHJldHVybiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpID8gaCgna2VlcC1hbGl2ZScpIDogbnVsbFxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlID0gdm5vZGUucGFyZW50KSB7XG4gICAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBUcmFuc2l0aW9uID0ge1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICAgIGFic3RyYWN0OiB0cnVlLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjLnRhZztcbiAgICAgIH0pO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIHdhcm4oJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICsgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJywgdGhpcy4kcGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJykge1xuICAgICAgICB3YXJuKCdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSwgdGhpcy4kcGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiByYXdDaGlsZDtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgIHJldHVybiByYXdDaGlsZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGwgPyAnX192JyArIChjaGlsZC50YWcgKyB0aGlzLl91aWQpICsgJ19fJyA6IGNoaWxkLmtleTtcbiAgICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAgIGlmIChvbGRDaGlsZCAmJiBvbGRDaGlsZC5kYXRhICYmIG9sZENoaWxkLmtleSAhPT0gY2hpbGQua2V5KSB7XG4gICAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcblxuICAgICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiBwZXJmb3JtTGVhdmUoKSB7XG4gICAgICAgICAgICAgIGRlbGF5ZWRMZWF2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkge1xuICAgICAgICAgICAgICBkZWxheWVkTGVhdmUgPSBsZWF2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhd0NoaWxkO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcHJvcHMgPSBleHRlbmQoe1xuICAgIHRhZzogU3RyaW5nLFxuICAgIG1vdmVDbGFzczogU3RyaW5nXG4gIH0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbiAgZGVsZXRlIHByb3BzLm1vZGU7XG5cbiAgdmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICAgIG1hcFtjLmtleV0gPSBjOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gb3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyA6IGMudGFnO1xuICAgICAgICAgICAgd2FybignPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDwnICsgbmFtZSArICc+Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgX2MgPSBwcmV2Q2hpbGRyZW5bX2ldO1xuICAgICAgICAgIF9jLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICAgIF9jLmRhdGEucG9zID0gX2MuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGlmIChtYXBbX2Mua2V5XSkge1xuICAgICAgICAgICAga2VwdC5wdXNoKF9jKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKF9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9LFxuICAgIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlKCkge1xuICAgICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgICAgdGhpcy5fX3BhdGNoX18odGhpcy5fdm5vZGUsIHRoaXMua2VwdCwgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgICApO1xuICAgICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gICAgfSxcbiAgICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgdGhpcy5uYW1lICsgJy1tb3ZlJztcbiAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICAgICAgICBjLmVsbS5fbW92ZUNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgICAgICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gICAgICAgIHZhciBuZXdQb3MgPSBjLmRhdGEucG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gICAgICAgIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICAgICAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgICAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgICAgICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIGR4ICsgJ3B4LCcgKyBkeSArICdweCknO1xuICAgICAgICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgICAgdmFyIGYgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgICAgICBlbC5fbW92ZURlc3QgPSBjLmRhdGEucG9zO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYihlKSB7XG4gICAgICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuXG4gICAgbWV0aG9kczoge1xuICAgICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZShlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2hhc01vdmUgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlO1xuICAgICAgICB9XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICAgIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG4gIH07XG5cbiAgLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuICBWdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuICBWdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuICBWdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcbiAgVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuXG4gIC8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuICBleHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbiAgLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuICBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGNvbmZpZy5faXNTZXJ2ZXIgPyBub29wIDogcGF0Y2g7XG5cbiAgLy8gd3JhcCBtb3VudFxuICBWdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChlbCwgaHlkcmF0aW5nKSB7XG4gICAgZWwgPSBlbCAmJiAhY29uZmlnLl9pc1NlcnZlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcy5fbW91bnQoZWwsIGh5ZHJhdGluZyk7XG4gIH07XG5cbiAgLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgfSBlbHNlIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBpbkJyb3dzZXIgJiYgL0Nocm9tZVxcL1xcZCsvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgKyAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scycpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgMCk7XG5cbiAgdmFyIGRlY29kZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICBmdW5jdGlvbiBkZWNvZGVIVE1MKGh0bWwpIHtcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnQ7XG4gIH1cblxuICAvLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbiAgdmFyIHNpbmdsZUF0dHJJZGVudGlmaWVyID0gLyhbXlxcc1wiJzw+XFwvPV0rKS87XG4gIHZhciBzaW5nbGVBdHRyQXNzaWduID0gLyg/Oj0pLztcbiAgdmFyIHNpbmdsZUF0dHJWYWx1ZXMgPSBbXG4gIC8vIGF0dHIgdmFsdWUgZG91YmxlIHF1b3Rlc1xuICAvXCIoW15cIl0qKVwiKy8uc291cmNlLFxuICAvLyBhdHRyIHZhbHVlLCBzaW5nbGUgcXVvdGVzXG4gIC8nKFteJ10qKScrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIG5vIHF1b3Rlc1xuICAvKFteXFxzXCInPTw+YF0rKS8uc291cmNlXTtcbiAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBSZWdFeHAoJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICsgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgKyAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPycpO1xuXG4gIC8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuICAvLyBidXQgZm9yIFZ1ZSB0ZW1wbGF0ZXMgd2UgY2FuIGVuZm9yY2UgYSBzaW1wbGUgY2hhcnNldFxuICB2YXIgbmNuYW1lID0gJ1thLXpBLVpfXVtcXFxcd1xcXFwtXFxcXC5dKic7XG4gIHZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG4gIHZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKCdePCcgKyBxbmFtZUNhcHR1cmUpO1xuICB2YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xuICB2YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG4gIHZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG5cbiAgdmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbiAgJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gICAgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGcgPT09ICcnO1xuICB9KTtcblxuICAvLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbiAgdmFyIGlzU3BlY2lhbFRhZyA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZScsIHRydWUpO1xuXG4gIHZhciByZUNhY2hlID0ge307XG5cbiAgdmFyIGFtcFJFID0gLyZhbXA7L2c7XG4gIHZhciBsdFJFID0gLyZsdDsvZztcbiAgdmFyIGd0UkUgPSAvJmd0Oy9nO1xuICB2YXIgcXVvdGVSRSA9IC8mcXVvdDsvZztcblxuICBmdW5jdGlvbiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVUYWdzKSB7XG4gICAgaWYgKHNob3VsZERlY29kZVRhZ3MpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShsdFJFLCAnPCcpLnJlcGxhY2UoZ3RSRSwgJz4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoYW1wUkUsICcmJykucmVwbGFjZShxdW90ZVJFLCAnXCInKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSFRNTChodG1sLCBvcHRpb25zKSB7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gICAgdmFyIGlzVW5hcnlUYWcgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gICAgdmFyIGlzRnJvbURPTSA9IG9wdGlvbnMuaXNGcm9tRE9NO1xuICAgIHZhciBzaG91bGREZWNvZGVUYWdzID0gb3B0aW9ucy5zaG91bGREZWNvZGVUYWdzO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxhc3QgPSB2b2lkIDAsXG4gICAgICAgIGxhc3RUYWcgPSB2b2lkIDA7XG4gICAgd2hpbGUgKGh0bWwpIHtcbiAgICAgIGxhc3QgPSBodG1sO1xuICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHNjcmlwdCBvciBzdHlsZSBlbGVtZW50XG4gICAgICBpZiAoIWxhc3RUYWcgfHwgIWlzU3BlY2lhbFRhZyhsYXN0VGFnKSkge1xuICAgICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgICAgaWYgKC9ePCEtLS8udGVzdChodG1sKSkge1xuICAgICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgICBpZiAoL148IVxcWy8udGVzdChodG1sKSkge1xuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFswXSwgZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHQgPSB2b2lkIDA7XG4gICAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgICBodG1sID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgICAgIHZhciByZXN0ID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0YWNrZWRUYWcgIT09ICdzY3JpcHQnICYmIHN0YWNrZWRUYWcgIT09ICdzdHlsZScgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPylcXF1cXF0+L2csICckMScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QubGVuZ3RoO1xuICAgICAgICAgIGh0bWwgPSByZXN0O1xuICAgICAgICAgIHBhcnNlRW5kVGFnKCc8LycgKyBzdGFja2VkVGFnICsgJz4nLCBzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgICAgICB9KSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHBhcnNpbmcgdGVtcGxhdGU6XFxuXFxuJyArIGh0bWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICAgIHBhcnNlRW5kVGFnKCk7XG5cbiAgICBmdW5jdGlvbiBhZHZhbmNlKG4pIHtcbiAgICAgIGluZGV4ICs9IG47XG4gICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZygpIHtcbiAgICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICAgIGlmIChzdGFydCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgICB9O1xuICAgICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICAgIHZhciBlbmQgPSB2b2lkIDAsXG4gICAgICAgICAgICBhdHRyID0gdm9pZCAwO1xuICAgICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcobWF0Y2gpIHtcbiAgICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoJycsIGxhc3RUYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgICBwYXJzZUVuZFRhZygnJywgdGFnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyh0YWdOYW1lKSB8fCB0YWdOYW1lID09PSAnaHRtbCcgJiYgbGFzdFRhZyA9PT0gJ2hlYWQnIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgICAgaWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XG4gICAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7XG4gICAgICAgICAgICBkZWxldGUgYXJnc1szXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7XG4gICAgICAgICAgICBkZWxldGUgYXJnc1s0XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFyZ3NbNV0gPT09ICcnKSB7XG4gICAgICAgICAgICBkZWxldGUgYXJnc1s1XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgICAgdmFsdWU6IGlzRnJvbURPTSA/IGRlY29kZUF0dHIodmFsdWUsIHNob3VsZERlY29kZVRhZ3MpIDogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgICAgICB1bmFyeVNsYXNoID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUVuZFRhZyh0YWcsIHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG4gICAgICBpZiAoc3RhcnQgPT0gbnVsbCkgc3RhcnQgPSBpbmRleDtcbiAgICAgIGlmIChlbmQgPT0gbnVsbCkgZW5kID0gaW5kZXg7XG5cbiAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICBpZiAodGFnTmFtZSkge1xuICAgICAgICB2YXIgbmVlZGxlID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICAgIGlmIChzdGFja1twb3NdLnRhZy50b0xvd2VyQ2FzZSgpID09PSBuZWVkbGUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgICAgcG9zID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgICAgfSBlbHNlIGlmICh0YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdicicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwJykge1xuICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRmlsdGVycyhleHApIHtcbiAgICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICB2YXIgY3VybHkgPSAwO1xuICAgIHZhciBzcXVhcmUgPSAwO1xuICAgIHZhciBwYXJlbiA9IDA7XG4gICAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gICAgdmFyIGMgPSB2b2lkIDAsXG4gICAgICAgIHByZXYgPSB2b2lkIDAsXG4gICAgICAgIGkgPSB2b2lkIDAsXG4gICAgICAgIGV4cHJlc3Npb24gPSB2b2lkIDAsXG4gICAgICAgIGZpbHRlcnMgPSB2b2lkIDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcmV2ID0gYztcbiAgICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgICAvLyBjaGVjayBzaW5nbGUgcXVvdGVcbiAgICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgaW5TaW5nbGUgPSAhaW5TaW5nbGU7XG4gICAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAgIC8vIGNoZWNrIGRvdWJsZSBxdW90ZVxuICAgICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSBpbkRvdWJsZSA9ICFpbkRvdWJsZTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiYgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlbikge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgY2FzZSAweDIyOlxuICAgICAgICAgICAgaW5Eb3VibGUgPSB0cnVlO2JyZWFrOyAvLyBcIlxuICAgICAgICAgIGNhc2UgMHgyNzpcbiAgICAgICAgICAgIGluU2luZ2xlID0gdHJ1ZTticmVhazsgLy8gJ1xuICAgICAgICAgIGNhc2UgMHgyODpcbiAgICAgICAgICAgIHBhcmVuKys7YnJlYWs7IC8vIChcbiAgICAgICAgICBjYXNlIDB4Mjk6XG4gICAgICAgICAgICBwYXJlbi0tO2JyZWFrOyAvLyApXG4gICAgICAgICAgY2FzZSAweDVCOlxuICAgICAgICAgICAgc3F1YXJlKys7YnJlYWs7IC8vIFtcbiAgICAgICAgICBjYXNlIDB4NUQ6XG4gICAgICAgICAgICBzcXVhcmUtLTticmVhazsgLy8gXVxuICAgICAgICAgIGNhc2UgMHg3QjpcbiAgICAgICAgICAgIGN1cmx5Kys7YnJlYWs7IC8vIHtcbiAgICAgICAgICBjYXNlIDB4N0Q6XG4gICAgICAgICAgICBjdXJseS0tO2JyZWFrOyAvLyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgICAgcHVzaEZpbHRlcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hGaWx0ZXIoKSB7XG4gICAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHByZXNzaW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcEZpbHRlcihleHAsIGZpbHRlcikge1xuICAgIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgICByZXR1cm4gJ19mKFwiJyArIGZpbHRlciArICdcIikoJyArIGV4cCArICcpJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgICByZXR1cm4gJ19mKFwiJyArIG5hbWUgKyAnXCIpKCcgKyBleHAgKyAnLCcgKyBhcmdzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxcXG4pKz8pXFx9XFx9L2c7XG4gIHZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxuICB2YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICAgIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpO1xuICB9KTtcblxuICBmdW5jdGlvbiBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykge1xuICAgIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICAgIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdG9rZW5zID0gW107XG4gICAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG1hdGNoID0gdm9pZCAwLFxuICAgICAgICBpbmRleCA9IHZvaWQgMDtcbiAgICB3aGlsZSAobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSB7XG4gICAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSkpO1xuICAgICAgfVxuICAgICAgLy8gdGFnIHRva2VuXG4gICAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgICB0b2tlbnMucHVzaCgnX3MoJyArIGV4cCArICcpJyk7XG4gICAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucy5qb2luKCcrJyk7XG4gIH1cblxuICBmdW5jdGlvbiBiYXNlV2Fybihtc2cpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbVnVlIHBhcnNlcl06ICcgKyBtc2cpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbihtb2R1bGVzLCBrZXkpIHtcbiAgICByZXR1cm4gbW9kdWxlcyA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgICByZXR1cm4gbVtrZXldO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoXykge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSkgOiBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKSB7XG4gICAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGFyZzogYXJnLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEhvb2soZWwsIG5hbWUsIGNvZGUpIHtcbiAgICB2YXIgaG9va3MgPSBlbC5ob29rcyB8fCAoZWwuaG9va3MgPSB7fSk7XG4gICAgdmFyIGhvb2sgPSBob29rc1tuYW1lXTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaG9vaykge1xuICAgICAgaG9vay5wdXNoKGNvZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rc1tuYW1lXSA9IFtjb2RlXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzKSB7XG4gICAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICAgIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICAgIH1cbiAgICB2YXIgZXZlbnRzID0gdm9pZCAwO1xuICAgIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gICAgfVxuICAgIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUsIG1vZGlmaWVyczogbW9kaWZpZXJzIH07XG4gICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgICBldmVudHNbbmFtZV0gPSBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyKGVsLCBuYW1lLCBnZXRTdGF0aWMpIHtcbiAgICB2YXIgZHluYW1pY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gICAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZHluYW1pY1ZhbHVlO1xuICAgIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpIHtcbiAgICB2YXIgdmFsID0gdm9pZCAwO1xuICAgIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHZhciBkaXJSRSA9IC9edi18XkB8XjovO1xuICB2YXIgZm9yQWxpYXNSRSA9IC8oLiopXFxzKyg/OmlufG9mKVxccysoLiopLztcbiAgdmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XG4gIHZhciBiaW5kUkUgPSAvXjp8XnYtYmluZDovO1xuICB2YXIgb25SRSA9IC9eQHxedi1vbjovO1xuICB2YXIgYXJnUkUgPSAvOiguKikkLztcbiAgdmFyIG1vZGlmaWVyUkUgPSAvXFwuW15cXC5dKy9nO1xuXG4gIHZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGRlY29kZUhUTUwpO1xuXG4gIC8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxuICB2YXIgd2FybiQxID0gdm9pZCAwO1xuICB2YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSB2b2lkIDA7XG4gIHZhciBwbGF0Zm9ybU11c3RVc2VQcm9wID0gdm9pZCAwO1xuICB2YXIgcGxhdGZvcm1Jc1ByZVRhZyA9IHZvaWQgMDtcbiAgdmFyIHByZVRyYW5zZm9ybXMgPSB2b2lkIDA7XG4gIHZhciB0cmFuc2Zvcm1zID0gdm9pZCAwO1xuICB2YXIgcG9zdFRyYW5zZm9ybXMgPSB2b2lkIDA7XG4gIHZhciBkZWxpbWl0ZXJzID0gdm9pZCAwO1xuICB2YXIgc2VlblNsb3RzID0gdm9pZCAwO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gICAgd2FybiQxID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gICAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gICAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gICAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICAgIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcbiAgICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuICAgIHNlZW5TbG90cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgICB2YXIgcm9vdCA9IHZvaWQgMDtcbiAgICB2YXIgY3VycmVudFBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gICAgdmFyIGluUHJlID0gZmFsc2U7XG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgICAgaXNGcm9tRE9NOiBvcHRpb25zLmlzRnJvbURPTSxcbiAgICAgIHNob3VsZERlY29kZVRhZ3M6IG9wdGlvbnMuc2hvdWxkRGVjb2RlVGFncyxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICB2YXIgbnMgPSBjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKG9wdGlvbnMuaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgdHlwZTogMSxcbiAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgICAgICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgICAgICAgIHBhcmVudDogY3VycmVudFBhcmVudCxcbiAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwiY2xpZW50XCIgIT09ICdzZXJ2ZXInICYmIGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpKSB7XG4gICAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMSgnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNiaWxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgKyAoJzwnICsgdGFnICsgJz4uJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuXG4gICAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgICAgICAgICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgICAgICAgICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFhdHRycy5sZW5ndGg7XG5cbiAgICAgICAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuICAgICAgICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gICAgICAgICAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG4gICAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXNbX2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyhlbCkge1xuICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgICB3YXJuJDEoJ0Nhbm5vdCB1c2UgPCcgKyBlbC50YWcgKyAnPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5ICcgKyAnY29udGFpbiBtdWx0aXBsZSBub2RlczpcXG4nICsgdGVtcGxhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICAgIHdhcm4kMSgnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzOlxcbicgKyB0ZW1wbGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgIXdhcm5lZCkge1xuICAgICAgICAgIC8vIGFsbG93IDIgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYgYW5kIHYtZWxzZVxuICAgICAgICAgIGlmIChyb290LmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWlmJykgJiYgZWxlbWVudC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1lbHNlJykpIHtcbiAgICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgd2FybiQxKCdDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50OlxcblxcbicgKyB0ZW1wbGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICAgIGlmIChlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICAgIHByb2Nlc3NFbHNlKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgcG9zdFRyYW5zZm9ybXNbX2kyXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVuZDogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJykge1xuICAgICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgICBpblByZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzKHRleHQpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICF3YXJuZWQpIHtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB3YXJuJDEoJ0NvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQ6XFxuXFxuJyArIHRlbXBsYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKSA/IGRlY29kZUhUTUxDYWNoZWQodGV4dClcbiAgICAgICAgLy8gb25seSBwcmVzZXJ2ZSB3aGl0ZXNwYWNlIGlmIGl0cyBub3QgcmlnaHQgYWZ0ZXIgYSBzdGFydGluZyB0YWdcbiAgICAgICAgOiBwcmVzZXJ2ZVdoaXRlc3BhY2UgJiYgY3VycmVudFBhcmVudC5jaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzUHJlKGVsKSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICAgIGVsLnByZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzKGVsKSB7XG4gICAgdmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xuICAgIGlmIChsKSB7XG4gICAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgICBlbC5wbGFpbiA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0tleShlbCkge1xuICAgIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICAgIGlmIChleHApIHtcbiAgICAgIGVsLmtleSA9IGV4cDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzUmVmKGVsKSB7XG4gICAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gICAgaWYgKHJlZikge1xuICAgICAgZWwucmVmID0gcmVmO1xuICAgICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRm9yKGVsKSB7XG4gICAgdmFyIGV4cCA9IHZvaWQgMDtcbiAgICBpZiAoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpIHtcbiAgICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgICAgaWYgKCFpbk1hdGNoKSB7XG4gICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMSgnSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiAnICsgZXhwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWwuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgICBlbC5hbGlhcyA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICBlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbM10pIHtcbiAgICAgICAgICBlbC5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzNdLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuYWxpYXMgPSBhbGlhcztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzSWYoZWwpIHtcbiAgICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgICBpZiAoZXhwKSB7XG4gICAgICBlbC5pZiA9IGV4cDtcbiAgICB9XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRWxzZShlbCwgcGFyZW50KSB7XG4gICAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgICBwcmV2LmVsc2VCbG9jayA9IGVsO1xuICAgIH0gZWxzZSBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4kMSgndi1lbHNlIHVzZWQgb24gZWxlbWVudCA8JyArIGVsLnRhZyArICc+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NPbmNlKGVsKSB7XG4gICAgdmFyIG9uY2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gICAgaWYgKG9uY2UgIT0gbnVsbCkge1xuICAgICAgZWwub25jZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1Nsb3QoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIWVsLmF0dHJzTWFwWyc6bmFtZSddICYmICFlbC5hdHRyc01hcFsndi1iaW5kOm5hbWUnXSAmJiBjaGVja0luRm9yKGVsKSkge1xuICAgICAgICAgIHdhcm4kMSgnU3RhdGljIDxzbG90PiBmb3VuZCBpbnNpZGUgdi1mb3I6IHRoZXkgd2lsbCBub3QgcmVuZGVyIGNvcnJlY3RseS4gJyArICdSZW5kZXIgdGhlIGxpc3QgaW4gcGFyZW50IHNjb3BlIGFuZCB1c2UgYSBzaW5nbGUgPHNsb3Q+IGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBlbC5zbG90TmFtZTtcbiAgICAgICAgaWYgKHNlZW5TbG90c1tuYW1lXSkge1xuICAgICAgICAgIHdhcm4kMSgnRHVwbGljYXRlICcgKyAobmFtZSA/ICc8c2xvdD4gd2l0aCBuYW1lICcgKyBuYW1lIDogJ2RlZmF1bHQgPHNsb3Q+JykgKyAnICcgKyAnZm91bmQgaW4gdGhlIHNhbWUgdGVtcGxhdGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VlblNsb3RzW25hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQoZWwpIHtcbiAgICB2YXIgYmluZGluZyA9IHZvaWQgMDtcbiAgICBpZiAoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkge1xuICAgICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgICB9XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0F0dHJzKGVsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgdmFyIGkgPSB2b2lkIDAsXG4gICAgICAgIGwgPSB2b2lkIDAsXG4gICAgICAgIG5hbWUgPSB2b2lkIDAsXG4gICAgICAgIHZhbHVlID0gdm9pZCAwLFxuICAgICAgICBhcmcgPSB2b2lkIDAsXG4gICAgICAgIG1vZGlmaWVycyA9IHZvaWQgMCxcbiAgICAgICAgaXNQcm9wID0gdm9pZCAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgLy8gdi1iaW5kXG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSBuYW1lID0gJ2lubmVySFRNTCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1Byb3AgfHwgcGxhdGZvcm1NdXN0VXNlUHJvcChuYW1lKSkge1xuICAgICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgIC8vIHYtb25cbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgICBpZiAoYXJnTWF0Y2ggJiYgKGFyZyA9IGFyZ01hdGNoWzFdKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgd2FybiQxKG5hbWUgKyAnPVwiJyArIHZhbHVlICsgJ1wiOiAnICsgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gJyArICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0luRm9yKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1vZGlmaWVycyhuYW1lKSB7XG4gICAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmV0ID0ge307XG4gICAgICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXRbbS5zbGljZSgxKV0gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2OiByZXRcbiAgICAgICAgfTtcbiAgICAgIH0oKTtcblxuICAgICAgaWYgKHR5cGVvZiBfcmV0ID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VBdHRyc01hcChhdHRycykge1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIG1hcFthdHRyc1tpXS5uYW1lXSkge1xuICAgICAgICB3YXJuJDEoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICAgIH1cbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFByZXZFbGVtZW50KGNoaWxkcmVuKSB7XG4gICAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLnRhZykgcmV0dXJuIGNoaWxkcmVuW2ldO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnKGVsKSB7XG4gICAgcmV0dXJuIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fCBlbC50YWcgPT09ICdzY3JpcHQnICYmICghZWwuYXR0cnNNYXAudHlwZSB8fCBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0Jyk7XG4gIH1cblxuICB2YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbiAgdmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcoYXR0cnMpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgICByZXMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIHZhciBpc1N0YXRpY0tleSA9IHZvaWQgMDtcbiAgdmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IHZvaWQgMDtcblxuICB2YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4gIC8qKlxuICAgKiBHb2FsIG9mIHRoZSBvcHRpbWl6aWVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAgICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICAgKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICAgKlxuICAgKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAgICpcbiAgICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICAgKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gICAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICAgKi9cbiAgZnVuY3Rpb24gb3B0aW1pemUocm9vdCwgb3B0aW9ucykge1xuICAgIGlmICghcm9vdCkgcmV0dXJuO1xuICAgIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICAgIG1hcmtTdGF0aWMocm9vdCk7XG4gICAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICAgIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEoa2V5cykge1xuICAgIHJldHVybiBtYWtlTWFwKCd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArIChrZXlzID8gJywnICsga2V5cyA6ICcnKSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGljKG5vZGUpIHtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgbWFya1N0YXRpYyhjaGlsZCk7XG4gICAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyhub2RlLCBpc0luRm9yKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgaWYgKG5vZGUub25jZSB8fCBub2RlLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCAhIW5vZGUuZm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RhdGljKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgICAvLyBleHByZXNzaW9uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09IDMpIHtcbiAgICAgIC8vIHRleHRcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gISEobm9kZS5wcmUgfHwgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpKTtcbiAgfVxuXG4gIHZhciBzaW1wbGVQYXRoUkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPydcXF18XFxbXCIuKj9cIlxcXXxcXFtcXGQrXFxdfFxcW1tBLVphLXpfJF1bXFx3JF0qXFxdKSokLztcblxuICAvLyBrZXlDb2RlIGFsaWFzZXNcbiAgdmFyIGtleUNvZGVzID0ge1xuICAgIGVzYzogMjcsXG4gICAgdGFiOiA5LFxuICAgIGVudGVyOiAxMyxcbiAgICBzcGFjZTogMzIsXG4gICAgdXA6IDM4LFxuICAgIGxlZnQ6IDM3LFxuICAgIHJpZ2h0OiAzOSxcbiAgICBkb3duOiA0MCxcbiAgICAnZGVsZXRlJzogWzgsIDQ2XVxuICB9O1xuXG4gIHZhciBtb2RpZmllckNvZGUgPSB7XG4gICAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICAgIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICAgIHNlbGY6ICdpZigkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldClyZXR1cm47J1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdlbkhhbmRsZXJzKGV2ZW50cywgbmF0aXZlKSB7XG4gICAgdmFyIHJlcyA9IG5hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgICAgcmVzICs9ICdcIicgKyBuYW1lICsgJ1wiOicgKyBnZW5IYW5kbGVyKGV2ZW50c1tuYW1lXSkgKyAnLCc7XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICByZXR1cm4gJ1snICsgaGFuZGxlci5tYXAoZ2VuSGFuZGxlcikuam9pbignLCcpICsgJ10nO1xuICAgIH0gZWxzZSBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICByZXR1cm4gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSkgPyBoYW5kbGVyLnZhbHVlIDogJ2Z1bmN0aW9uKCRldmVudCl7JyArIGhhbmRsZXIudmFsdWUgKyAnfSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb2RlID0gJ2Z1bmN0aW9uKCRldmVudCl7JztcbiAgICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgICBjb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldIHx8IGdlbktleUZpbHRlcihrZXkpO1xuICAgICAgfVxuICAgICAgdmFyIGhhbmRsZXJDb2RlID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSkgPyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJyA6IGhhbmRsZXIudmFsdWU7XG4gICAgICByZXR1cm4gY29kZSArIGhhbmRsZXJDb2RlICsgJ30nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbktleUZpbHRlcihrZXkpIHtcbiAgICB2YXIgY29kZSA9IHBhcnNlSW50KGtleSwgMTApIHx8IC8vIG51bWJlciBrZXlDb2RlXG4gICAga2V5Q29kZXNba2V5XSB8fCAvLyBidWlsdC1pbiBhbGlhc1xuICAgICdfaygnICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICcpJzsgLy8gY3VzdG9tIGFsaWFzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29kZSkpIHtcbiAgICAgIHJldHVybiAnaWYoJyArIGNvZGUubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiAnJGV2ZW50LmtleUNvZGUhPT0nICsgYztcbiAgICAgIH0pLmpvaW4oJyYmJykgKyAnKXJldHVybjsnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ2lmKCRldmVudC5rZXlDb2RlIT09JyArIGNvZGUgKyAnKXJldHVybjsnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmQkMShlbCwgZGlyKSB7XG4gICAgYWRkSG9vayhlbCwgJ2NvbnN0cnVjdCcsICdfYihuMSwnICsgZGlyLnZhbHVlICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJyx0cnVlJyA6ICcnKSArICcpJyk7XG4gIH1cblxuICB2YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gICAgYmluZDogYmluZCQxLFxuICAgIGNsb2FrOiBub29wXG4gIH07XG5cbiAgLy8gY29uZmlndXJhYmxlIHN0YXRlXG4gIHZhciB3YXJuJDIgPSB2b2lkIDA7XG4gIHZhciB0cmFuc2Zvcm1zJDEgPSB2b2lkIDA7XG4gIHZhciBkYXRhR2VuRm5zID0gdm9pZCAwO1xuICB2YXIgcGxhdGZvcm1EaXJlY3RpdmVzJDEgPSB2b2lkIDA7XG4gIHZhciBzdGF0aWNSZW5kZXJGbnMgPSB2b2lkIDA7XG4gIHZhciBjdXJyZW50T3B0aW9ucyA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpIHtcbiAgICAvLyBzYXZlIHByZXZpb3VzIHN0YXRpY1JlbmRlckZucyBzbyBnZW5lcmF0ZSBjYWxscyBjYW4gYmUgbmVzdGVkXG4gICAgdmFyIHByZXZTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG4gICAgdmFyIGN1cnJlbnRTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgICBjdXJyZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHRyYW5zZm9ybXMkMSA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICAgIGRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgICBwbGF0Zm9ybURpcmVjdGl2ZXMkMSA9IG9wdGlvbnMuZGlyZWN0aXZlcyB8fCB7fTtcbiAgICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0KSA6ICdfaChcImRpdlwiKSc7XG4gICAgc3RhdGljUmVuZGVyRm5zID0gcHJldlN0YXRpY1JlbmRlckZucztcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyOiAnd2l0aCh0aGlzKXtyZXR1cm4gJyArIGNvZGUgKyAnfScsXG4gICAgICBzdGF0aWNSZW5kZXJGbnM6IGN1cnJlbnRTdGF0aWNSZW5kZXJGbnNcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRWxlbWVudChlbCkge1xuICAgIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICAgIC8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG4gICAgICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgc3RhdGljUmVuZGVyRm5zLnB1c2goJ3dpdGgodGhpcyl7cmV0dXJuICcgKyBnZW5FbGVtZW50KGVsKSArICd9Jyk7XG4gICAgICByZXR1cm4gJ19tKCcgKyAoc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArICcpJztcbiAgICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuRm9yKGVsKTtcbiAgICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlbklmKGVsKTtcbiAgICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xuICAgICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJztcbiAgICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gZ2VuU2xvdChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgICB2YXIgY29kZSA9IHZvaWQgMDtcbiAgICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGF0YSA9IGdlbkRhdGEoZWwpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCk7XG4gICAgICAgIGNvZGUgPSAnX2goXFwnJyArIGVsLnRhZyArICdcXCcnICsgKGRhdGEgPyAnLCcgKyBkYXRhIDogJycgLy8gZGF0YVxuICAgICAgICApICsgKGNoaWxkcmVuID8gJywnICsgY2hpbGRyZW4gOiAnJyAvLyBjaGlsZHJlblxuICAgICAgICApICsgJyknO1xuICAgICAgfVxuICAgICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtcyQxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSB0cmFuc2Zvcm1zJDFbaV0oZWwsIGNvZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuSWYoZWwpIHtcbiAgICB2YXIgZXhwID0gZWwuaWY7XG4gICAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgICByZXR1cm4gJygnICsgZXhwICsgJyk/JyArIGdlbkVsZW1lbnQoZWwpICsgJzonICsgZ2VuRWxzZShlbCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5FbHNlKGVsKSB7XG4gICAgcmV0dXJuIGVsLmVsc2VCbG9jayA/IGdlbkVsZW1lbnQoZWwuZWxzZUJsb2NrKSA6ICd2b2lkIDAnO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRm9yKGVsKSB7XG4gICAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gJywnICsgZWwuaXRlcmF0b3IxIDogJyc7XG4gICAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/ICcsJyArIGVsLml0ZXJhdG9yMiA6ICcnO1xuICAgIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICAgIHJldHVybiAnKCcgKyBleHAgKyAnKSYmX2woKCcgKyBleHAgKyAnKSwnICsgKCdmdW5jdGlvbignICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyAnKXsnKSArICgncmV0dXJuICcgKyBnZW5FbGVtZW50KGVsKSkgKyAnfSknO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGF0YShlbCkge1xuICAgIGlmIChlbC5wbGFpbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gJ3snO1xuXG4gICAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICAgIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCk7XG4gICAgaWYgKGRpcnMpIGRhdGEgKz0gZGlycyArICcsJztcblxuICAgIC8vIGtleVxuICAgIGlmIChlbC5rZXkpIHtcbiAgICAgIGRhdGEgKz0gJ2tleTonICsgZWwua2V5ICsgJywnO1xuICAgIH1cbiAgICAvLyByZWZcbiAgICBpZiAoZWwucmVmKSB7XG4gICAgICBkYXRhICs9ICdyZWY6JyArIGVsLnJlZiArICcsJztcbiAgICB9XG4gICAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgICBkYXRhICs9ICdyZWZJbkZvcjp0cnVlLCc7XG4gICAgfVxuICAgIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgZGF0YSArPSAndGFnOlwiJyArIGVsLnRhZyArICdcIiwnO1xuICAgIH1cbiAgICAvLyBzbG90IHRhcmdldFxuICAgIGlmIChlbC5zbG90VGFyZ2V0KSB7XG4gICAgICBkYXRhICs9ICdzbG90OicgKyBlbC5zbG90VGFyZ2V0ICsgJywnO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSArPSBkYXRhR2VuRm5zW2ldKGVsKTtcbiAgICB9XG4gICAgLy8gdi1zaG93LCB1c2VkIHRvIGF2b2lkIHRyYW5zaXRpb24gYmVpbmcgYXBwbGllZFxuICAgIC8vIHNpbmNlIHYtc2hvdyB0YWtlcyBpdCBvdmVyXG4gICAgaWYgKGVsLmF0dHJzTWFwWyd2LXNob3cnXSkge1xuICAgICAgZGF0YSArPSAnc2hvdzp0cnVlLCc7XG4gICAgfVxuICAgIC8vIGF0dHJpYnV0ZXNcbiAgICBpZiAoZWwuYXR0cnMpIHtcbiAgICAgIGRhdGEgKz0gJ2F0dHJzOnsnICsgZ2VuUHJvcHMoZWwuYXR0cnMpICsgJ30sJztcbiAgICB9XG4gICAgLy8gRE9NIHByb3BzXG4gICAgaWYgKGVsLnByb3BzKSB7XG4gICAgICBkYXRhICs9ICdkb21Qcm9wczp7JyArIGdlblByb3BzKGVsLnByb3BzKSArICd9LCc7XG4gICAgfVxuICAgIC8vIGhvb2tzXG4gICAgaWYgKGVsLmhvb2tzKSB7XG4gICAgICBkYXRhICs9ICdob29rOnsnICsgZ2VuSG9va3MoZWwuaG9va3MpICsgJ30sJztcbiAgICB9XG4gICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgICBkYXRhICs9IGdlbkhhbmRsZXJzKGVsLmV2ZW50cykgKyAnLCc7XG4gICAgfVxuICAgIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICAgIGRhdGEgKz0gZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKSArICcsJztcbiAgICB9XG4gICAgLy8gaW5saW5lLXRlbXBsYXRlXG4gICAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgKGVsLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgYXN0LnR5cGUgIT09IDEpKSB7XG4gICAgICAgIHdhcm4kMignSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gICAgICB9XG4gICAgICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcbiAgICAgICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgY3VycmVudE9wdGlvbnMpO1xuICAgICAgICBkYXRhICs9ICdpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7JyArIGlubGluZVJlbmRlckZucy5yZW5kZXIgKyAnfSxzdGF0aWNSZW5kZXJGbnM6WycgKyBpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIHJldHVybiAnZnVuY3Rpb24oKXsnICsgY29kZSArICd9JztcbiAgICAgICAgfSkuam9pbignLCcpICsgJ119JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5EaXJlY3RpdmVzKGVsKSB7XG4gICAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICAgIGlmICghZGlycykgcmV0dXJuO1xuICAgIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICAgIHZhciBpID0gdm9pZCAwLFxuICAgICAgICBsID0gdm9pZCAwLFxuICAgICAgICBkaXIgPSB2b2lkIDAsXG4gICAgICAgIG5lZWRSdW50aW1lID0gdm9pZCAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZGlyID0gZGlyc1tpXTtcbiAgICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHZhciBnZW4gPSBwbGF0Zm9ybURpcmVjdGl2ZXMkMVtkaXIubmFtZV0gfHwgYmFzZURpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgICAgaWYgKGdlbikge1xuICAgICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgd2FybiQyKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgICAgcmVzICs9ICd7bmFtZTpcIicgKyBkaXIubmFtZSArICdcIicgKyAoZGlyLnZhbHVlID8gJyx2YWx1ZTooJyArIGRpci52YWx1ZSArICcpLGV4cHJlc3Npb246JyArIEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkgOiAnJykgKyAoZGlyLmFyZyA/ICcsYXJnOlwiJyArIGRpci5hcmcgKyAnXCInIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAnLG1vZGlmaWVyczonICsgSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykgOiAnJykgKyAnfSwnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzUnVudGltZSkge1xuICAgICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuQ2hpbGRyZW4oZWwpIHtcbiAgICBpZiAoZWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gJ1snICsgZWwuY2hpbGRyZW4ubWFwKGdlbk5vZGUpLmpvaW4oJywnKSArICddJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5Ob2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdlblRleHQobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQudHlwZSA9PT0gMiA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiBKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2xvdChlbCkge1xuICAgIHZhciBzbG90ID0gJyRzbG90c1snICsgKGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIicpICsgJ10nO1xuICAgIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsKTtcbiAgICByZXR1cm4gY2hpbGRyZW4gPyAnKCcgKyBzbG90ICsgJ3x8JyArIGNoaWxkcmVuICsgJyknIDogc2xvdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkNvbXBvbmVudChlbCkge1xuICAgIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsKTtcbiAgICByZXR1cm4gJ19oKCcgKyBlbC5jb21wb25lbnQgKyAnLCcgKyBnZW5EYXRhKGVsKSArIChjaGlsZHJlbiA/ICcsJyArIGNoaWxkcmVuIDogJycpICsgJyknO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuUHJvcHMocHJvcHMpIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIHJlcyArPSAnXCInICsgcHJvcC5uYW1lICsgJ1wiOicgKyBwcm9wLnZhbHVlICsgJywnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkhvb2tzKGhvb2tzKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIF9rZXkgaW4gaG9va3MpIHtcbiAgICAgIHJlcyArPSAnXCInICsgX2tleSArICdcIjpmdW5jdGlvbihuMSxuMil7JyArIGhvb2tzW19rZXldLmpvaW4oJzsnKSArICd9LCc7XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgYSB0ZW1wbGF0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBpbGUkMSh0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICAgIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gICAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICBhc3Q6IGFzdCxcbiAgICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gICAgfTtcbiAgfVxuXG4gIC8vIG9wZXJhdG9ycyBsaWtlIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbiAgdmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJykuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG4gIC8vIGNoZWNrIHZhbGlkIGlkZW50aWZpZXIgZm9yIHYtZm9yXG4gIHZhciBpZGVudFJFID0gL1tBLVphLXpfJF1bXFx3JF0qLztcbiAgLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xuICB2YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4gIC8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG4gIGZ1bmN0aW9uIGRldGVjdEVycm9ycyhhc3QpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgaWYgKGFzdCkge1xuICAgICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrTm9kZShub2RlLCBlcnJvcnMpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgJ3YtZm9yPVwiJyArIHZhbHVlICsgJ1wiJywgZXJyb3JzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgbmFtZSArICc9XCInICsgdmFsdWUgKyAnXCInLCBlcnJvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRm9yKG5vZGUsIHRleHQsIGVycm9ycykge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcbiAgICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyKGlkZW50LCB0eXBlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJyAmJiAhaWRlbnRSRS50ZXN0KGlkZW50KSkge1xuICAgICAgZXJyb3JzLnB1c2goJy0gaW52YWxpZCAnICsgdHlwZSArICcgXCInICsgaWRlbnQgKyAnXCIgaW4gZXhwcmVzc2lvbjogJyArIHRleHQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgZXhwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgICBlcnJvcnMucHVzaCgnLSBhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogJyArICgnXCInICsga2V5d29yZE1hdGNoWzBdICsgJ1wiIGluIGV4cHJlc3Npb24gJyArIHRleHQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy5wdXNoKCctIGludmFsaWQgZXhwcmVzc2lvbjogJyArIHRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUoZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgd2FybignY2xhc3M9XCInICsgc3RhdGljQ2xhc3MgKyAnXCI6ICcgKyAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiBkZXByZWNhdGVkLiAnICsgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICAgIH1cbiAgICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gICAgaWYgKGNsYXNzQmluZGluZykge1xuICAgICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRhdGEkMShlbCkge1xuICAgIHZhciBkYXRhID0gJyc7XG4gICAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgICBkYXRhICs9ICdzdGF0aWNDbGFzczonICsgZWwuc3RhdGljQ2xhc3MgKyAnLCc7XG4gICAgfVxuICAgIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICAgIGRhdGEgKz0gJ2NsYXNzOicgKyBlbC5jbGFzc0JpbmRpbmcgKyAnLCc7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGtsYXNzJDEgPSB7XG4gICAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICAgIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gICAgZ2VuRGF0YTogZ2VuRGF0YSQxXG4gIH07XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxKGVsKSB7XG4gICAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICAgIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5EYXRhJDIoZWwpIHtcbiAgICByZXR1cm4gZWwuc3R5bGVCaW5kaW5nID8gJ3N0eWxlOignICsgZWwuc3R5bGVCaW5kaW5nICsgJyksJyA6ICcnO1xuICB9XG5cbiAgdmFyIHN0eWxlJDEgPSB7XG4gICAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICAgIGdlbkRhdGE6IGdlbkRhdGEkMlxuICB9O1xuXG4gIHZhciBtb2R1bGVzJDEgPSBba2xhc3MkMSwgc3R5bGUkMV07XG5cbiAgdmFyIHdhcm4kMyA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBtb2RlbCQxKGVsLCBkaXIsIF93YXJuKSB7XG4gICAgd2FybiQzID0gX3dhcm47XG4gICAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICAgIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICAgIGlmIChlbC50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICByZXR1cm4gZ2VuU2VsZWN0KGVsLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoZWwuYXR0cnNNYXAudHlwZSkge1xuICAgICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlKSB7XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwLmNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgd2FybiQzKCc8JyArIGVsLnRhZyArICcgdi1tb2RlbD1cIicgKyB2YWx1ZSArICdcIiBjaGVja2VkPjpcXG4nICsgJ2lubGluZSBjaGVja2VkIGF0dHJpYnV0ZXMgd2lsbCBiZSBpZ25vcmVkIHdoZW4gdXNpbmcgdi1tb2RlbC4gJyArICdEZWNsYXJlIGluaXRpYWwgdmFsdWVzIGluIHRoZSBjb21wb25lbnRcXCdzIGRhdGEgb3B0aW9uIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJyk7XG4gICAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gICAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gICAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAnQXJyYXkuaXNBcnJheSgnICsgdmFsdWUgKyAnKScgKyAoJz8oJyArIHZhbHVlICsgJykuaW5kZXhPZignICsgdmFsdWVCaW5kaW5nICsgJyk+LTEnKSArICgnOignICsgdmFsdWUgKyAnKT09PSgnICsgdHJ1ZVZhbHVlQmluZGluZyArICcpJykpO1xuICAgIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCAndmFyICQkYT0nICsgdmFsdWUgKyAnLCcgKyAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgKyAoJyQkYz0kJGVsLmNoZWNrZWQ/KCcgKyB0cnVlVmFsdWVCaW5kaW5nICsgJyk6KCcgKyBmYWxzZVZhbHVlQmluZGluZyArICcpOycpICsgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArICgndmFyICQkdj0nICsgdmFsdWVCaW5kaW5nICsgJywnKSArICckJGk9JCRhLmluZGV4T2YoJCR2KTsnICsgKCdpZigkJGMpeyQkaTwwJiYoJyArIHZhbHVlICsgJz0kJGEuY29uY2F0KCQkdikpfScpICsgKCdlbHNleyQkaT4tMSYmKCcgKyB2YWx1ZSArICc9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfScpICsgKCd9ZWxzZXsnICsgdmFsdWUgKyAnPSQkY30nKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSkge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5hdHRyc01hcC5jaGVja2VkICE9IG51bGwpIHtcbiAgICAgIHdhcm4kMygnPCcgKyBlbC50YWcgKyAnIHYtbW9kZWw9XCInICsgdmFsdWUgKyAnXCIgY2hlY2tlZD46XFxuJyArICdpbmxpbmUgY2hlY2tlZCBhdHRyaWJ1dGVzIHdpbGwgYmUgaWdub3JlZCB3aGVuIHVzaW5nIHYtbW9kZWwuICcgKyAnRGVjbGFyZSBpbml0aWFsIHZhbHVlcyBpbiB0aGUgY29tcG9uZW50XFwncyBkYXRhIG9wdGlvbiBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpO1xuICAgIGFkZFByb3AoZWwsICdjaGVja2VkJywgJygnICsgdmFsdWUgKyAnKT09PSgnICsgdmFsdWVCaW5kaW5nICsgJyknKTtcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgdmFsdWUgKyAnPScgKyB2YWx1ZUJpbmRpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKSB7XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZWwudGFnID09PSAnaW5wdXQnICYmIGVsLmF0dHJzTWFwLnZhbHVlKSB7XG4gICAgICAgIHdhcm4kMygnPCcgKyBlbC50YWcgKyAnIHYtbW9kZWw9XCInICsgdmFsdWUgKyAnXCIgdmFsdWU9XCInICsgZWwuYXR0cnNNYXAudmFsdWUgKyAnXCI+OlxcbicgKyAnaW5saW5lIHZhbHVlIGF0dHJpYnV0ZXMgd2lsbCBiZSBpZ25vcmVkIHdoZW4gdXNpbmcgdi1tb2RlbC4gJyArICdEZWNsYXJlIGluaXRpYWwgdmFsdWVzIGluIHRoZSBjb21wb25lbnRcXCdzIGRhdGEgb3B0aW9uIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgICBpZiAoZWwudGFnID09PSAndGV4dGFyZWEnICYmIGVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB3YXJuJDMoJzx0ZXh0YXJlYSB2LW1vZGVsPVwiJyArIHZhbHVlICsgJ1wiPjpcXG4nICsgJ2lubGluZSBjb250ZW50IGluc2lkZSA8dGV4dGFyZWE+IHdpbGwgYmUgaWdub3JlZCB3aGVuIHVzaW5nIHYtbW9kZWwuICcgKyAnRGVjbGFyZSBpbml0aWFsIHZhbHVlcyBpbiB0aGUgY29tcG9uZW50XFwncyBkYXRhIG9wdGlvbiBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAgIHZhciBfcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuXG4gICAgdmFyIGxhenkgPSBfcmVmLmxhenk7XG4gICAgdmFyIG51bWJlciA9IF9yZWYubnVtYmVyO1xuICAgIHZhciB0cmltID0gX3JlZi50cmltO1xuXG4gICAgdmFyIGV2ZW50ID0gbGF6eSB8fCBpc0lFICYmIHR5cGUgPT09ICdyYW5nZScgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgICB2YXIgaXNOYXRpdmUgPSBlbC50YWcgPT09ICdpbnB1dCcgfHwgZWwudGFnID09PSAndGV4dGFyZWEnO1xuXG4gICAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGlzTmF0aXZlID8gJyRldmVudC50YXJnZXQudmFsdWUnICsgKHRyaW0gPyAnLnRyaW0oKScgOiAnJykgOiAnJGV2ZW50JztcbiAgICB2YXIgY29kZSA9IG51bWJlciB8fCB0eXBlID09PSAnbnVtYmVyJyA/IHZhbHVlICsgJz1fbignICsgdmFsdWVFeHByZXNzaW9uICsgJyknIDogdmFsdWUgKyAnPScgKyB2YWx1ZUV4cHJlc3Npb247XG4gICAgaWYgKGlzTmF0aXZlICYmIG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgICBjb2RlID0gJ2lmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjsnICsgY29kZTtcbiAgICB9XG4gICAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgaXNOYXRpdmUgPyAnX3MoJyArIHZhbHVlICsgJyknIDogJygnICsgdmFsdWUgKyAnKScpO1xuICAgIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlKTtcbiAgICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICAgIC8vIG5lZWQgcnVudGltZSBkaXJlY3RpdmUgY29kZSB0byBoZWxwIHdpdGggY29tcG9zaXRpb24gZXZlbnRzXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5TZWxlY3QoZWwsIHZhbHVlKSB7XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBlbC5jaGlsZHJlbi5zb21lKGNoZWNrT3B0aW9uV2FybmluZyk7XG4gICAgfVxuICAgIHZhciBjb2RlID0gdmFsdWUgKyAnPUFycmF5LnByb3RvdHlwZS5maWx0ZXInICsgJy5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pJyArICcubWFwKGZ1bmN0aW9uKG8pe3JldHVybiBcIl92YWx1ZVwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWV9KScgKyAoZWwuYXR0cnNNYXAubXVsdGlwbGUgPT0gbnVsbCA/ICdbMF0nIDogJycpO1xuICAgIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlKTtcbiAgICAvLyBuZWVkIHJ1bnRpbWUgdG8gaGVscCB3aXRoIHBvc3NpYmxlIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBvcHRpb25zXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja09wdGlvbldhcm5pbmcob3B0aW9uKSB7XG4gICAgaWYgKG9wdGlvbi50eXBlID09PSAxICYmIG9wdGlvbi50YWcgPT09ICdvcHRpb24nICYmIG9wdGlvbi5hdHRyc01hcC5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICB2YXIgcGFyZW50TW9kZWwgPSBvcHRpb24ucGFyZW50ICYmIG9wdGlvbi5wYXJlbnQudHlwZSA9PT0gMSAmJiBvcHRpb24ucGFyZW50LmF0dHJzTWFwWyd2LW1vZGVsJ107XG4gICAgICB3YXJuJDMoJzxzZWxlY3Qgdi1tb2RlbD1cIicgKyBwYXJlbnRNb2RlbCArICdcIj46XFxuJyArICdpbmxpbmUgc2VsZWN0ZWQgYXR0cmlidXRlcyBvbiA8b3B0aW9uPiB3aWxsIGJlIGlnbm9yZWQgd2hlbiB1c2luZyB2LW1vZGVsLiAnICsgJ0RlY2xhcmUgaW5pdGlhbCB2YWx1ZXMgaW4gdGhlIGNvbXBvbmVudFxcJ3MgZGF0YSBvcHRpb24gaW5zdGVhZC4nKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHQoZWwsIGRpcikge1xuICAgIGlmIChkaXIudmFsdWUpIHtcbiAgICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsICdfcygnICsgZGlyLnZhbHVlICsgJyknKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBodG1sKGVsLCBkaXIpIHtcbiAgICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgJ19zKCcgKyBkaXIudmFsdWUgKyAnKScpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkaXJlY3RpdmVzJDEgPSB7XG4gICAgbW9kZWw6IG1vZGVsJDEsXG4gICAgdGV4dDogdGV4dCxcbiAgICBodG1sOiBodG1sXG4gIH07XG5cbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB2YXIgYmFzZU9wdGlvbnMgPSB7XG4gICAgaXNJRTogaXNJRSxcbiAgICBleHBlY3RIVE1MOiB0cnVlLFxuICAgIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSksXG4gICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICAgIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gICAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gICAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gICAgaXNQcmVUYWc6IGlzUHJlVGFnXG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKSA6IGJhc2VPcHRpb25zO1xuICAgIHJldHVybiBjb21waWxlJDEodGVtcGxhdGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCBvcHRpb25zLCB2bSkge1xuICAgIHZhciBfd2FybiA9IG9wdGlvbnMgJiYgb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIF93YXJuKCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICsgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgKyAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgKyAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBrZXkgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVycyA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGUgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcbiAgICByZXMucmVuZGVyID0gbWFrZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlcik7XG4gICAgdmFyIGwgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlcy5zdGF0aWNSZW5kZXJGbnNbaV0gPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zW2ldKTtcbiAgICB9XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocmVzLnJlbmRlciA9PT0gbm9vcCB8fCByZXMuc3RhdGljUmVuZGVyRm5zLnNvbWUoZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbiA9PT0gbm9vcDtcbiAgICAgIH0pKSB7XG4gICAgICAgIF93YXJuKCdmYWlsZWQgdG8gY29tcGlsZSB0ZW1wbGF0ZTpcXG5cXG4nICsgdGVtcGxhdGUgKyAnXFxuXFxuJyArIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpLmpvaW4oJ1xcbicpICsgJ1xcblxcbicsIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2tleV0gPSByZXM7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlRnVuY3Rpb24oY29kZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICAgIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUw7XG4gIH0pO1xuXG4gIHZhciBtb3VudCA9IFZ1ZS5wcm90b3R5cGUuJG1vdW50O1xuICBWdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChlbCwgaHlkcmF0aW5nKSB7XG4gICAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gICAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICAgIHZhciBpc0Zyb21ET00gPSBmYWxzZTtcbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgaXNGcm9tRE9NID0gdHJ1ZTtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgICBpc0Zyb21ET00gPSB0cnVlO1xuICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgICAgaXNGcm9tRE9NID0gdHJ1ZTtcbiAgICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgICAgfVxuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBfY29tcGlsZVRvRnVuY3Rpb25zID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgICAgd2Fybjogd2FybixcbiAgICAgICAgICBpc0Zyb21ET006IGlzRnJvbURPTSxcbiAgICAgICAgICBzaG91bGREZWNvZGVUYWdzOiBzaG91bGREZWNvZGVUYWdzLFxuICAgICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB2YXIgcmVuZGVyID0gX2NvbXBpbGVUb0Z1bmN0aW9ucy5yZW5kZXI7XG4gICAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSBfY29tcGlsZVRvRnVuY3Rpb25zLnN0YXRpY1JlbmRlckZucztcblxuICAgICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICAgKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE91dGVySFRNTChlbCkge1xuICAgIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICAgIHJldHVybiBlbC5vdXRlckhUTUw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgfVxuICB9XG5cbiAgVnVlLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbiAgcmV0dXJuIFZ1ZTtcblxufSkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmpzIiwidW5kZWZpbmVkXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTs7QUFBQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7O0FBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FDQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FEQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

eval("var __vue_script__, __vue_template__\n__vue_script__ = __webpack_require__(4)\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] resources/assets/js/App.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = __webpack_require__(9)\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (false) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"_v-e5a52b48/App.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvQXBwLnZ1ZT9hODc1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0FwcC52dWVcIilcbmlmIChfX3Z1ZV9zY3JpcHRfXyAmJlxuICAgIF9fdnVlX3NjcmlwdF9fLl9fZXNNb2R1bGUgJiZcbiAgICBPYmplY3Qua2V5cyhfX3Z1ZV9zY3JpcHRfXykubGVuZ3RoID4gMSkge1xuICBjb25zb2xlLndhcm4oXCJbdnVlLWxvYWRlcl0gcmVzb3VyY2VzL2Fzc2V0cy9qcy9BcHAudnVlOiBuYW1lZCBleHBvcnRzIGluICoudnVlIGZpbGVzIGFyZSBpZ25vcmVkLlwiKX1cbl9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtaHRtbC1sb2FkZXIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vQXBwLnZ1ZVwiKVxubW9kdWxlLmV4cG9ydHMgPSBfX3Z1ZV9zY3JpcHRfXyB8fCB7fVxuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuaWYgKF9fdnVlX3RlbXBsYXRlX18pIHtcbih0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIiA/IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zIHx8IChtb2R1bGUuZXhwb3J0cy5vcHRpb25zID0ge30pKSA6IG1vZHVsZS5leHBvcnRzKS50ZW1wbGF0ZSA9IF9fdnVlX3RlbXBsYXRlX19cbn1cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHsgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICB2YXIgaWQgPSBcIl92LWU1YTUyYjQ4L0FwcC52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9BcHAudnVlXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

eval("var __vue_script__, __vue_template__\n__webpack_require__(12)\n__vue_script__ = __webpack_require__(5)\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] resources/assets/js/components/Example.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = __webpack_require__(10)\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (false) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"_v-47d748c6/Example.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9FeGFtcGxlLnZ1ZT9kZDRlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX3Z1ZV9zY3JpcHRfXywgX192dWVfdGVtcGxhdGVfX1xucmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9FeGFtcGxlLnZ1ZVwiKVxuX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0V4YW1wbGUudnVlXCIpXG5pZiAoX192dWVfc2NyaXB0X18gJiZcbiAgICBfX3Z1ZV9zY3JpcHRfXy5fX2VzTW9kdWxlICYmXG4gICAgT2JqZWN0LmtleXMoX192dWVfc2NyaXB0X18pLmxlbmd0aCA+IDEpIHtcbiAgY29uc29sZS53YXJuKFwiW3Z1ZS1sb2FkZXJdIHJlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9FeGFtcGxlLnZ1ZTogbmFtZWQgZXhwb3J0cyBpbiAqLnZ1ZSBmaWxlcyBhcmUgaWdub3JlZC5cIil9XG5fX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhdnVlLWh0bWwtbG9hZGVyIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL0V4YW1wbGUudnVlXCIpXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX3NjcmlwdF9fIHx8IHt9XG5pZiAobW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0XG5pZiAoX192dWVfdGVtcGxhdGVfXykge1xuKHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJmdW5jdGlvblwiID8gKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgfHwgKG1vZHVsZS5leHBvcnRzLm9wdGlvbnMgPSB7fSkpIDogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gX192dWVfdGVtcGxhdGVfX1xufVxuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkgeyAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIHZhciBpZCA9IFwiX3YtNDdkNzQ4YzYvRXhhbXBsZS52dWVcIlxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoaWQsIG1vZHVsZS5leHBvcnRzKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS51cGRhdGUoaWQsIG1vZHVsZS5leHBvcnRzLCBfX3Z1ZV90ZW1wbGF0ZV9fKVxuICB9XG59KSgpfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL0V4YW1wbGUudnVlXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 4 */
/***/ function(module, exports) {

"use strict";
eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// <template>\n//     <router-view></router-view>\n// </template>\n//\n// <script>\nexports.default = {};\n// </script>\n\n/* generated by vue-loader */\n\nmodule.exports = exports[\"default\"];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9BcHAudnVlPzg4MDQiXSwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICAgIDxyb3V0ZXItdmlldz48L3JvdXRlci12aWV3PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICB9XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBBcHAudnVlPzMwNzRjYzAyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFLQTtBQUNBOzs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 5 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// <template>\n//   <div class=\"container\">\n//     <div class=\"content\">\n//       <div class=\"title\">{{ msg }}</div>\n//     </div>\n//   </div>\n// </template>\n//\n// <script>\nexports.default = {\n  data: function data() {\n    return {\n      msg: 'Vue 2.0 + Laravel 5'\n    };\n  }\n};\n// </script>\n//\n// <style>\n//   html, body {\n//     height: 100%;\n//   }\n//\n//   body {\n//     margin: 0;\n//     padding: 0;\n//     width: 100%;\n//     display: table;\n//     font-weight: 100;\n//     font-family: 'Lato';\n//   }\n//\n//   .container {\n//     text-align: center;\n//     display: table-cell;\n//     vertical-align: middle;\n//   }\n//\n//   .content {\n//     text-align: center;\n//     display: inline-block;\n//   }\n//\n//   .title {\n//     font-size: 96px;\n//   }\n// </style>\n\n/* generated by vue-loader */\n\nmodule.exports = exports['default'];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9FeGFtcGxlLnZ1ZT9mYmQ4Il0sInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwidGl0bGVcIj57eyBtc2cgfX08L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICBleHBvcnQgZGVmYXVsdHtcbiAgICBkYXRhICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1zZzogJ1Z1ZSAyLjAgKyBMYXJhdmVsIDUnXG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBodG1sLCBib2R5IHtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gIH1cblxuICBib2R5IHtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiB0YWJsZTtcbiAgICBmb250LXdlaWdodDogMTAwO1xuICAgIGZvbnQtZmFtaWx5OiAnTGF0byc7XG4gIH1cblxuICAuY29udGFpbmVyIHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICB9XG5cbiAgLmNvbnRlbnQge1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIH1cblxuICAudGl0bGUge1xuICAgIGZvbnQtc2l6ZTogOTZweDtcbiAgfVxuPC9zdHlsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBFeGFtcGxlLnZ1ZT8xNGEwY2FiYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQVNBOztBQUVBOztBQUVBO0FBREE7QUFHQTtBQUxBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 6 */
/***/ function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\n\t\tvar this$1 = this;\n\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this$1[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\n\t\tvar this$1 = this;\n\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this$1[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/ZTdmMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 7 */
/***/ function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcz9mY2RmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(6)();\n// imports\n\n\n// module\nexports.push([module.i, \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nhtml, body {\\n  height: 100%;\\n}\\n\\nbody {\\n  margin: 0;\\n  padding: 0;\\n  width: 100%;\\n  display: table;\\n  font-weight: 100;\\n  font-family: 'Lato';\\n}\\n\\n.container {\\n  text-align: center;\\n  display: table-cell;\\n  vertical-align: middle;\\n}\\n\\n.content {\\n  text-align: center;\\n  display: inline-block;\\n}\\n\\n.title {\\n  font-size: 96px;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"/./resources/assets/js/components/Example.vue?14a0cabc\"],\"names\":[],\"mappings\":\";;;;;;;;;;;;;;;;;;;AAmBA;EACA,aAAA;CACA;;AAEA;EACA,UAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,iBAAA;EACA,oBAAA;CACA;;AAEA;EACA,mBAAA;EACA,oBAAA;EACA,uBAAA;CACA;;AAEA;EACA,mBAAA;EACA,sBAAA;CACA;;AAEA;EACA,gBAAA;CACA\",\"file\":\"Example.vue\",\"sourcesContent\":[\"<template>\\n  <div class=\\\"container\\\">\\n    <div class=\\\"content\\\">\\n      <div class=\\\"title\\\">{{ msg }}</div>\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\n  export default{\\n    data () {\\n      return {\\n        msg: 'Vue 2.0 + Laravel 5'\\n      }\\n    }\\n  }\\n</script>\\n\\n<style>\\n  html, body {\\n    height: 100%;\\n  }\\n\\n  body {\\n    margin: 0;\\n    padding: 0;\\n    width: 100%;\\n    display: table;\\n    font-weight: 100;\\n    font-family: 'Lato';\\n  }\\n\\n  .container {\\n    text-align: center;\\n    display: table-cell;\\n    vertical-align: middle;\\n  }\\n\\n  .content {\\n    text-align: center;\\n    display: inline-block;\\n  }\\n\\n  .title {\\n    font-size: 96px;\\n  }\\n</style>\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvY29tcG9uZW50cy9FeGFtcGxlLnZ1ZT80YzE0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuaHRtbCwgYm9keSB7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmJvZHkge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgZGlzcGxheTogdGFibGU7XFxuICBmb250LXdlaWdodDogMTAwO1xcbiAgZm9udC1mYW1pbHk6ICdMYXRvJztcXG59XFxuXFxuLmNvbnRhaW5lciB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuXFxuLmNvbnRlbnQge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG5cXG4udGl0bGUge1xcbiAgZm9udC1zaXplOiA5NnB4O1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL0V4YW1wbGUudnVlPzE0YTBjYWJjXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7RUFDQSxhQUFBO0NBQ0E7O0FBRUE7RUFDQSxVQUFBO0VBQ0EsV0FBQTtFQUNBLFlBQUE7RUFDQSxlQUFBO0VBQ0EsaUJBQUE7RUFDQSxvQkFBQTtDQUNBOztBQUVBO0VBQ0EsbUJBQUE7RUFDQSxvQkFBQTtFQUNBLHVCQUFBO0NBQ0E7O0FBRUE7RUFDQSxtQkFBQTtFQUNBLHNCQUFBO0NBQ0E7O0FBRUE7RUFDQSxnQkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJFeGFtcGxlLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJ0aXRsZVxcXCI+e3sgbXNnIH19PC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcbiAgZXhwb3J0IGRlZmF1bHR7XFxuICAgIGRhdGEgKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBtc2c6ICdWdWUgMi4wICsgTGFyYXZlbCA1J1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbjwvc2NyaXB0PlxcblxcbjxzdHlsZT5cXG4gIGh0bWwsIGJvZHkge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICB9XFxuXFxuICBib2R5IHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGZvbnQtd2VpZ2h0OiAxMDA7XFxuICAgIGZvbnQtZmFtaWx5OiAnTGF0byc7XFxuICB9XFxuXFxuICAuY29udGFpbmVyIHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgfVxcblxcbiAgLmNvbnRlbnQge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIH1cXG5cXG4gIC50aXRsZSB7XFxuICAgIGZvbnQtc2l6ZTogOTZweDtcXG4gIH1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcyEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb21wb25lbnRzL0V4YW1wbGUudnVlXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 9 */
/***/ function(module, exports) {

eval("module.exports = \"\\n<router-view></router-view>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvQXBwLnZ1ZT82YmNmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJcXG48cm91dGVyLXZpZXc+PC9yb3V0ZXItdmlldz5cXG5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9yZXNvdXJjZXMvYXNzZXRzL2pzL0FwcC52dWVcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 10 */
/***/ function(module, exports) {

eval("module.exports = \"\\n<div class=\\\"container\\\">\\n  <div class=\\\"content\\\">\\n    <div class=\\\"title\\\">{{ msg }}</div>\\n  </div>\\n</div>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvRXhhbXBsZS52dWU/NzJiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbnRlbnRcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0aXRsZVxcXCI+e3sgbXNnIH19PC9kaXY+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWh0bWwtbG9hZGVyIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvRXhhbXBsZS52dWVcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/***/ function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\tvar sourceMap = obj.sourceMap;\n\n\tif (media) {\n\t\tstyleElement.setAttribute(\"media\", media);\n\t}\n\n\tif (sourceMap) {\n\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t// this makes source maps inside style tags work properly in Chrome\n\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzP2MyZmMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgbWVtbztcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBtZW1vO1xuXHRcdH07XG5cdH0sXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcblx0fSksXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXHR9KSxcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcblx0XHRpZihuZXdPYmopIHtcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0aWYgKG1lZGlhKSB7XG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcblx0XHQvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG5cdFx0Y3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nO1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(8);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(11)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js?sourceMap!./../../../../node_modules/vue-loader/lib/style-rewriter.js!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./Example.vue\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js?sourceMap!./../../../../node_modules/vue-loader/lib/style-rewriter.js!./../../../../node_modules/vue-loader/lib/selector.js?type=style&index=0!./Example.vue\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvRXhhbXBsZS52dWU/NGZjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vRXhhbXBsZS52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZSZpbmRleD0wIS4vRXhhbXBsZS52dWVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGUmaW5kZXg9MCEuL0V4YW1wbGUudnVlXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzIS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlJmluZGV4PTAhLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbXBvbmVudHMvRXhhbXBsZS52dWVcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_dist_vue_js__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_dist_vue_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue_dist_vue_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__App_vue__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__App_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__App_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue_router__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vue_router___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_vue_router__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_Example_vue__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_Example_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__components_Example_vue__);\n\n\n\n\n__WEBPACK_IMPORTED_MODULE_0_vue_dist_vue_js___default.a.use(__WEBPACK_IMPORTED_MODULE_2_vue_router___default.a)\n\n\n\nvar router = new __WEBPACK_IMPORTED_MODULE_2_vue_router___default.a({\n  mode: 'history',\n  base: 'example',\n  routes: [\n    { path: '/', component: __WEBPACK_IMPORTED_MODULE_3__components_Example_vue___default.a }\n  ]\n})\n\nnew __WEBPACK_IMPORTED_MODULE_0_vue_dist_vue_js___default.a(__WEBPACK_IMPORTED_MODULE_0_vue_dist_vue_js___default.a.util.extend({ router: router }, __WEBPACK_IMPORTED_MODULE_1__App_vue___default.a)).$mount('#app')\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2Fzc2V0cy9qcy9tYWluLmpzPzZlNGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuanMnXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwLnZ1ZSdcbmltcG9ydCBWdWVSb3V0ZXIgZnJvbSAndnVlLXJvdXRlcidcblxuVnVlLnVzZShWdWVSb3V0ZXIpXG5cbmltcG9ydCBFeGFtcGxlIGZyb20gJy4vY29tcG9uZW50cy9FeGFtcGxlLnZ1ZSdcblxuY29uc3Qgcm91dGVyID0gbmV3IFZ1ZVJvdXRlcih7XG4gIG1vZGU6ICdoaXN0b3J5JyxcbiAgYmFzZTogJ2V4YW1wbGUnLFxuICByb3V0ZXM6IFtcbiAgICB7IHBhdGg6ICcvJywgY29tcG9uZW50OiBFeGFtcGxlIH1cbiAgXVxufSlcblxubmV3IFZ1ZShWdWUudXRpbC5leHRlbmQoeyByb3V0ZXIgfSwgQXBwKSkuJG1vdW50KCcjYXBwJylcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL2pzL21haW4uanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
/******/ ]);